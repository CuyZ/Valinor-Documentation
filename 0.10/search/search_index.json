{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Valinor \u2022 PHP object mapper with strong type support Valinor is a PHP library that helps to map any input into a strongly-typed value object structure. The conversion can handle native PHP types as well as other well-known advanced type annotations like array shapes, generics and more. Why? There are many benefits of using value objects instead of plain arrays and scalar values in a modern codebase, among which: Data and behaviour encapsulation \u2014 locks an object's behaviour inside its class, preventing it from being scattered across the codebase. Data validation \u2014 guarantees the valid state of an object. Immutability \u2014 ensures the state of an object cannot be changed during runtime. When mapping any source to an object structure, this library will ensure that all input values are properly converted to match the types of the nodes \u2014 class properties or method parameters. Any value that cannot be converted to the correct type will trigger an error and prevent the mapping from completing. These checks guarantee that if the mapping succeeds, the object structure is perfectly valid, hence there is no need for further validation nor type conversion: the objects are ready to be used. Static analysis A strongly-typed codebase allows the usage of static analysis tools like PHPStan and Psalm that can identify issues in a codebase without running it. Moreover, static analysis can help during a refactoring of a codebase with tools like an IDE or Rector .","title":"Introduction"},{"location":"#valinor-php-object-mapper-with-strong-type-support","text":"Valinor is a PHP library that helps to map any input into a strongly-typed value object structure. The conversion can handle native PHP types as well as other well-known advanced type annotations like array shapes, generics and more.","title":"Valinor \u2022 PHP object mapper with strong type support"},{"location":"#why","text":"There are many benefits of using value objects instead of plain arrays and scalar values in a modern codebase, among which: Data and behaviour encapsulation \u2014 locks an object's behaviour inside its class, preventing it from being scattered across the codebase. Data validation \u2014 guarantees the valid state of an object. Immutability \u2014 ensures the state of an object cannot be changed during runtime. When mapping any source to an object structure, this library will ensure that all input values are properly converted to match the types of the nodes \u2014 class properties or method parameters. Any value that cannot be converted to the correct type will trigger an error and prevent the mapping from completing. These checks guarantee that if the mapping succeeds, the object structure is perfectly valid, hence there is no need for further validation nor type conversion: the objects are ready to be used.","title":"Why?"},{"location":"#static-analysis","text":"A strongly-typed codebase allows the usage of static analysis tools like PHPStan and Psalm that can identify issues in a codebase without running it. Moreover, static analysis can help during a refactoring of a codebase with tools like an IDE or Rector .","title":"Static analysis"},{"location":"changelog/","text":"Changelog All notable changes to this project will be documented in this file. 0.10.0 (2022-06-10) Notable changes Documentation is now available at valinor.cuyz.io . Features Support mapping to dates with no time ( e0a529 ) Bug Fixes Allow declaring promoted parameter type with @var annotation ( d8eb4d ) Allow mapping iterable to shaped array ( 628baf ) 0.9.0 (2022-05-23) Notable changes Cache injection and warmup The cache feature has been revisited, to give more control to the user on how and when to use it. The method MapperBuilder::withCacheDir() has been deprecated in favor of a new method MapperBuilder::withCache() which accepts any PSR-16 compliant implementation. Warning These changes lead up to the default cache not being automatically registered anymore. If you still want to enable the cache (which you should), you will have to explicitly inject it (see below). A default implementation is provided out of the box, which saves cache entries into the file system. When the application runs in a development environment, the cache implementation should be decorated with FileWatchingCache , which will watch the files of the application and invalidate cache entries when a PHP file is modified by a developer \u2014 preventing the library not behaving as expected when the signature of a property or a method changes. The cache can be warmed up, for instance in a pipeline during the build and deployment of the application \u2014 kudos to @boesing for the feature! Note The cache has to be registered first, otherwise the warmup will end up being useless. $cache = new \\CuyZ\\Valinor\\Cache\\FileSystemCache ( 'path/to/cache-directory' ); if ( $isApplicationInDevelopmentEnvironment ) { $cache = new \\CuyZ\\Valinor\\Cache\\FileWatchingCache ( $cache ); } $mapperBuilder = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> withCache ( $cache ); // During the build: $mapperBuilder -> warmup ( SomeClass :: class , SomeOtherClass :: class ); // In the application: $mapperBuilder -> mapper () -> map ( SomeClass :: class , [ /* \u2026 */ ]); Message formatting & translation Major changes have been made to the messages being returned in case of a mapping error: the actual texts are now more accurate and show better information. Warning The method NodeMessage::format has been removed, message formatters should be used instead. If needed, the old behaviour can be retrieved with the formatter PlaceHolderMessageFormatter , although it is strongly advised to use the new placeholders feature (see below). The signature of the method MessageFormatter::format has changed as well. It is now also easier to format the messages, for instance when they need to be translated. Placeholders can now be used in a message body, and will be replaced with useful information. Placeholder Description {message_code} the code of the message {node_name} name of the node to which the message is bound {node_path} path of the node to which the message is bound {node_type} type of the node to which the message is bound {original_value} the source value that was given to the node {original_message} the original message before being customized try { ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( SomeClass :: class , [ /* \u2026 */ ]); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { $node = $error -> node (); $messages = new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\MessagesFlattener ( $node ); foreach ( $messages as $message ) { if ( $message -> code () === 'some_code' ) { $message = $message -> withBody ( 'new message / {original_message}' ); } echo $message ; } } The messages are formatted using the ICU library , enabling the placeholders to use advanced syntax to perform proper translations, for instance currency support. try { ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( 'int<0, 100>' , 1337 ); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { $message = $error -> node () -> messages ()[ 0 ]; if ( is_numeric ( $message -> value ())) { $message = $message -> withBody ( 'Invalid amount {original_value, number, currency}' ); } // Invalid amount: $1,337.00 echo $message -> withLocale ( 'en_US' ); // Invalid amount: \u00a31,337.00 echo $message -> withLocale ( 'en_GB' ); // Invalid amount: 1 337,00 \u20ac echo $message -> withLocale ( 'fr_FR' ); } See ICU documentation for more information on available syntax. Warning If the intl extension is not installed, a shim will be available to replace the placeholders, but it won't handle advanced syntax as described above. The formatter TranslationMessageFormatter can be used to translate the content of messages. The library provides a list of all messages that can be returned; this list can be filled or modified with custom translations. \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\TranslationMessageFormatter :: default () // Create/override a single entry\u2026 -> withTranslation ( 'fr' , 'some custom message' , 'un message personnalis\u00e9' ) // \u2026or several entries. -> withTranslations ([ 'some custom message' => [ 'en' => 'Some custom message' , 'fr' => 'Un message personnalis\u00e9' , 'es' => 'Un mensaje personalizado' , ], 'some other message' => [ // \u2026 ], ]) -> format ( $message ); It is possible to join several formatters into one formatter by using the AggregateMessageFormatter . This instance can then easily be injected in a service that will handle messages. The formatters will be called in the same order they are given to the aggregate. ( new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\AggregateMessageFormatter ( new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\LocaleMessageFormatter ( 'fr' ), new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\MessageMapFormatter ([ // \u2026 ], \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\TranslationMessageFormatter :: default (), )) -> format ( $message ) \u26a0 BREAKING CHANGES Improve message customization with formatters ( 60a665 ) Revoke ObjectBuilder API access ( 11e126 ) Features Allow injecting a cache implementation that is used by the mapper ( 69ad3f ) Extract file watching feature in own cache implementation ( 2d70ef ) Improve mapping error messages ( 05cf4a ) Introduce method to warm the cache up ( ccf09f ) Bug Fixes Make interface type match undefined object type ( 105eef ) Other Change InvalidParameterIndex exception inheritance type ( b75adb ) Introduce layer for object builder arguments ( 48f936 ) 0.8.0 (2022-05-09) Notable changes Float values handling Allows the usage of float values, as follows: class Foo { /** @var 404.42|1337.42 */ public readonly float $value ; } Literal boolean true / false values handling Thanks @danog for this feature! Allows the usage of boolean values, as follows: class Foo { /** @var int|false */ public readonly int | bool $value ; } Class string of union of object handling Allows to declare several class names in a class-string : class Foo { /** @var class-string<SomeClass|SomeOtherClass> */ public readonly string $className ; } Allow psalm and phpstan prefix in docblocks Thanks @boesing for this feature! The following annotations are now properly handled: @psalm-param , @phpstan-param , @psalm-return and @phpstan-return . If one of those is found along with a basic @param or @return annotation, it will take precedence over the basic value. Features Allow psalm and phpstan prefix in docblocks ( 64e0a2 ) Handle class string of union of object ( b7923b ) Handle filename in function definition ( 0b042b ) Handle float value type ( 790df8 ) Handle literal boolean true / false types ( afcedf ) Introduce composite types ( 892f38 ) Bug Fixes Call value altering function only if value is accepted ( 2f08e1 ) Handle function definition cache invalidation when file is modified ( 511a0d ) Other Add configuration for Composer allowed plugins ( 2f310c ) Add Psalm configuration file to .gitattributes ( 979272 ) Bump dev-dependencies ( 844384 ) Declare code type in docblocks ( 03c84a ) Ignore Polyfill coverage ( c08fe5 ) Remove symfony/polyfill-php80 dependency ( 368737 ) 0.7.0 (2022-03-24) Notable changes Warning This release introduces a major breaking change that must be considered before updating Constructor registration The automatic named constructor discovery has been disabled . It is now mandatory to explicitly register custom constructors that can be used by the mapper. This decision was made because of a security issue reported by @Ocramius and described in advisory [GHSA-xhr8-mpwq-2rr2]. As a result, existing code must list all named constructors that were previously automatically used by the mapper, and registerer them using the method MapperBuilder::registerConstructor() . The method MapperBuilder::bind() has been deprecated in favor of the method above that should be used instead. final class SomeClass { public static function namedConstructor ( string $foo ) : self { // \u2026 } } ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> registerConstructor ( SomeClass :: namedConstructor ( ... ), // \u2026or for PHP < 8.1: [ SomeClass :: class , 'namedConstructor' ], ) -> mapper () -> map ( SomeClass :: class , [ // \u2026 ]); See documentation for more information. Source builder The Source class is a new entry point for sources that are not plain array or iterable. It allows accessing other features like camel-case keys or custom paths mapping in a convenient way. It should be used as follows: $source = \\CuyZ\\Valinor\\Mapper\\Source\\Source :: json ( $jsonString ) -> camelCaseKeys () -> map ([ 'towns' => 'cities' , 'towns.*.label' => 'name' , ]); $result = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( SomeClass :: class , $source ); See documentation for more details about its usage. \u26a0 BREAKING CHANGES Change Attributes::ofType return type to array ( 1a599b ) Introduce method to register constructors used during mapping ( ecafba ) Features Introduce a path-mapping source modifier ( b7a7d2 ) Introduce a source builder ( ad5103 ) Bug Fixes Handle numeric key with camel case source key modifier ( b8a18f ) Handle parameter default object value compilation ( fdef93 ) Handle variadic arguments in callable constructors ( b646cc ) Properly handle alias types for function reflection ( e5b515 ) Other Add Striker HTML report when running infection ( 79c7a4 ) Handle class name in function definition ( e2451d ) Introduce functions container to wrap definition handling ( fd1117 ) 0.6.0 (2022-02-24) \u26a0 BREAKING CHANGES Improve interface inferring API ( 1eb6e6 ) Improve object binding API ( 6d4270 ) Features Handle variadic parameters in constructors ( b6b329 ) Improve value altering API ( 422e6a ) Introduce a camel case source key modifier ( d94652 ) Introduce function definition repository ( b49ebf ) Introduce method to get parameter by index ( 380961 ) Bug Fixes Change license in composer.json ( 6fdd62 ) Ensure native mixed types remain valid ( 18ccbe ) Remove string keys when unpacking variadic parameter values ( cbf4e1 ) Transform exception thrown during object binding into a message ( 359e32 ) Write temporary cache file inside cache subdirectory ( 1b80a1 ) Other Check value acceptance in separate node builder ( 30d447 ) Narrow union types during node build ( 06e9de ) 0.5.0 (2022-01-27) Features Introduce automatic named constructor resolution ( 718d3c ) Set up dependabot for automated weekly dependency upgrades ( 23b611 ) Simplify type signature of TreeMapper#map() ( e28003 ) Bug Fixes Correct regex that detects @internal or @api annotations ( 39f0b7 ) Improve type definitions to allow Psalm automatic inferring ( f9b04c ) Return indexed list of attributes when filtering on type ( 66aa4d ) 0.4.0 (2022-01-07) Notable changes Allow mapping to any type Previously, the method TreeMapper::map would allow mapping only to an object. It is now possible to map to any type handled by the library. It is for instance possible to map to an array of objects: $objects = ( new MapperBuilder ()) -> mapper () -> map ( 'array<' . SomeClass :: class . '>' , [ /* \u2026 */ ] ); For simple use-cases, an array shape can be used: $array = ( new MapperBuilder ()) -> mapper () -> map ( 'array{foo: string, bar: int}' , [ /* \u2026 */ ] ); echo $array [ 'foo' ]; echo $array [ 'bar' ] * 2 ; This new feature changes the possible behaviour of the mapper, meaning static analysis tools need help to understand the types correctly. An extension for PHPStan and a plugin for Psalm are now provided and can be included in a project to automatically increase the type coverage. Better handling of messages When working with messages, it can sometimes be useful to customize the content of a message \u2014 for instance to translate it. The helper class \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\MessageMapFormatter can be used to provide a list of new formats. It can be instantiated with an array where each key represents either: The code of the message to be replaced The content of the message to be replaced The class name of the message to be replaced If none of those is found, the content of the message will stay unchanged unless a default one is given to the class. If one of these keys is found, the array entry will be used to replace the content of the message. This entry can be either a plain text or a callable that takes the message as a parameter and returns a string; it is for instance advised to use a callable in cases where a translation service is used \u2014 to avoid useless greedy operations. In any case, the content can contain placeholders that will automatically be replaced by, in order: The original code of the message The original content of the message A string representation of the node type The name of the node The path of the node try { ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( SomeClass :: class , [ /* \u2026 */ ]); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { $node = $error -> node (); $messages = new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\MessagesFlattener ( $node ); $formatter = ( new MessageMapFormatter ([ // Will match if the given message has this exact code 'some_code' => 'new content / previous code was: %1$s' , // Will match if the given message has this exact content 'Some message content' => 'new content / previous message: %2$s' , // Will match if the given message is an instance of `SomeError` SomeError :: class => ' - Original code of the message: %1$s - Original content of the message: %2$s - Node type: %3$s - Node name: %4$s - Node path: %5$s ' , // A callback can be used to get access to the message instance OtherError :: class => function ( NodeMessage $message ) : string { if (( string ) $message -> type () === 'string|int' ) { // \u2026 } return 'Some message content' ; }, // For greedy operation, it is advised to use a lazy-callback 'bar' => fn () => $this -> translator -> translate ( 'foo.bar' ), ])) -> defaultsTo ( 'some default message' ) // \u2026or\u2026 -> defaultsTo ( fn () => $this -> translator -> translate ( 'default_message' )); foreach ( $messages as $message ) { echo $formatter -> format ( $message ); } } Automatic union of objects inferring during mapping When the mapper needs to map a source to a union of objects, it will try to guess which object it will map to, based on the needed arguments of the objects, and the values contained in the source. final class UnionOfObjects { public readonly SomeFooObject | SomeBarObject $object ; } final class SomeFooObject { public readonly string $foo ; } final class SomeBarObject { public readonly string $bar ; } // Will map to an instance of `SomeFooObject` ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( UnionOfObjects :: class , [ 'foo' => 'foo' ]); // Will map to an instance of `SomeBarObject` ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( UnionOfObjects :: class , [ 'bar' => 'bar' ]); \u26a0 BREAKING CHANGES Add access to root node when error occurs during mapping ( 54f608 ) Allow mapping to any type ( b2e810 ) Allow object builder to yield arguments without source ( 8a7414 ) Wrap node messages in proper class ( a805ba ) Features Introduce automatic union of objects inferring during mapping ( 79d7c2 ) Introduce helper class MessageMapFormatter ( ddf69e ) Introduce helper class MessagesFlattener ( a97b40 ) Introduce helper NodeTraverser for recursive operations on nodes ( cc1bc6 ) Bug Fixes Handle nested attributes compilation ( d2795b ) Treat forbidden mixed type as invalid type ( 36bd36 ) Treat union type resolving error as message ( e834cd ) Use locked package versions for quality assurance workflow ( 626f13 ) Other Ignore changelog configuration file in git export ( 85a6a4 ) Raise PHPStan version ( 0144bf ) 0.3.0 (2021-12-18) Features Handle common database datetime formats (#40) ( 179ba3 ) Other Change Composer scripts calls ( 0b507c ) Raise version of friendsofphp/php-cs-fixer ( e5ccbe ) 0.2.0 (2021-12-07) Features Handle integer range type ( 9f99a2 ) Handle local type aliasing in class definition ( 56142d ) Handle type alias import in class definition ( fa3ce5 ) Bug Fixes Do not accept shaped array with excessive key(s) ( 5a578e ) Handle integer value match properly ( 9ee2cc ) Other Delete commented code ( 4f5612 ) Move exceptions to more specific folder ( 185edf ) Rename GenericAssignerLexer to TypeAliasLexer ( 680941 ) Use marcocesarato/php-conventional-changelog for changelog ( 178aa9 ) 0.1.1 (2021-12-01) \u26a0 BREAKING CHANGES Change license from GPL 3 to MIT ( a77b28 ) Features Handle multiline type declaration ( d99c59 ) Bug Fixes Filter type symbols with strict string comparison ( 6cdea3 ) Handle correctly iterable source during mapping ( dd4624 ) Handle shaped array integer key ( 5561d0 ) Resolve single/double quotes when parsing doc-block type ( 1c628b ) Other Change PHPStan stub file extension ( 8fc6af ) Delete unwanted code ( e3e169 ) Syntax highlight stub files (#9) ( 9ea95f ) Use composer runtime API ( 1f754a )","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file.","title":"Changelog"},{"location":"changelog/#0100-2022-06-10","text":"","title":"0.10.0 (2022-06-10)"},{"location":"changelog/#notable-changes","text":"Documentation is now available at valinor.cuyz.io .","title":"Notable changes"},{"location":"changelog/#features","text":"Support mapping to dates with no time ( e0a529 )","title":"Features"},{"location":"changelog/#bug-fixes","text":"Allow declaring promoted parameter type with @var annotation ( d8eb4d ) Allow mapping iterable to shaped array ( 628baf )","title":"Bug Fixes"},{"location":"changelog/#090-2022-05-23","text":"","title":"0.9.0 (2022-05-23)"},{"location":"changelog/#notable-changes_1","text":"Cache injection and warmup The cache feature has been revisited, to give more control to the user on how and when to use it. The method MapperBuilder::withCacheDir() has been deprecated in favor of a new method MapperBuilder::withCache() which accepts any PSR-16 compliant implementation. Warning These changes lead up to the default cache not being automatically registered anymore. If you still want to enable the cache (which you should), you will have to explicitly inject it (see below). A default implementation is provided out of the box, which saves cache entries into the file system. When the application runs in a development environment, the cache implementation should be decorated with FileWatchingCache , which will watch the files of the application and invalidate cache entries when a PHP file is modified by a developer \u2014 preventing the library not behaving as expected when the signature of a property or a method changes. The cache can be warmed up, for instance in a pipeline during the build and deployment of the application \u2014 kudos to @boesing for the feature! Note The cache has to be registered first, otherwise the warmup will end up being useless. $cache = new \\CuyZ\\Valinor\\Cache\\FileSystemCache ( 'path/to/cache-directory' ); if ( $isApplicationInDevelopmentEnvironment ) { $cache = new \\CuyZ\\Valinor\\Cache\\FileWatchingCache ( $cache ); } $mapperBuilder = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> withCache ( $cache ); // During the build: $mapperBuilder -> warmup ( SomeClass :: class , SomeOtherClass :: class ); // In the application: $mapperBuilder -> mapper () -> map ( SomeClass :: class , [ /* \u2026 */ ]); Message formatting & translation Major changes have been made to the messages being returned in case of a mapping error: the actual texts are now more accurate and show better information. Warning The method NodeMessage::format has been removed, message formatters should be used instead. If needed, the old behaviour can be retrieved with the formatter PlaceHolderMessageFormatter , although it is strongly advised to use the new placeholders feature (see below). The signature of the method MessageFormatter::format has changed as well. It is now also easier to format the messages, for instance when they need to be translated. Placeholders can now be used in a message body, and will be replaced with useful information. Placeholder Description {message_code} the code of the message {node_name} name of the node to which the message is bound {node_path} path of the node to which the message is bound {node_type} type of the node to which the message is bound {original_value} the source value that was given to the node {original_message} the original message before being customized try { ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( SomeClass :: class , [ /* \u2026 */ ]); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { $node = $error -> node (); $messages = new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\MessagesFlattener ( $node ); foreach ( $messages as $message ) { if ( $message -> code () === 'some_code' ) { $message = $message -> withBody ( 'new message / {original_message}' ); } echo $message ; } } The messages are formatted using the ICU library , enabling the placeholders to use advanced syntax to perform proper translations, for instance currency support. try { ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( 'int<0, 100>' , 1337 ); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { $message = $error -> node () -> messages ()[ 0 ]; if ( is_numeric ( $message -> value ())) { $message = $message -> withBody ( 'Invalid amount {original_value, number, currency}' ); } // Invalid amount: $1,337.00 echo $message -> withLocale ( 'en_US' ); // Invalid amount: \u00a31,337.00 echo $message -> withLocale ( 'en_GB' ); // Invalid amount: 1 337,00 \u20ac echo $message -> withLocale ( 'fr_FR' ); } See ICU documentation for more information on available syntax. Warning If the intl extension is not installed, a shim will be available to replace the placeholders, but it won't handle advanced syntax as described above. The formatter TranslationMessageFormatter can be used to translate the content of messages. The library provides a list of all messages that can be returned; this list can be filled or modified with custom translations. \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\TranslationMessageFormatter :: default () // Create/override a single entry\u2026 -> withTranslation ( 'fr' , 'some custom message' , 'un message personnalis\u00e9' ) // \u2026or several entries. -> withTranslations ([ 'some custom message' => [ 'en' => 'Some custom message' , 'fr' => 'Un message personnalis\u00e9' , 'es' => 'Un mensaje personalizado' , ], 'some other message' => [ // \u2026 ], ]) -> format ( $message ); It is possible to join several formatters into one formatter by using the AggregateMessageFormatter . This instance can then easily be injected in a service that will handle messages. The formatters will be called in the same order they are given to the aggregate. ( new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\AggregateMessageFormatter ( new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\LocaleMessageFormatter ( 'fr' ), new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\MessageMapFormatter ([ // \u2026 ], \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\TranslationMessageFormatter :: default (), )) -> format ( $message )","title":"Notable changes"},{"location":"changelog/#breaking-changes","text":"Improve message customization with formatters ( 60a665 ) Revoke ObjectBuilder API access ( 11e126 )","title":"\u26a0 BREAKING CHANGES"},{"location":"changelog/#features_1","text":"Allow injecting a cache implementation that is used by the mapper ( 69ad3f ) Extract file watching feature in own cache implementation ( 2d70ef ) Improve mapping error messages ( 05cf4a ) Introduce method to warm the cache up ( ccf09f )","title":"Features"},{"location":"changelog/#bug-fixes_1","text":"Make interface type match undefined object type ( 105eef )","title":"Bug Fixes"},{"location":"changelog/#other","text":"Change InvalidParameterIndex exception inheritance type ( b75adb ) Introduce layer for object builder arguments ( 48f936 )","title":"Other"},{"location":"changelog/#080-2022-05-09","text":"","title":"0.8.0 (2022-05-09)"},{"location":"changelog/#notable-changes_2","text":"Float values handling Allows the usage of float values, as follows: class Foo { /** @var 404.42|1337.42 */ public readonly float $value ; } Literal boolean true / false values handling Thanks @danog for this feature! Allows the usage of boolean values, as follows: class Foo { /** @var int|false */ public readonly int | bool $value ; } Class string of union of object handling Allows to declare several class names in a class-string : class Foo { /** @var class-string<SomeClass|SomeOtherClass> */ public readonly string $className ; } Allow psalm and phpstan prefix in docblocks Thanks @boesing for this feature! The following annotations are now properly handled: @psalm-param , @phpstan-param , @psalm-return and @phpstan-return . If one of those is found along with a basic @param or @return annotation, it will take precedence over the basic value.","title":"Notable changes"},{"location":"changelog/#features_2","text":"Allow psalm and phpstan prefix in docblocks ( 64e0a2 ) Handle class string of union of object ( b7923b ) Handle filename in function definition ( 0b042b ) Handle float value type ( 790df8 ) Handle literal boolean true / false types ( afcedf ) Introduce composite types ( 892f38 )","title":"Features"},{"location":"changelog/#bug-fixes_2","text":"Call value altering function only if value is accepted ( 2f08e1 ) Handle function definition cache invalidation when file is modified ( 511a0d )","title":"Bug Fixes"},{"location":"changelog/#other_1","text":"Add configuration for Composer allowed plugins ( 2f310c ) Add Psalm configuration file to .gitattributes ( 979272 ) Bump dev-dependencies ( 844384 ) Declare code type in docblocks ( 03c84a ) Ignore Polyfill coverage ( c08fe5 ) Remove symfony/polyfill-php80 dependency ( 368737 )","title":"Other"},{"location":"changelog/#070-2022-03-24","text":"","title":"0.7.0 (2022-03-24)"},{"location":"changelog/#notable-changes_3","text":"Warning This release introduces a major breaking change that must be considered before updating Constructor registration The automatic named constructor discovery has been disabled . It is now mandatory to explicitly register custom constructors that can be used by the mapper. This decision was made because of a security issue reported by @Ocramius and described in advisory [GHSA-xhr8-mpwq-2rr2]. As a result, existing code must list all named constructors that were previously automatically used by the mapper, and registerer them using the method MapperBuilder::registerConstructor() . The method MapperBuilder::bind() has been deprecated in favor of the method above that should be used instead. final class SomeClass { public static function namedConstructor ( string $foo ) : self { // \u2026 } } ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> registerConstructor ( SomeClass :: namedConstructor ( ... ), // \u2026or for PHP < 8.1: [ SomeClass :: class , 'namedConstructor' ], ) -> mapper () -> map ( SomeClass :: class , [ // \u2026 ]); See documentation for more information. Source builder The Source class is a new entry point for sources that are not plain array or iterable. It allows accessing other features like camel-case keys or custom paths mapping in a convenient way. It should be used as follows: $source = \\CuyZ\\Valinor\\Mapper\\Source\\Source :: json ( $jsonString ) -> camelCaseKeys () -> map ([ 'towns' => 'cities' , 'towns.*.label' => 'name' , ]); $result = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( SomeClass :: class , $source ); See documentation for more details about its usage.","title":"Notable changes"},{"location":"changelog/#breaking-changes_1","text":"Change Attributes::ofType return type to array ( 1a599b ) Introduce method to register constructors used during mapping ( ecafba )","title":"\u26a0 BREAKING CHANGES"},{"location":"changelog/#features_3","text":"Introduce a path-mapping source modifier ( b7a7d2 ) Introduce a source builder ( ad5103 )","title":"Features"},{"location":"changelog/#bug-fixes_3","text":"Handle numeric key with camel case source key modifier ( b8a18f ) Handle parameter default object value compilation ( fdef93 ) Handle variadic arguments in callable constructors ( b646cc ) Properly handle alias types for function reflection ( e5b515 )","title":"Bug Fixes"},{"location":"changelog/#other_2","text":"Add Striker HTML report when running infection ( 79c7a4 ) Handle class name in function definition ( e2451d ) Introduce functions container to wrap definition handling ( fd1117 )","title":"Other"},{"location":"changelog/#060-2022-02-24","text":"","title":"0.6.0 (2022-02-24)"},{"location":"changelog/#breaking-changes_2","text":"Improve interface inferring API ( 1eb6e6 ) Improve object binding API ( 6d4270 )","title":"\u26a0 BREAKING CHANGES"},{"location":"changelog/#features_4","text":"Handle variadic parameters in constructors ( b6b329 ) Improve value altering API ( 422e6a ) Introduce a camel case source key modifier ( d94652 ) Introduce function definition repository ( b49ebf ) Introduce method to get parameter by index ( 380961 )","title":"Features"},{"location":"changelog/#bug-fixes_4","text":"Change license in composer.json ( 6fdd62 ) Ensure native mixed types remain valid ( 18ccbe ) Remove string keys when unpacking variadic parameter values ( cbf4e1 ) Transform exception thrown during object binding into a message ( 359e32 ) Write temporary cache file inside cache subdirectory ( 1b80a1 )","title":"Bug Fixes"},{"location":"changelog/#other_3","text":"Check value acceptance in separate node builder ( 30d447 ) Narrow union types during node build ( 06e9de )","title":"Other"},{"location":"changelog/#050-2022-01-27","text":"","title":"0.5.0 (2022-01-27)"},{"location":"changelog/#features_5","text":"Introduce automatic named constructor resolution ( 718d3c ) Set up dependabot for automated weekly dependency upgrades ( 23b611 ) Simplify type signature of TreeMapper#map() ( e28003 )","title":"Features"},{"location":"changelog/#bug-fixes_5","text":"Correct regex that detects @internal or @api annotations ( 39f0b7 ) Improve type definitions to allow Psalm automatic inferring ( f9b04c ) Return indexed list of attributes when filtering on type ( 66aa4d )","title":"Bug Fixes"},{"location":"changelog/#040-2022-01-07","text":"","title":"0.4.0 (2022-01-07)"},{"location":"changelog/#notable-changes_4","text":"Allow mapping to any type Previously, the method TreeMapper::map would allow mapping only to an object. It is now possible to map to any type handled by the library. It is for instance possible to map to an array of objects: $objects = ( new MapperBuilder ()) -> mapper () -> map ( 'array<' . SomeClass :: class . '>' , [ /* \u2026 */ ] ); For simple use-cases, an array shape can be used: $array = ( new MapperBuilder ()) -> mapper () -> map ( 'array{foo: string, bar: int}' , [ /* \u2026 */ ] ); echo $array [ 'foo' ]; echo $array [ 'bar' ] * 2 ; This new feature changes the possible behaviour of the mapper, meaning static analysis tools need help to understand the types correctly. An extension for PHPStan and a plugin for Psalm are now provided and can be included in a project to automatically increase the type coverage. Better handling of messages When working with messages, it can sometimes be useful to customize the content of a message \u2014 for instance to translate it. The helper class \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\MessageMapFormatter can be used to provide a list of new formats. It can be instantiated with an array where each key represents either: The code of the message to be replaced The content of the message to be replaced The class name of the message to be replaced If none of those is found, the content of the message will stay unchanged unless a default one is given to the class. If one of these keys is found, the array entry will be used to replace the content of the message. This entry can be either a plain text or a callable that takes the message as a parameter and returns a string; it is for instance advised to use a callable in cases where a translation service is used \u2014 to avoid useless greedy operations. In any case, the content can contain placeholders that will automatically be replaced by, in order: The original code of the message The original content of the message A string representation of the node type The name of the node The path of the node try { ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( SomeClass :: class , [ /* \u2026 */ ]); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { $node = $error -> node (); $messages = new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\MessagesFlattener ( $node ); $formatter = ( new MessageMapFormatter ([ // Will match if the given message has this exact code 'some_code' => 'new content / previous code was: %1$s' , // Will match if the given message has this exact content 'Some message content' => 'new content / previous message: %2$s' , // Will match if the given message is an instance of `SomeError` SomeError :: class => ' - Original code of the message: %1$s - Original content of the message: %2$s - Node type: %3$s - Node name: %4$s - Node path: %5$s ' , // A callback can be used to get access to the message instance OtherError :: class => function ( NodeMessage $message ) : string { if (( string ) $message -> type () === 'string|int' ) { // \u2026 } return 'Some message content' ; }, // For greedy operation, it is advised to use a lazy-callback 'bar' => fn () => $this -> translator -> translate ( 'foo.bar' ), ])) -> defaultsTo ( 'some default message' ) // \u2026or\u2026 -> defaultsTo ( fn () => $this -> translator -> translate ( 'default_message' )); foreach ( $messages as $message ) { echo $formatter -> format ( $message ); } } Automatic union of objects inferring during mapping When the mapper needs to map a source to a union of objects, it will try to guess which object it will map to, based on the needed arguments of the objects, and the values contained in the source. final class UnionOfObjects { public readonly SomeFooObject | SomeBarObject $object ; } final class SomeFooObject { public readonly string $foo ; } final class SomeBarObject { public readonly string $bar ; } // Will map to an instance of `SomeFooObject` ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( UnionOfObjects :: class , [ 'foo' => 'foo' ]); // Will map to an instance of `SomeBarObject` ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( UnionOfObjects :: class , [ 'bar' => 'bar' ]);","title":"Notable changes"},{"location":"changelog/#breaking-changes_3","text":"Add access to root node when error occurs during mapping ( 54f608 ) Allow mapping to any type ( b2e810 ) Allow object builder to yield arguments without source ( 8a7414 ) Wrap node messages in proper class ( a805ba )","title":"\u26a0 BREAKING CHANGES"},{"location":"changelog/#features_6","text":"Introduce automatic union of objects inferring during mapping ( 79d7c2 ) Introduce helper class MessageMapFormatter ( ddf69e ) Introduce helper class MessagesFlattener ( a97b40 ) Introduce helper NodeTraverser for recursive operations on nodes ( cc1bc6 )","title":"Features"},{"location":"changelog/#bug-fixes_6","text":"Handle nested attributes compilation ( d2795b ) Treat forbidden mixed type as invalid type ( 36bd36 ) Treat union type resolving error as message ( e834cd ) Use locked package versions for quality assurance workflow ( 626f13 )","title":"Bug Fixes"},{"location":"changelog/#other_4","text":"Ignore changelog configuration file in git export ( 85a6a4 ) Raise PHPStan version ( 0144bf )","title":"Other"},{"location":"changelog/#030-2021-12-18","text":"","title":"0.3.0 (2021-12-18)"},{"location":"changelog/#features_7","text":"Handle common database datetime formats (#40) ( 179ba3 )","title":"Features"},{"location":"changelog/#other_5","text":"Change Composer scripts calls ( 0b507c ) Raise version of friendsofphp/php-cs-fixer ( e5ccbe )","title":"Other"},{"location":"changelog/#020-2021-12-07","text":"","title":"0.2.0 (2021-12-07)"},{"location":"changelog/#features_8","text":"Handle integer range type ( 9f99a2 ) Handle local type aliasing in class definition ( 56142d ) Handle type alias import in class definition ( fa3ce5 )","title":"Features"},{"location":"changelog/#bug-fixes_7","text":"Do not accept shaped array with excessive key(s) ( 5a578e ) Handle integer value match properly ( 9ee2cc )","title":"Bug Fixes"},{"location":"changelog/#other_6","text":"Delete commented code ( 4f5612 ) Move exceptions to more specific folder ( 185edf ) Rename GenericAssignerLexer to TypeAliasLexer ( 680941 ) Use marcocesarato/php-conventional-changelog for changelog ( 178aa9 )","title":"Other"},{"location":"changelog/#011-2021-12-01","text":"","title":"0.1.1 (2021-12-01)"},{"location":"changelog/#breaking-changes_4","text":"Change license from GPL 3 to MIT ( a77b28 )","title":"\u26a0 BREAKING CHANGES"},{"location":"changelog/#features_9","text":"Handle multiline type declaration ( d99c59 )","title":"Features"},{"location":"changelog/#bug-fixes_8","text":"Filter type symbols with strict string comparison ( 6cdea3 ) Handle correctly iterable source during mapping ( dd4624 ) Handle shaped array integer key ( 5561d0 ) Resolve single/double quotes when parsing doc-block type ( 1c628b )","title":"Bug Fixes"},{"location":"changelog/#other_7","text":"Change PHPStan stub file extension ( 8fc6af ) Delete unwanted code ( e3e169 ) Syntax highlight stub files (#9) ( 9ea95f ) Use composer runtime API ( 1f754a )","title":"Other"},{"location":"credits/","text":"Credits & thank you The development of this library is mainly motivated by the kind words and the help of many people. I am grateful to everyone, especially to the contributors of this repository who directly help to push the project forward. I also want to thank Blackfire for providing a license of their awesome tool, leading to notable performance gains when using this library.","title":"Credits"},{"location":"credits/#credits-thank-you","text":"The development of this library is mainly motivated by the kind words and the help of many people. I am grateful to everyone, especially to the contributors of this repository who directly help to push the project forward. I also want to thank Blackfire for providing a license of their awesome tool, leading to notable performance gains when using this library.","title":"Credits &amp; thank you"},{"location":"getting-started/","text":"Getting started Installation composer require cuyz/valinor Example An application must handle the data coming from an external API; the response has a JSON format and describes a thread and its answers. The validity of this input is unsure, besides manipulating a raw JSON string is laborious and inefficient. { \"id\" : 1337 , \"content\" : \"Do you like potatoes?\" , \"date\" : \"1957-07-23 13:37:42\" , \"answers\" : [ { \"user\" : \"Ella F.\" , \"message\" : \"I like potatoes\" , \"date\" : \"1957-07-31 15:28:12\" }, { \"user\" : \"Louis A.\" , \"message\" : \"And I like tomatoes\" , \"date\" : \"1957-08-13 09:05:24\" } ] } The application must be certain that it can handle this data correctly; wrapping the input in a value object will help. A schema representing the needed structure must be provided, using classes. final class Thread { public function __construct ( public readonly int $id , public readonly string $content , public readonly DateTimeInterface $date , /** @var Answer[] */ public readonly array $answers , ) {} } final class Answer { public function __construct ( public readonly string $user , public readonly string $message , public readonly DateTimeInterface $date , ) {} } Then a mapper is used to hydrate a source into these objects. public function getThread ( int $id ) : Thread { $rawJson = $this -> client -> request ( \"https://example.com/thread/ $id \" ); try { return ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( Thread :: class , new \\CuyZ\\Valinor\\Mapper\\Source\\JsonSource ( $rawJson ) ); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { // Do something\u2026 } } Mapping advanced types Although it is recommended to map an input to a value object, in some cases mapping to another type can be easier/more flexible. It is for instance possible to map to an array of objects: try { $objects = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( 'array<' . SomeClass :: class . '>' , [ /* \u2026 */ ] ); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { // Do something\u2026 } For simple use-cases, an array shape can be used: try { $array = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( 'array{foo: string, bar: int}' , [ /* \u2026 */ ] ); echo $array [ 'foo' ]; echo $array [ 'bar' ] * 2 ; } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { // Do something\u2026 }","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting started"},{"location":"getting-started/#installation","text":"composer require cuyz/valinor","title":"Installation"},{"location":"getting-started/#example","text":"An application must handle the data coming from an external API; the response has a JSON format and describes a thread and its answers. The validity of this input is unsure, besides manipulating a raw JSON string is laborious and inefficient. { \"id\" : 1337 , \"content\" : \"Do you like potatoes?\" , \"date\" : \"1957-07-23 13:37:42\" , \"answers\" : [ { \"user\" : \"Ella F.\" , \"message\" : \"I like potatoes\" , \"date\" : \"1957-07-31 15:28:12\" }, { \"user\" : \"Louis A.\" , \"message\" : \"And I like tomatoes\" , \"date\" : \"1957-08-13 09:05:24\" } ] } The application must be certain that it can handle this data correctly; wrapping the input in a value object will help. A schema representing the needed structure must be provided, using classes. final class Thread { public function __construct ( public readonly int $id , public readonly string $content , public readonly DateTimeInterface $date , /** @var Answer[] */ public readonly array $answers , ) {} } final class Answer { public function __construct ( public readonly string $user , public readonly string $message , public readonly DateTimeInterface $date , ) {} } Then a mapper is used to hydrate a source into these objects. public function getThread ( int $id ) : Thread { $rawJson = $this -> client -> request ( \"https://example.com/thread/ $id \" ); try { return ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( Thread :: class , new \\CuyZ\\Valinor\\Mapper\\Source\\JsonSource ( $rawJson ) ); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { // Do something\u2026 } }","title":"Example"},{"location":"getting-started/#mapping-advanced-types","text":"Although it is recommended to map an input to a value object, in some cases mapping to another type can be easier/more flexible. It is for instance possible to map to an array of objects: try { $objects = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( 'array<' . SomeClass :: class . '>' , [ /* \u2026 */ ] ); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { // Do something\u2026 } For simple use-cases, an array shape can be used: try { $array = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( 'array{foo: string, bar: int}' , [ /* \u2026 */ ] ); echo $array [ 'foo' ]; echo $array [ 'bar' ] * 2 ; } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { // Do something\u2026 }","title":"Mapping advanced types"},{"location":"message-customization/","text":"Message customization The content of a message can be changed to fit custom use cases; it can contain placeholders that will be replaced with useful information. The placeholders below are always available; even more may be used depending on the original message. Placeholder Description {message_code} the code of the message {node_name} name of the node to which the message is bound {node_path} path of the node to which the message is bound {node_type} type of the node to which the message is bound {original_value} the source value that was given to the node {original_message} the original message before being customized Usage: try { ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( SomeClass :: class , [ /* \u2026 */ ]); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { $node = $error -> node (); $messages = new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\MessagesFlattener ( $node ); foreach ( $messages as $message ) { if ( $message -> code () === 'some_code' ) { $message = $message -> withBody ( 'new message / {original_message}' ); } echo $message ; } } The messages are formatted using the ICU library , enabling the placeholders to use advanced syntax to perform proper translations, for instance currency support. try { ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( 'int<0, 100>' , 1337 ); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { $message = $error -> node () -> messages ()[ 0 ]; if ( is_numeric ( $message -> value ())) { $message = $message -> withBody ( 'Invalid amount {original_value, number, currency}' ); } // Invalid amount: $1,337.00 echo $message -> withLocale ( 'en_US' ); // Invalid amount: \u00a31,337.00 echo $message -> withLocale ( 'en_GB' ); // Invalid amount: 1 337,00 \u20ac echo $message -> withLocale ( 'fr_FR' ); } See ICU documentation for more information on available syntax. Warning If the intl extension is not installed, a shim will be available to replace the placeholders, but it won't handle advanced syntax as described above. Deeper message customization / translation For deeper message changes, formatters can be used \u2014 for instance to translate content. Translation The formatter TranslationMessageFormatter can be used to translate the content of messages. The library provides a list of all messages that can be returned; this list can be filled or modified with custom translations. \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\TranslationMessageFormatter :: default () // Create/override a single entry\u2026 -> withTranslation ( 'fr' , 'some custom message' , 'un message personnalis\u00e9' ) // \u2026or several entries. -> withTranslations ([ 'some custom message' => [ 'en' => 'Some custom message' , 'fr' => 'Un message personnalis\u00e9' , 'es' => 'Un mensaje personalizado' , ], 'some other message' => [ // \u2026 ], ]) -> format ( $message ); Replacement map The formatter MessageMapFormatter can be used to provide a list of messages replacements. It can be instantiated with an array where each key represents either: The code of the message to be replaced The body of the message to be replaced The class name of the message to be replaced If none of those is found, the content of the message will stay unchanged unless a default one is given to the class. If one of these keys is found, the array entry will be used to replace the content of the message. This entry can be either a plain text or a callable that takes the message as a parameter and returns a string; it is for instance advised to use a callable in cases where a custom translation service is used \u2014 to avoid useless greedy operations. In any case, the content can contain placeholders as described above . ( new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\MessageMapFormatter ([ // Will match if the given message has this exact code 'some_code' => 'New content / code: {message_code}' , // Will match if the given message has this exact content 'Some message content' => 'New content / previous: {original_message}' , // Will match if the given message is an instance of `SomeError` SomeError :: class => 'New content / value: {original_value}' , // A callback can be used to get access to the message instance OtherError :: class => function ( NodeMessage $message ) : string { if ( $message -> path () === 'foo.bar' ) { return 'Some custom message' ; } return $message -> body (); }, // For greedy operation, it is advised to use a lazy-callback 'foo' => fn () => $this -> customTranslator -> translate ( 'foo.bar' ), ])) -> defaultsTo ( 'some default message' ) // \u2026or\u2026 -> defaultsTo ( fn () => $this -> customTranslator -> translate ( 'default_message' )) -> format ( $message ); Several formatters It is possible to join several formatters into one formatter by using the AggregateMessageFormatter . This instance can then easily be injected in a service that will handle messages. The formatters will be called in the same order they are given to the aggregate. ( new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\AggregateMessageFormatter ( new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\LocaleMessageFormatter ( 'fr' ), new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\MessageMapFormatter ([ // \u2026 ], \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\TranslationMessageFormatter :: default (), )) -> format ( $message )","title":"Message customization"},{"location":"message-customization/#message-customization","text":"The content of a message can be changed to fit custom use cases; it can contain placeholders that will be replaced with useful information. The placeholders below are always available; even more may be used depending on the original message. Placeholder Description {message_code} the code of the message {node_name} name of the node to which the message is bound {node_path} path of the node to which the message is bound {node_type} type of the node to which the message is bound {original_value} the source value that was given to the node {original_message} the original message before being customized Usage: try { ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( SomeClass :: class , [ /* \u2026 */ ]); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { $node = $error -> node (); $messages = new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\MessagesFlattener ( $node ); foreach ( $messages as $message ) { if ( $message -> code () === 'some_code' ) { $message = $message -> withBody ( 'new message / {original_message}' ); } echo $message ; } } The messages are formatted using the ICU library , enabling the placeholders to use advanced syntax to perform proper translations, for instance currency support. try { ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( 'int<0, 100>' , 1337 ); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { $message = $error -> node () -> messages ()[ 0 ]; if ( is_numeric ( $message -> value ())) { $message = $message -> withBody ( 'Invalid amount {original_value, number, currency}' ); } // Invalid amount: $1,337.00 echo $message -> withLocale ( 'en_US' ); // Invalid amount: \u00a31,337.00 echo $message -> withLocale ( 'en_GB' ); // Invalid amount: 1 337,00 \u20ac echo $message -> withLocale ( 'fr_FR' ); } See ICU documentation for more information on available syntax. Warning If the intl extension is not installed, a shim will be available to replace the placeholders, but it won't handle advanced syntax as described above.","title":"Message customization"},{"location":"message-customization/#deeper-message-customization-translation","text":"For deeper message changes, formatters can be used \u2014 for instance to translate content.","title":"Deeper message customization / translation"},{"location":"message-customization/#translation","text":"The formatter TranslationMessageFormatter can be used to translate the content of messages. The library provides a list of all messages that can be returned; this list can be filled or modified with custom translations. \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\TranslationMessageFormatter :: default () // Create/override a single entry\u2026 -> withTranslation ( 'fr' , 'some custom message' , 'un message personnalis\u00e9' ) // \u2026or several entries. -> withTranslations ([ 'some custom message' => [ 'en' => 'Some custom message' , 'fr' => 'Un message personnalis\u00e9' , 'es' => 'Un mensaje personalizado' , ], 'some other message' => [ // \u2026 ], ]) -> format ( $message );","title":"Translation"},{"location":"message-customization/#replacement-map","text":"The formatter MessageMapFormatter can be used to provide a list of messages replacements. It can be instantiated with an array where each key represents either: The code of the message to be replaced The body of the message to be replaced The class name of the message to be replaced If none of those is found, the content of the message will stay unchanged unless a default one is given to the class. If one of these keys is found, the array entry will be used to replace the content of the message. This entry can be either a plain text or a callable that takes the message as a parameter and returns a string; it is for instance advised to use a callable in cases where a custom translation service is used \u2014 to avoid useless greedy operations. In any case, the content can contain placeholders as described above . ( new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\MessageMapFormatter ([ // Will match if the given message has this exact code 'some_code' => 'New content / code: {message_code}' , // Will match if the given message has this exact content 'Some message content' => 'New content / previous: {original_message}' , // Will match if the given message is an instance of `SomeError` SomeError :: class => 'New content / value: {original_value}' , // A callback can be used to get access to the message instance OtherError :: class => function ( NodeMessage $message ) : string { if ( $message -> path () === 'foo.bar' ) { return 'Some custom message' ; } return $message -> body (); }, // For greedy operation, it is advised to use a lazy-callback 'foo' => fn () => $this -> customTranslator -> translate ( 'foo.bar' ), ])) -> defaultsTo ( 'some default message' ) // \u2026or\u2026 -> defaultsTo ( fn () => $this -> customTranslator -> translate ( 'default_message' )) -> format ( $message );","title":"Replacement map"},{"location":"message-customization/#several-formatters","text":"It is possible to join several formatters into one formatter by using the AggregateMessageFormatter . This instance can then easily be injected in a service that will handle messages. The formatters will be called in the same order they are given to the aggregate. ( new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\AggregateMessageFormatter ( new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\LocaleMessageFormatter ( 'fr' ), new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\MessageMapFormatter ([ // \u2026 ], \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\TranslationMessageFormatter :: default (), )) -> format ( $message )","title":"Several formatters"},{"location":"source/","text":"Source Any source can be given to the mapper, be it an array, some json, yaml or even a file: $mapper = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper (); $mapper -> map ( SomeClass :: class , \\CuyZ\\Valinor\\Mapper\\Source\\Source :: array ( $someData ) ); $mapper -> map ( SomeClass :: class , \\CuyZ\\Valinor\\Mapper\\Source\\Source :: json ( $jsonString ) ); $mapper -> map ( SomeClass :: class , \\CuyZ\\Valinor\\Mapper\\Source\\Source :: yaml ( $yamlString ) ); $mapper -> map ( SomeClass :: class , // File containing valid Json or Yaml content and with valid extension \\CuyZ\\Valinor\\Mapper\\Source\\Source :: file ( new SplFileObject ( 'path/to/my/file.json' ) ) ); Modifiers Sometimes the source is not in the same format and/or organised in the same way as a value object. Modifiers can be used to change a source before the mapping occurs. Camel case keys This modifier recursively forces all keys to be in camelCase format. final class SomeClass { public readonly string $someValue ; } $source = \\CuyZ\\Valinor\\Mapper\\Source\\Source :: array ([ 'some_value' => 'foo' , // \u2026or\u2026 'some-value' => 'foo' , // \u2026or\u2026 'some value' => 'foo' , // \u2026will be replaced by `['someValue' => 'foo']` ]) -> camelCaseKeys (); ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( SomeClass :: class , $source ); Path mapping This modifier can be used to change paths in the source data using a dot notation. The mapping is done using an associative array of path mappings. This array must have the source path as key and the target path as value. The source path uses the dot notation (eg A.B.C ) and can contain one * for array paths (eg A.B.*.C ). final class Country { /** @var City[] */ public readonly array $cities ; } final class City { public readonly string $name ; } $source = \\CuyZ\\Valinor\\Mapper\\Source\\Source :: array ([ 'towns' => [ [ 'label' => 'Ankh Morpork' ], [ 'label' => 'Minas Tirith' ], ], ]) -> map ([ 'towns' => 'cities' , 'towns.*.label' => 'name' , ]); // After modification this is what the source will look like: [ 'cities' => [ [ 'name' => 'Ankh Morpork' ], [ 'name' => 'Minas Tirith' ], ], ]; ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( Country :: class , $source ); Custom source The source is just an iterable, so it's easy to create a custom one. It can even be combined with the provided builder. final class AcmeSource implements IteratorAggregate { private iterable $source ; public function __construct ( iterable $source ) { $this -> source = $this -> doSomething ( $source ); } private function doSomething ( iterable $source ) : iterable { // Do something with $source return $source ; } public function getIterator () { yield from $this -> source ; } } $source = \\CuyZ\\Valinor\\Mapper\\Source\\Source :: iterable ( new AcmeSource ([ 'value' => 'foo' ]) ) -> camelCaseKeys (); ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( SomeClass :: class , $source );","title":"Source"},{"location":"source/#source","text":"Any source can be given to the mapper, be it an array, some json, yaml or even a file: $mapper = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper (); $mapper -> map ( SomeClass :: class , \\CuyZ\\Valinor\\Mapper\\Source\\Source :: array ( $someData ) ); $mapper -> map ( SomeClass :: class , \\CuyZ\\Valinor\\Mapper\\Source\\Source :: json ( $jsonString ) ); $mapper -> map ( SomeClass :: class , \\CuyZ\\Valinor\\Mapper\\Source\\Source :: yaml ( $yamlString ) ); $mapper -> map ( SomeClass :: class , // File containing valid Json or Yaml content and with valid extension \\CuyZ\\Valinor\\Mapper\\Source\\Source :: file ( new SplFileObject ( 'path/to/my/file.json' ) ) );","title":"Source"},{"location":"source/#modifiers","text":"Sometimes the source is not in the same format and/or organised in the same way as a value object. Modifiers can be used to change a source before the mapping occurs.","title":"Modifiers"},{"location":"source/#camel-case-keys","text":"This modifier recursively forces all keys to be in camelCase format. final class SomeClass { public readonly string $someValue ; } $source = \\CuyZ\\Valinor\\Mapper\\Source\\Source :: array ([ 'some_value' => 'foo' , // \u2026or\u2026 'some-value' => 'foo' , // \u2026or\u2026 'some value' => 'foo' , // \u2026will be replaced by `['someValue' => 'foo']` ]) -> camelCaseKeys (); ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( SomeClass :: class , $source );","title":"Camel case keys"},{"location":"source/#path-mapping","text":"This modifier can be used to change paths in the source data using a dot notation. The mapping is done using an associative array of path mappings. This array must have the source path as key and the target path as value. The source path uses the dot notation (eg A.B.C ) and can contain one * for array paths (eg A.B.*.C ). final class Country { /** @var City[] */ public readonly array $cities ; } final class City { public readonly string $name ; } $source = \\CuyZ\\Valinor\\Mapper\\Source\\Source :: array ([ 'towns' => [ [ 'label' => 'Ankh Morpork' ], [ 'label' => 'Minas Tirith' ], ], ]) -> map ([ 'towns' => 'cities' , 'towns.*.label' => 'name' , ]); // After modification this is what the source will look like: [ 'cities' => [ [ 'name' => 'Ankh Morpork' ], [ 'name' => 'Minas Tirith' ], ], ]; ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( Country :: class , $source );","title":"Path mapping"},{"location":"source/#custom-source","text":"The source is just an iterable, so it's easy to create a custom one. It can even be combined with the provided builder. final class AcmeSource implements IteratorAggregate { private iterable $source ; public function __construct ( iterable $source ) { $this -> source = $this -> doSomething ( $source ); } private function doSomething ( iterable $source ) : iterable { // Do something with $source return $source ; } public function getIterator () { yield from $this -> source ; } } $source = \\CuyZ\\Valinor\\Mapper\\Source\\Source :: iterable ( new AcmeSource ([ 'value' => 'foo' ]) ) -> camelCaseKeys (); ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( SomeClass :: class , $source );","title":"Custom source"},{"location":"validation/","text":"Validation The source given to a mapper can never be trusted, this is actually the very goal of this library: transforming an unstructured input to a well-defined object structure. If the mapper cannot guess how to cast a certain value, it means that it is not able to guarantee the validity of the desired object thus it will fail. Any issue encountered during the mapping will add an error to an upstream exception of type \\CuyZ\\Valinor\\Mapper\\MappingError . It is therefore always recommended wrapping the mapping function call with a try/catch statement and handle the error properly. More specific validation should be done in the constructor of the value object, by throwing an exception if something is wrong with the given data. A good practice would be to use lightweight validation tools like Webmozart Assert . When the mapping fails, the exception gives access to the root node. This recursive object allows retrieving all needed information through the whole mapping tree: path, values, types and messages, including the issues that caused the exception. final class SomeClass { public function __construct ( private string $someValue ) { Assert :: startsWith ( $someValue , 'foo_' ); } } try { ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( SomeClass :: class , [ 'someValue' => 'bar_baz' ] ); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { // Get flatten list of all messages through the whole nodes tree $node = $error -> node (); $messages = new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\MessagesFlattener ( $node ); // If only errors are wanted, they can be filtered $errorMessages = $messages -> errors (); // Should print something similar to: // > Expected a value to start with \"foo_\". Got: \"bar_baz\" foreach ( $errorMessages as $message ) { echo $message ; } }","title":"Validation"},{"location":"validation/#validation","text":"The source given to a mapper can never be trusted, this is actually the very goal of this library: transforming an unstructured input to a well-defined object structure. If the mapper cannot guess how to cast a certain value, it means that it is not able to guarantee the validity of the desired object thus it will fail. Any issue encountered during the mapping will add an error to an upstream exception of type \\CuyZ\\Valinor\\Mapper\\MappingError . It is therefore always recommended wrapping the mapping function call with a try/catch statement and handle the error properly. More specific validation should be done in the constructor of the value object, by throwing an exception if something is wrong with the given data. A good practice would be to use lightweight validation tools like Webmozart Assert . When the mapping fails, the exception gives access to the root node. This recursive object allows retrieving all needed information through the whole mapping tree: path, values, types and messages, including the issues that caused the exception. final class SomeClass { public function __construct ( private string $someValue ) { Assert :: startsWith ( $someValue , 'foo_' ); } } try { ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( SomeClass :: class , [ 'someValue' => 'bar_baz' ] ); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { // Get flatten list of all messages through the whole nodes tree $node = $error -> node (); $messages = new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\MessagesFlattener ( $node ); // If only errors are wanted, they can be filtered $errorMessages = $messages -> errors (); // Should print something similar to: // > Expected a value to start with \"foo_\". Got: \"bar_baz\" foreach ( $errorMessages as $message ) { echo $message ; } }","title":"Validation"},{"location":"mapping/construction-strategy/","text":"Construction strategy During the mapping, instances of objects are recursively created and hydrated with transformed values. Construction strategies will determine what values are needed and how an object is built. Native constructor If a constructor exists and is public, its arguments will determine which values are needed from the input. final class SomeClass { public function __construct ( public readonly string $foo , public readonly int $bar , ) {} } Custom constructor An object may have custom ways of being created, in such cases these constructors need to be registered to the mapper to be used. A constructor is a callable that can be either: A named constructor, also known as a static factory method The method of a service \u2014 for instance a repository A \"callable object\" \u2014 a class that declares an __invoke method Any other callable \u2014 including anonymous functions In any case, the return type of the callable will be resolved by the mapper to know when to use it. Any argument can be provided and will automatically be mapped using the given source. These arguments can then be used to instantiate the object in the desired way. Registering any constructor will disable the native constructor \u2014 the __construct method \u2014 of the targeted class. If for some reason it still needs to be handled as well, the name of the class must be given to the registration method. ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> registerConstructor ( // Allow the native constructor to be used Color :: class , // Register a named constructor (1) Color :: fromHex ( ... ), /** * An anonymous function can also be used, for instance when the desired * object is an external dependency that cannot be modified. * * @param 'red'|'green'|'blue' $color * @param 'dark'|'light' $darkness */ function ( string $color , string $darkness ) : Color { $main = $darkness === 'dark' ? 128 : 255 ; $other = $darkness === 'dark' ? 0 : 128 ; return new Color ( $color === 'red' ? $main : $other , $color === 'green' ? $main : $other , $color === 'blue' ? $main : $other , ); } ) -> mapper () -> map ( Color :: class , [ /* \u2026 */ ]); final class Color { /** * @param int<0, 255> $red * @param int<0, 255> $green * @param int<0, 255> $blue */ public function __construct ( public readonly int $red , public readonly int $green , public readonly int $blue ) {} /** * @param non-empty-string $hex */ public static function fromHex ( string $hex ) : self { if ( strlen ( $hex ) !== 6 ) { throw new DomainException ( 'Must be 6 characters long' ); } /** @var int<0, 255> $red */ $red = hexdec ( substr ( $hex , 0 , 2 )); /** @var int<0, 255> $green */ $green = hexdec ( substr ( $hex , 2 , 2 )); /** @var int<0, 255> $blue */ $blue = hexdec ( substr ( $hex , 4 , 2 )); return new self ( $red , $green , $blue ); } } \u2026or for PHP < 8.1: [ Color :: class , 'fromHex' ], Properties If no constructor is registered, properties will determine which values are needed from the input. final class SomeClass { public readonly string $foo ; public readonly int $bar ; }","title":"Construction strategy"},{"location":"mapping/construction-strategy/#construction-strategy","text":"During the mapping, instances of objects are recursively created and hydrated with transformed values. Construction strategies will determine what values are needed and how an object is built.","title":"Construction strategy"},{"location":"mapping/construction-strategy/#native-constructor","text":"If a constructor exists and is public, its arguments will determine which values are needed from the input. final class SomeClass { public function __construct ( public readonly string $foo , public readonly int $bar , ) {} }","title":"Native constructor"},{"location":"mapping/construction-strategy/#custom-constructor","text":"An object may have custom ways of being created, in such cases these constructors need to be registered to the mapper to be used. A constructor is a callable that can be either: A named constructor, also known as a static factory method The method of a service \u2014 for instance a repository A \"callable object\" \u2014 a class that declares an __invoke method Any other callable \u2014 including anonymous functions In any case, the return type of the callable will be resolved by the mapper to know when to use it. Any argument can be provided and will automatically be mapped using the given source. These arguments can then be used to instantiate the object in the desired way. Registering any constructor will disable the native constructor \u2014 the __construct method \u2014 of the targeted class. If for some reason it still needs to be handled as well, the name of the class must be given to the registration method. ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> registerConstructor ( // Allow the native constructor to be used Color :: class , // Register a named constructor (1) Color :: fromHex ( ... ), /** * An anonymous function can also be used, for instance when the desired * object is an external dependency that cannot be modified. * * @param 'red'|'green'|'blue' $color * @param 'dark'|'light' $darkness */ function ( string $color , string $darkness ) : Color { $main = $darkness === 'dark' ? 128 : 255 ; $other = $darkness === 'dark' ? 0 : 128 ; return new Color ( $color === 'red' ? $main : $other , $color === 'green' ? $main : $other , $color === 'blue' ? $main : $other , ); } ) -> mapper () -> map ( Color :: class , [ /* \u2026 */ ]); final class Color { /** * @param int<0, 255> $red * @param int<0, 255> $green * @param int<0, 255> $blue */ public function __construct ( public readonly int $red , public readonly int $green , public readonly int $blue ) {} /** * @param non-empty-string $hex */ public static function fromHex ( string $hex ) : self { if ( strlen ( $hex ) !== 6 ) { throw new DomainException ( 'Must be 6 characters long' ); } /** @var int<0, 255> $red */ $red = hexdec ( substr ( $hex , 0 , 2 )); /** @var int<0, 255> $green */ $green = hexdec ( substr ( $hex , 2 , 2 )); /** @var int<0, 255> $blue */ $blue = hexdec ( substr ( $hex , 4 , 2 )); return new self ( $red , $green , $blue ); } } \u2026or for PHP < 8.1: [ Color :: class , 'fromHex' ],","title":"Custom constructor"},{"location":"mapping/construction-strategy/#properties","text":"If no constructor is registered, properties will determine which values are needed from the input. final class SomeClass { public readonly string $foo ; public readonly int $bar ; }","title":"Properties"},{"location":"mapping/handled-types/","text":"Handled types To prevent conflicts or duplication of the type annotations, this library tries to handle most of the type annotations that are accepted by PHPStan and Psalm . Scalar final class SomeClass { public function __construct ( private bool $boolean , private float $float , private int $integer , /** @var positive-int */ private int $positiveInteger , /** @var negative-int */ private int $negativeInteger , /** @var int<-42, 1337> */ private int $integerRange , /** @var int<min, 0> */ private int $integerRangeWithMinRange , /** @var int<0, max> */ private int $integerRangeWithMaxRange , private string $string , /** @var non-empty-string */ private string $nonEmptyString , /** @var class-string */ private string $classString , /** @var class-string<SomeInterface> */ private string $classStringOfAnInterface , ) {} } Object final class SomeClass { public function __construct ( private SomeClass $class , private DateTimeInterface $interface , /** @var SomeInterface&AnotherInterface */ private object $intersection , /** @var SomeCollection<SomeClass> */ private SomeCollection $classWithGeneric , ) {} } /** * @template T of object */ final class SomeCollection { public function __construct ( /** @var array<T> */ private array $objects , ) {} } Array & lists final class SomeClass { public function __construct ( /** @var string[] */ private array $simpleArray , /** @var array<string> */ private array $arrayOfStrings , /** @var array<string, SomeClass> */ private array $arrayOfClassWithStringKeys , /** @var array<int, SomeClass> */ private array $arrayOfClassWithIntegerKeys , /** @var non-empty-array<string> */ private array $nonEmptyArrayOfStrings , /** @var non-empty-array<string, SomeClass> */ private array $nonEmptyArrayWithStringKeys , /** @var list<string> */ private array $listOfStrings , /** @var non-empty-list<string> */ private array $nonEmptyListOfStrings , /** @var array{foo: string, bar: int} */ private array $shapedArray , /** @var array{foo: string, bar?: int} */ private array $shapedArrayWithOptionalElement , /** @var array{string, bar: int} */ private array $shapedArrayWithUndefinedKey , ) {} } Union final class SomeClass { public function __construct ( private int | string $simpleUnion , /** @var class-string<SomeInterface|AnotherInterface> */ private string $unionOfClassString , /** @var array<SomeInterface|AnotherInterface> */ private array $unionInsideArray , /** @var int|true */ private int | bool $unionWithLiteralTrueType ; /** @var int|false */ private int | bool $unionWithLiteralFalseType ; /** @var 404.42|1337.42 */ private float $unionOfFloatValues , /** @var 42|1337 */ private int $unionOfIntegerValues , /** @var 'foo'|'bar' */ private string $unionOfStringValues , ) {} }","title":"Handled types"},{"location":"mapping/handled-types/#handled-types","text":"To prevent conflicts or duplication of the type annotations, this library tries to handle most of the type annotations that are accepted by PHPStan and Psalm .","title":"Handled types"},{"location":"mapping/handled-types/#scalar","text":"final class SomeClass { public function __construct ( private bool $boolean , private float $float , private int $integer , /** @var positive-int */ private int $positiveInteger , /** @var negative-int */ private int $negativeInteger , /** @var int<-42, 1337> */ private int $integerRange , /** @var int<min, 0> */ private int $integerRangeWithMinRange , /** @var int<0, max> */ private int $integerRangeWithMaxRange , private string $string , /** @var non-empty-string */ private string $nonEmptyString , /** @var class-string */ private string $classString , /** @var class-string<SomeInterface> */ private string $classStringOfAnInterface , ) {} }","title":"Scalar"},{"location":"mapping/handled-types/#object","text":"final class SomeClass { public function __construct ( private SomeClass $class , private DateTimeInterface $interface , /** @var SomeInterface&AnotherInterface */ private object $intersection , /** @var SomeCollection<SomeClass> */ private SomeCollection $classWithGeneric , ) {} } /** * @template T of object */ final class SomeCollection { public function __construct ( /** @var array<T> */ private array $objects , ) {} }","title":"Object"},{"location":"mapping/handled-types/#array-lists","text":"final class SomeClass { public function __construct ( /** @var string[] */ private array $simpleArray , /** @var array<string> */ private array $arrayOfStrings , /** @var array<string, SomeClass> */ private array $arrayOfClassWithStringKeys , /** @var array<int, SomeClass> */ private array $arrayOfClassWithIntegerKeys , /** @var non-empty-array<string> */ private array $nonEmptyArrayOfStrings , /** @var non-empty-array<string, SomeClass> */ private array $nonEmptyArrayWithStringKeys , /** @var list<string> */ private array $listOfStrings , /** @var non-empty-list<string> */ private array $nonEmptyListOfStrings , /** @var array{foo: string, bar: int} */ private array $shapedArray , /** @var array{foo: string, bar?: int} */ private array $shapedArrayWithOptionalElement , /** @var array{string, bar: int} */ private array $shapedArrayWithUndefinedKey , ) {} }","title":"Array &amp; lists"},{"location":"mapping/handled-types/#union","text":"final class SomeClass { public function __construct ( private int | string $simpleUnion , /** @var class-string<SomeInterface|AnotherInterface> */ private string $unionOfClassString , /** @var array<SomeInterface|AnotherInterface> */ private array $unionInsideArray , /** @var int|true */ private int | bool $unionWithLiteralTrueType ; /** @var int|false */ private int | bool $unionWithLiteralFalseType ; /** @var 404.42|1337.42 */ private float $unionOfFloatValues , /** @var 42|1337 */ private int $unionOfIntegerValues , /** @var 'foo'|'bar' */ private string $unionOfStringValues , ) {} }","title":"Union"},{"location":"mapping/inferring-interfaces/","text":"Inferring interfaces When the mapper meets an interface, it needs to understand which implementation (a class that implements this interface) will be used \u2014 this information must be provided in the mapper builder, using the method infer() . The callback given to this method must return the name of a class that implements the interface. Any arguments can be required by the callback; they will be mapped properly using the given source. $mapper = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> infer ( UuidInterface :: class , fn () => MyUuid :: class ) -> infer ( SomeInterface :: class , fn ( string $type ) => match ( $type ) { 'first' => FirstImplementation :: class , 'second' => SecondImplementation :: class , default => throw new DomainException ( \"Unhandled type ` $type `.\" ) }) -> mapper (); // Will return an instance of `FirstImplementation` $mapper -> map ( SomeInterface :: class , [ 'type' => 'first' , 'uuid' => 'a6868d61-acba-406d-bcff-30ecd8c0ceb6' , 'someString' => 'foo' , ]); // Will return an instance of `SecondImplementation` $mapper -> map ( SomeInterface :: class , [ 'type' => 'second' , 'uuid' => 'a6868d61-acba-406d-bcff-30ecd8c0ceb6' , 'someInt' => 42 , ]); interface SomeInterface {} final class FirstImplementation implements SomeInterface { public readonly UuidInterface $uuid ; public readonly string $someString ; } final class SecondImplementation implements SomeInterface { public readonly UuidInterface $uuid ; public readonly int $someInt ; }","title":"Inferring interfaces"},{"location":"mapping/inferring-interfaces/#inferring-interfaces","text":"When the mapper meets an interface, it needs to understand which implementation (a class that implements this interface) will be used \u2014 this information must be provided in the mapper builder, using the method infer() . The callback given to this method must return the name of a class that implements the interface. Any arguments can be required by the callback; they will be mapped properly using the given source. $mapper = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> infer ( UuidInterface :: class , fn () => MyUuid :: class ) -> infer ( SomeInterface :: class , fn ( string $type ) => match ( $type ) { 'first' => FirstImplementation :: class , 'second' => SecondImplementation :: class , default => throw new DomainException ( \"Unhandled type ` $type `.\" ) }) -> mapper (); // Will return an instance of `FirstImplementation` $mapper -> map ( SomeInterface :: class , [ 'type' => 'first' , 'uuid' => 'a6868d61-acba-406d-bcff-30ecd8c0ceb6' , 'someString' => 'foo' , ]); // Will return an instance of `SecondImplementation` $mapper -> map ( SomeInterface :: class , [ 'type' => 'second' , 'uuid' => 'a6868d61-acba-406d-bcff-30ecd8c0ceb6' , 'someInt' => 42 , ]); interface SomeInterface {} final class FirstImplementation implements SomeInterface { public readonly UuidInterface $uuid ; public readonly string $someString ; } final class SecondImplementation implements SomeInterface { public readonly UuidInterface $uuid ; public readonly int $someInt ; }","title":"Inferring interfaces"},{"location":"other/performance-and-cache/","text":"Performance & caching This library needs to parse a lot of information in order to handle all provided features. Therefore, it is strongly advised to activate the cache to reduce heavy workload between runtimes, especially when the application runs in a production environment. The library provides a cache implementation out of the box, which saves cache entries into the file system. Note It is also possible to use any PSR-16 compliant implementation, as long as it is capable of caching the entries handled by the library. When the application runs in a development environment, the cache implementation should be decorated with FileWatchingCache , which will watch the files of the application and invalidate cache entries when a PHP file is modified by a developer \u2014 preventing the library not behaving as expected when the signature of a property or a method changes. $cache = new \\CuyZ\\Valinor\\Cache\\FileSystemCache ( 'path/to/cache-directory' ); if ( $isApplicationInDevelopmentEnvironment ) { $cache = new \\CuyZ\\Valinor\\Cache\\FileWatchingCache ( $cache ); } ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> withCache ( $cache ) -> mapper () -> map ( SomeClass :: class , [ /* \u2026 */ ]); Warming up cache The cache can be warmed up, for instance in a pipeline during the build and deployment of the application. Note The cache has to be registered first, otherwise the warmup will end up being useless. $cache = new \\CuyZ\\Valinor\\Cache\\FileSystemCache ( 'path/to/cache-dir' ); $mapperBuilder = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> withCache ( $cache ); // During the build: $mapperBuilder -> warmup ( SomeClass :: class , SomeOtherClass :: class ); // In the application: $mapper -> mapper () -> map ( SomeClass :: class , [ /* \u2026 */ ]);","title":"Performance & caching"},{"location":"other/performance-and-cache/#performance-caching","text":"This library needs to parse a lot of information in order to handle all provided features. Therefore, it is strongly advised to activate the cache to reduce heavy workload between runtimes, especially when the application runs in a production environment. The library provides a cache implementation out of the box, which saves cache entries into the file system. Note It is also possible to use any PSR-16 compliant implementation, as long as it is capable of caching the entries handled by the library. When the application runs in a development environment, the cache implementation should be decorated with FileWatchingCache , which will watch the files of the application and invalidate cache entries when a PHP file is modified by a developer \u2014 preventing the library not behaving as expected when the signature of a property or a method changes. $cache = new \\CuyZ\\Valinor\\Cache\\FileSystemCache ( 'path/to/cache-directory' ); if ( $isApplicationInDevelopmentEnvironment ) { $cache = new \\CuyZ\\Valinor\\Cache\\FileWatchingCache ( $cache ); } ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> withCache ( $cache ) -> mapper () -> map ( SomeClass :: class , [ /* \u2026 */ ]);","title":"Performance &amp; caching"},{"location":"other/performance-and-cache/#warming-up-cache","text":"The cache can be warmed up, for instance in a pipeline during the build and deployment of the application. Note The cache has to be registered first, otherwise the warmup will end up being useless. $cache = new \\CuyZ\\Valinor\\Cache\\FileSystemCache ( 'path/to/cache-dir' ); $mapperBuilder = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> withCache ( $cache ); // During the build: $mapperBuilder -> warmup ( SomeClass :: class , SomeOtherClass :: class ); // In the application: $mapper -> mapper () -> map ( SomeClass :: class , [ /* \u2026 */ ]);","title":"Warming up cache"},{"location":"other/static-analysis/","text":"Static analysis To help static analysis of a codebase using this library, an extension for PHPStan and a plugin for Psalm are provided. They enable these tools to better understand the behaviour of the mapper. Considering at least one of those tools are installed on a project, below are examples of the kind of errors that would be reported. Mapping to an array of classes final class SomeClass { public function __construct ( public readonly string $foo , public readonly int $bar , ) {} } $objects = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( 'array<' . SomeClass :: class . '>' , [ /* \u2026 */ ] ); foreach ( $objects as $object ) { // \u2705 echo $object -> foo ; // \u2705 echo $object -> bar * 2 ; // \u274c Cannot perform operation between `string` and `int` echo $object -> foo * $object -> bar ; // \u274c Property `SomeClass::$fiz` is not defined echo $object -> fiz ; } Mapping to a shaped array $array = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( 'array{foo: string, bar: int}' , [ /* \u2026 */ ] ); // \u2705 echo $array [ 'foo' ]; // \u274c Expected `string` but got `int` echo strtolower ( $array [ 'bar' ]); // \u274c Cannot perform operation between `string` and `int` echo $array [ 'foo' ] * $array [ 'bar' ]; // \u274c Offset `fiz` does not exist on array echo $array [ 'fiz' ]; To activate this feature, the configuration must be updated for the installed tool(s): phpstan.neon includes : - vendor/cuyz/valinor/qa/PHPStan/valinor-phpstan-configuration.php psalm.xml <plugins> <plugin filename= \"vendor/cuyz/valinor/qa/Psalm/Plugin/TreeMapperPsalmPlugin.php\" /> </plugins>","title":"Static analysis"},{"location":"other/static-analysis/#static-analysis","text":"To help static analysis of a codebase using this library, an extension for PHPStan and a plugin for Psalm are provided. They enable these tools to better understand the behaviour of the mapper. Considering at least one of those tools are installed on a project, below are examples of the kind of errors that would be reported. Mapping to an array of classes final class SomeClass { public function __construct ( public readonly string $foo , public readonly int $bar , ) {} } $objects = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( 'array<' . SomeClass :: class . '>' , [ /* \u2026 */ ] ); foreach ( $objects as $object ) { // \u2705 echo $object -> foo ; // \u2705 echo $object -> bar * 2 ; // \u274c Cannot perform operation between `string` and `int` echo $object -> foo * $object -> bar ; // \u274c Property `SomeClass::$fiz` is not defined echo $object -> fiz ; } Mapping to a shaped array $array = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( 'array{foo: string, bar: int}' , [ /* \u2026 */ ] ); // \u2705 echo $array [ 'foo' ]; // \u274c Expected `string` but got `int` echo strtolower ( $array [ 'bar' ]); // \u274c Cannot perform operation between `string` and `int` echo $array [ 'foo' ] * $array [ 'bar' ]; // \u274c Offset `fiz` does not exist on array echo $array [ 'fiz' ]; To activate this feature, the configuration must be updated for the installed tool(s): phpstan.neon includes : - vendor/cuyz/valinor/qa/PHPStan/valinor-phpstan-configuration.php psalm.xml <plugins> <plugin filename= \"vendor/cuyz/valinor/qa/Psalm/Plugin/TreeMapperPsalmPlugin.php\" /> </plugins>","title":"Static analysis"}]}