{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u00b6 \u2014 From boring old arrays to shiny typed objects \u2014 Valinor takes care of the construction and validation of raw inputs (JSON, plain arrays, etc.) into objects, ensuring a perfectly valid state. It allows the objects to be used without having to worry about their integrity during the whole application lifecycle. The validation system will detect any incorrect value and help the developers by providing precise and human-readable error messages. The mapper can handle native PHP types as well as other advanced types supported by PHPStan and Psalm like shaped arrays, generics, integer ranges and more. Why? \u00b6 There are many benefits of using objects instead of plain arrays in a codebase: Type safety \u2014 the structure of an object is known and guaranteed, no need for type checks once the object is constructed. Data integrity \u2014 the object cannot be in an invalid state, it will always contain valid data. Encapsulation \u2014 the logic of an object is isolated from the outside. Validating and transforming raw data into an object can be achieved easily with native PHP, but it requires a lot a boilerplate code. Below is a simple example of doing that without a mapper: final class Person { public readonly string $name ; public readonly DateTimeInterface $birthDate ; } $data = $client -> request ( 'GET' , 'https://example.com/person/42' ) -> toArray (); if ( ! isset ( $data [ 'name' ]) || ! is_string ( $data [ 'name' ])) { // Cumbersome error handling } if ( ! isset ( $data [ 'birthDate' ]) || ! is_string ( $data [ 'birthDate' ])) { // Another cumbersome error handling } $birthDate = DateTimeImmutable :: createFromFormat ( 'Y-m-d' , $data [ 'birthDate' ]); if ( ! $birthDate instanceof DateTimeInterface ) { // Yet another cumbersome error handling } $person = new Person ( $data [ 'name' ], $birthDate ); Using a mapper saves a lot of time and energy, especially on objects with a lot of properties: $data = $client -> request ( 'GET' , 'https://example.com/person/42' ) -> toArray (); try { $person = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( Person :: class , $data ); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { // Detailed error handling } This library provides advanced features for more complex cases, check out the next chapter to get started.","title":"Introduction"},{"location":"#_1","text":"\u2014 From boring old arrays to shiny typed objects \u2014 Valinor takes care of the construction and validation of raw inputs (JSON, plain arrays, etc.) into objects, ensuring a perfectly valid state. It allows the objects to be used without having to worry about their integrity during the whole application lifecycle. The validation system will detect any incorrect value and help the developers by providing precise and human-readable error messages. The mapper can handle native PHP types as well as other advanced types supported by PHPStan and Psalm like shaped arrays, generics, integer ranges and more.","title":"&nbsp;"},{"location":"#why","text":"There are many benefits of using objects instead of plain arrays in a codebase: Type safety \u2014 the structure of an object is known and guaranteed, no need for type checks once the object is constructed. Data integrity \u2014 the object cannot be in an invalid state, it will always contain valid data. Encapsulation \u2014 the logic of an object is isolated from the outside. Validating and transforming raw data into an object can be achieved easily with native PHP, but it requires a lot a boilerplate code. Below is a simple example of doing that without a mapper: final class Person { public readonly string $name ; public readonly DateTimeInterface $birthDate ; } $data = $client -> request ( 'GET' , 'https://example.com/person/42' ) -> toArray (); if ( ! isset ( $data [ 'name' ]) || ! is_string ( $data [ 'name' ])) { // Cumbersome error handling } if ( ! isset ( $data [ 'birthDate' ]) || ! is_string ( $data [ 'birthDate' ])) { // Another cumbersome error handling } $birthDate = DateTimeImmutable :: createFromFormat ( 'Y-m-d' , $data [ 'birthDate' ]); if ( ! $birthDate instanceof DateTimeInterface ) { // Yet another cumbersome error handling } $person = new Person ( $data [ 'name' ], $birthDate ); Using a mapper saves a lot of time and energy, especially on objects with a lot of properties: $data = $client -> request ( 'GET' , 'https://example.com/person/42' ) -> toArray (); try { $person = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( Person :: class , $data ); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { // Detailed error handling } This library provides advanced features for more complex cases, check out the next chapter to get started.","title":"Why?"},{"location":"getting-started/","text":"Getting started \u00b6 Installation \u00b6 composer require cuyz/valinor Example \u00b6 An application must handle the data coming from an external API; the response has a JSON format and describes a thread and its answers. The validity of this input is unsure, besides manipulating a raw JSON string is laborious and inefficient. { \"id\" : 1337 , \"content\" : \"Do you like potatoes?\" , \"date\" : \"1957-07-23 13:37:42\" , \"answers\" : [ { \"user\" : \"Ella F.\" , \"message\" : \"I like potatoes\" , \"date\" : \"1957-07-31 15:28:12\" }, { \"user\" : \"Louis A.\" , \"message\" : \"And I like tomatoes\" , \"date\" : \"1957-08-13 09:05:24\" } ] } The application must be certain that it can handle this data correctly; wrapping the input in a value object will help. A schema representing the needed structure must be provided, using classes. final class Thread { public function __construct ( public readonly int $id , public readonly string $content , public readonly DateTimeInterface $date , /** @var Answer[] */ public readonly array $answers , ) {} } final class Answer { public function __construct ( public readonly string $user , public readonly string $message , public readonly DateTimeInterface $date , ) {} } Then a mapper is used to hydrate a source into these objects. public function getThread ( int $id ) : Thread { $rawJson = $this -> client -> request ( \"https://example.com/thread/ $id \" ); try { return ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( Thread :: class , new \\CuyZ\\Valinor\\Mapper\\Source\\JsonSource ( $rawJson ) ); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { // Do something\u2026 } } Mapping advanced types \u00b6 Although it is recommended to map an input to a value object, in some cases mapping to another type can be easier/more flexible. It is for instance possible to map to an array of objects: try { $objects = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( 'array<' . SomeClass :: class . '>' , [ /* \u2026 */ ] ); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { // Do something\u2026 } For simple use-cases, an array shape can be used: try { $array = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( 'array{foo: string, bar: int}' , [ /* \u2026 */ ] ); echo $array [ 'foo' ]; echo $array [ 'bar' ] * 2 ; } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { // Do something\u2026 }","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting started"},{"location":"getting-started/#installation","text":"composer require cuyz/valinor","title":"Installation"},{"location":"getting-started/#example","text":"An application must handle the data coming from an external API; the response has a JSON format and describes a thread and its answers. The validity of this input is unsure, besides manipulating a raw JSON string is laborious and inefficient. { \"id\" : 1337 , \"content\" : \"Do you like potatoes?\" , \"date\" : \"1957-07-23 13:37:42\" , \"answers\" : [ { \"user\" : \"Ella F.\" , \"message\" : \"I like potatoes\" , \"date\" : \"1957-07-31 15:28:12\" }, { \"user\" : \"Louis A.\" , \"message\" : \"And I like tomatoes\" , \"date\" : \"1957-08-13 09:05:24\" } ] } The application must be certain that it can handle this data correctly; wrapping the input in a value object will help. A schema representing the needed structure must be provided, using classes. final class Thread { public function __construct ( public readonly int $id , public readonly string $content , public readonly DateTimeInterface $date , /** @var Answer[] */ public readonly array $answers , ) {} } final class Answer { public function __construct ( public readonly string $user , public readonly string $message , public readonly DateTimeInterface $date , ) {} } Then a mapper is used to hydrate a source into these objects. public function getThread ( int $id ) : Thread { $rawJson = $this -> client -> request ( \"https://example.com/thread/ $id \" ); try { return ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( Thread :: class , new \\CuyZ\\Valinor\\Mapper\\Source\\JsonSource ( $rawJson ) ); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { // Do something\u2026 } }","title":"Example"},{"location":"getting-started/#mapping-advanced-types","text":"Although it is recommended to map an input to a value object, in some cases mapping to another type can be easier/more flexible. It is for instance possible to map to an array of objects: try { $objects = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( 'array<' . SomeClass :: class . '>' , [ /* \u2026 */ ] ); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { // Do something\u2026 } For simple use-cases, an array shape can be used: try { $array = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( 'array{foo: string, bar: int}' , [ /* \u2026 */ ] ); echo $array [ 'foo' ]; echo $array [ 'bar' ] * 2 ; } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { // Do something\u2026 }","title":"Mapping advanced types"},{"location":"how-to/customize-error-messages/","text":"Customizing error messages \u00b6 The content of a message can be changed to fit custom use cases; it can contain placeholders that will be replaced with useful information. The placeholders below are always available; even more may be used depending on the original message. Placeholder Description {message_code} the code of the message {node_name} name of the node to which the message is bound {node_path} path of the node to which the message is bound {node_type} type of the node to which the message is bound {source_value} the source value that was given to the node {original_message} the original message before being customized Usage: try { ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( SomeClass :: class , [ /* \u2026 */ ]); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { $messages = \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Messages :: flattenFromNode ( $error -> node () ); foreach ( $messages as $message ) { if ( $message -> code () === 'some_code' ) { $message = $message -> withParameter ( 'some_parameter' , 'some custom value' ) -> withBody ( 'new message / {message_code} / {some_parameter}' ); } // new message / some_code / some custom value echo $message ; } } The messages are formatted using the ICU library , enabling the placeholders to use advanced syntax to perform proper translations, for instance currency support. try { ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( 'int<0, 100>' , 1337 ); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { $message = $error -> node () -> messages ()[ 0 ]; if ( is_numeric ( $message -> node () -> mappedValue ())) { $message = $message -> withBody ( 'Invalid amount {source_value, number, currency}' ); } // Invalid amount: $1,337.00 echo $message -> withLocale ( 'en_US' ); // Invalid amount: \u00a31,337.00 echo $message -> withLocale ( 'en_GB' ); // Invalid amount: 1 337,00 \u20ac echo $message -> withLocale ( 'fr_FR' ); } See ICU documentation for more information on available syntax. Warning If the intl extension is not installed, a shim will be available to replace the placeholders, but it won't handle advanced syntax as described above. Deeper message customization / translation \u00b6 For deeper message changes, formatters can be used to customize body and parameters. Note Formatters can be added to messages Translation \u00b6 The formatter TranslationMessageFormatter can be used to translate the content of messages. The library provides a list of all messages that can be returned; this list can be filled or modified with custom translations. \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\TranslationMessageFormatter :: default () // Create/override a single entry\u2026 -> withTranslation ( 'fr' , 'some custom message' , 'un message personnalis\u00e9' ) // \u2026or several entries. -> withTranslations ([ 'some custom message' => [ 'en' => 'Some custom message' , 'fr' => 'Un message personnalis\u00e9' , 'es' => 'Un mensaje personalizado' , ], 'some other message' => [ // \u2026 ], ]) -> format ( $message ); Replacement map \u00b6 The formatter MessageMapFormatter can be used to provide a list of messages replacements. It can be instantiated with an array where each key represents either: The code of the message to be replaced The body of the message to be replaced The class name of the message to be replaced If none of those is found, the content of the message will stay unchanged unless a default one is given to the class. If one of these keys is found, the array entry will be used to replace the content of the message. This entry can be either a plain text or a callable that takes the message as a parameter and returns a string; it is for instance advised to use a callable in cases where a custom translation service is used \u2014 to avoid useless greedy operations. In any case, the content can contain placeholders as described above . ( new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\MessageMapFormatter ([ // Will match if the given message has this exact code 'some_code' => 'New content / code: {message_code}' , // Will match if the given message has this exact content 'Some message content' => 'New content / previous: {original_message}' , // Will match if the given message is an instance of `SomeError` SomeError :: class => 'New content / value: {source_value}' , // A callback can be used to get access to the message instance OtherError :: class => function ( NodeMessage $message ) : string { if ( $message -> path () === 'foo.bar' ) { return 'Some custom message' ; } return $message -> body (); }, // For greedy operation, it is advised to use a lazy-callback 'foo' => fn () => $this -> customTranslator -> translate ( 'foo.bar' ), ])) -> defaultsTo ( 'some default message' ) // \u2026or\u2026 -> defaultsTo ( fn () => $this -> customTranslator -> translate ( 'default_message' )) -> format ( $message ); Several formatters \u00b6 It is possible to join several formatters into one formatter by using the AggregateMessageFormatter . This instance can then easily be injected in a service that will handle messages. The formatters will be called in the same order they are given to the aggregate. ( new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\AggregateMessageFormatter ( new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\LocaleMessageFormatter ( 'fr' ), new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\MessageMapFormatter ([ // \u2026 ], \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\TranslationMessageFormatter :: default (), )) -> format ( $message )","title":"Customize error messages"},{"location":"how-to/customize-error-messages/#customizing-error-messages","text":"The content of a message can be changed to fit custom use cases; it can contain placeholders that will be replaced with useful information. The placeholders below are always available; even more may be used depending on the original message. Placeholder Description {message_code} the code of the message {node_name} name of the node to which the message is bound {node_path} path of the node to which the message is bound {node_type} type of the node to which the message is bound {source_value} the source value that was given to the node {original_message} the original message before being customized Usage: try { ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( SomeClass :: class , [ /* \u2026 */ ]); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { $messages = \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Messages :: flattenFromNode ( $error -> node () ); foreach ( $messages as $message ) { if ( $message -> code () === 'some_code' ) { $message = $message -> withParameter ( 'some_parameter' , 'some custom value' ) -> withBody ( 'new message / {message_code} / {some_parameter}' ); } // new message / some_code / some custom value echo $message ; } } The messages are formatted using the ICU library , enabling the placeholders to use advanced syntax to perform proper translations, for instance currency support. try { ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( 'int<0, 100>' , 1337 ); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { $message = $error -> node () -> messages ()[ 0 ]; if ( is_numeric ( $message -> node () -> mappedValue ())) { $message = $message -> withBody ( 'Invalid amount {source_value, number, currency}' ); } // Invalid amount: $1,337.00 echo $message -> withLocale ( 'en_US' ); // Invalid amount: \u00a31,337.00 echo $message -> withLocale ( 'en_GB' ); // Invalid amount: 1 337,00 \u20ac echo $message -> withLocale ( 'fr_FR' ); } See ICU documentation for more information on available syntax. Warning If the intl extension is not installed, a shim will be available to replace the placeholders, but it won't handle advanced syntax as described above.","title":"Customizing error messages"},{"location":"how-to/customize-error-messages/#deeper-message-customization-translation","text":"For deeper message changes, formatters can be used to customize body and parameters. Note Formatters can be added to messages","title":"Deeper message customization / translation"},{"location":"how-to/customize-error-messages/#translation","text":"The formatter TranslationMessageFormatter can be used to translate the content of messages. The library provides a list of all messages that can be returned; this list can be filled or modified with custom translations. \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\TranslationMessageFormatter :: default () // Create/override a single entry\u2026 -> withTranslation ( 'fr' , 'some custom message' , 'un message personnalis\u00e9' ) // \u2026or several entries. -> withTranslations ([ 'some custom message' => [ 'en' => 'Some custom message' , 'fr' => 'Un message personnalis\u00e9' , 'es' => 'Un mensaje personalizado' , ], 'some other message' => [ // \u2026 ], ]) -> format ( $message );","title":"Translation"},{"location":"how-to/customize-error-messages/#replacement-map","text":"The formatter MessageMapFormatter can be used to provide a list of messages replacements. It can be instantiated with an array where each key represents either: The code of the message to be replaced The body of the message to be replaced The class name of the message to be replaced If none of those is found, the content of the message will stay unchanged unless a default one is given to the class. If one of these keys is found, the array entry will be used to replace the content of the message. This entry can be either a plain text or a callable that takes the message as a parameter and returns a string; it is for instance advised to use a callable in cases where a custom translation service is used \u2014 to avoid useless greedy operations. In any case, the content can contain placeholders as described above . ( new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\MessageMapFormatter ([ // Will match if the given message has this exact code 'some_code' => 'New content / code: {message_code}' , // Will match if the given message has this exact content 'Some message content' => 'New content / previous: {original_message}' , // Will match if the given message is an instance of `SomeError` SomeError :: class => 'New content / value: {source_value}' , // A callback can be used to get access to the message instance OtherError :: class => function ( NodeMessage $message ) : string { if ( $message -> path () === 'foo.bar' ) { return 'Some custom message' ; } return $message -> body (); }, // For greedy operation, it is advised to use a lazy-callback 'foo' => fn () => $this -> customTranslator -> translate ( 'foo.bar' ), ])) -> defaultsTo ( 'some default message' ) // \u2026or\u2026 -> defaultsTo ( fn () => $this -> customTranslator -> translate ( 'default_message' )) -> format ( $message );","title":"Replacement map"},{"location":"how-to/customize-error-messages/#several-formatters","text":"It is possible to join several formatters into one formatter by using the AggregateMessageFormatter . This instance can then easily be injected in a service that will handle messages. The formatters will be called in the same order they are given to the aggregate. ( new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\AggregateMessageFormatter ( new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\LocaleMessageFormatter ( 'fr' ), new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\MessageMapFormatter ([ // \u2026 ], \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\TranslationMessageFormatter :: default (), )) -> format ( $message )","title":"Several formatters"},{"location":"how-to/deal-with-dates/","text":"Dealing with dates \u00b6 When the mapper builds a date object, it has to know which format(s) are supported. By default, any valid timestamp or ATOM-formatted value will be accepted. If other formats are to be supported, they need to be registered using the following method: ( new \\CuyZ\\Valinor\\MapperBuilder ()) // Both `Cookie` and `ATOM` formats will be accepted -> supportDateFormats ( DATE_COOKIE , DATE_ATOM ) -> mapper () -> map ( DateTimeInterface :: class , 'Monday, 08-Nov-1971 13:37:42 UTC' ); Custom date class implementation \u00b6 By default, the library will map a DateTimeInterface to a DateTimeImmutable instance. If other implementations are to be supported, custom constructors can be used. Here is an implementation example for the nesbot/carbon library: ( new MapperBuilder ()) // When the mapper meets a `DateTimeInterface` it will convert it to Carbon -> infer ( DateTimeInterface :: class , fn () => \\Carbon\\Carbon :: class ) // We teach the mapper how to create a Carbon instance -> registerConstructor ( function ( string $time ) : \\Carbon\\Carbon { // Only `Cookie` format will be accepted return Carbon :: createFromFormat ( DATE_COOKIE , $time ); }) // Carbon uses its own exceptions, so we need to wrap it for the mapper -> filterExceptions ( function ( Throwable $exception ) { if ( $exception instanceof \\Carbon\\Exceptions\\Exception ) { return \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\MessageBuilder :: from ( $exception ); } throw $exception ; }) -> mapper () -> map ( DateTimeInterface :: class , 'Monday, 08-Nov-1971 13:37:42 UTC' );","title":"Deal with dates"},{"location":"how-to/deal-with-dates/#dealing-with-dates","text":"When the mapper builds a date object, it has to know which format(s) are supported. By default, any valid timestamp or ATOM-formatted value will be accepted. If other formats are to be supported, they need to be registered using the following method: ( new \\CuyZ\\Valinor\\MapperBuilder ()) // Both `Cookie` and `ATOM` formats will be accepted -> supportDateFormats ( DATE_COOKIE , DATE_ATOM ) -> mapper () -> map ( DateTimeInterface :: class , 'Monday, 08-Nov-1971 13:37:42 UTC' );","title":"Dealing with dates"},{"location":"how-to/deal-with-dates/#custom-date-class-implementation","text":"By default, the library will map a DateTimeInterface to a DateTimeImmutable instance. If other implementations are to be supported, custom constructors can be used. Here is an implementation example for the nesbot/carbon library: ( new MapperBuilder ()) // When the mapper meets a `DateTimeInterface` it will convert it to Carbon -> infer ( DateTimeInterface :: class , fn () => \\Carbon\\Carbon :: class ) // We teach the mapper how to create a Carbon instance -> registerConstructor ( function ( string $time ) : \\Carbon\\Carbon { // Only `Cookie` format will be accepted return Carbon :: createFromFormat ( DATE_COOKIE , $time ); }) // Carbon uses its own exceptions, so we need to wrap it for the mapper -> filterExceptions ( function ( Throwable $exception ) { if ( $exception instanceof \\Carbon\\Exceptions\\Exception ) { return \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\MessageBuilder :: from ( $exception ); } throw $exception ; }) -> mapper () -> map ( DateTimeInterface :: class , 'Monday, 08-Nov-1971 13:37:42 UTC' );","title":"Custom date class implementation"},{"location":"how-to/infer-interfaces/","text":"Inferring interfaces \u00b6 When the mapper meets an interface, it needs to understand which implementation (a class that implements this interface) will be used \u2014 this information must be provided in the mapper builder, using the method infer() . The callback given to this method must return the name of a class that implements the interface. Any arguments can be required by the callback; they will be mapped properly using the given source. If the callback can return several class names, it needs to provide a return signature with the list of all class-strings that can be returned (see below). $mapper = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> infer ( UuidInterface :: class , fn () => MyUuid :: class ) -> infer ( SomeInterface :: class , /** @return class-string<FirstImplementation|SecondImplementation> */ fn ( string $type ) => match ( $type ) { 'first' => FirstImplementation :: class , 'second' => SecondImplementation :: class , default => throw new DomainException ( \"Unhandled type ` $type `.\" ) } ) -> mapper (); // Will return an instance of `FirstImplementation` $mapper -> map ( SomeInterface :: class , [ 'type' => 'first' , 'uuid' => 'a6868d61-acba-406d-bcff-30ecd8c0ceb6' , 'someString' => 'foo' , ]); // Will return an instance of `SecondImplementation` $mapper -> map ( SomeInterface :: class , [ 'type' => 'second' , 'uuid' => 'a6868d61-acba-406d-bcff-30ecd8c0ceb6' , 'someInt' => 42 , ]); interface SomeInterface {} final class FirstImplementation implements SomeInterface { public readonly UuidInterface $uuid ; public readonly string $someString ; } final class SecondImplementation implements SomeInterface { public readonly UuidInterface $uuid ; public readonly int $someInt ; }","title":"Infer interfaces"},{"location":"how-to/infer-interfaces/#inferring-interfaces","text":"When the mapper meets an interface, it needs to understand which implementation (a class that implements this interface) will be used \u2014 this information must be provided in the mapper builder, using the method infer() . The callback given to this method must return the name of a class that implements the interface. Any arguments can be required by the callback; they will be mapped properly using the given source. If the callback can return several class names, it needs to provide a return signature with the list of all class-strings that can be returned (see below). $mapper = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> infer ( UuidInterface :: class , fn () => MyUuid :: class ) -> infer ( SomeInterface :: class , /** @return class-string<FirstImplementation|SecondImplementation> */ fn ( string $type ) => match ( $type ) { 'first' => FirstImplementation :: class , 'second' => SecondImplementation :: class , default => throw new DomainException ( \"Unhandled type ` $type `.\" ) } ) -> mapper (); // Will return an instance of `FirstImplementation` $mapper -> map ( SomeInterface :: class , [ 'type' => 'first' , 'uuid' => 'a6868d61-acba-406d-bcff-30ecd8c0ceb6' , 'someString' => 'foo' , ]); // Will return an instance of `SecondImplementation` $mapper -> map ( SomeInterface :: class , [ 'type' => 'second' , 'uuid' => 'a6868d61-acba-406d-bcff-30ecd8c0ceb6' , 'someInt' => 42 , ]); interface SomeInterface {} final class FirstImplementation implements SomeInterface { public readonly UuidInterface $uuid ; public readonly string $someString ; } final class SecondImplementation implements SomeInterface { public readonly UuidInterface $uuid ; public readonly int $someInt ; }","title":"Inferring interfaces"},{"location":"how-to/map-arguments-of-a-callable/","text":"Mapping arguments of a callable \u00b6 This library can map the arguments of a callable; it can be used to ensure a source has the right shape before calling a function/method. The mapper builder can be configured the same way it would be with a tree mapper, for instance to customize the type strictness . $someFunction = function ( string $foo , int $bar ) : string { return \" $foo / $bar \" ; } try { $arguments = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> argumentsMapper () -> mapArguments ( $someFunction , [ 'foo' => 'some value' , 'bar' => 42 , ]); // some value / 42 echo $someFunction ( ... $arguments ); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { // Do something\u2026 } Any callable can be given to the arguments mapper: final class SomeController { public static function someAction ( string $foo , int $bar ) : string { return \" $foo / $bar \" ; } } try { $arguments = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> argumentsMapper () -> mapArguments ( SomeController :: someAction ( ... ), [ 'foo' => 'some value' , 'bar' => 42 , ]); // some value / 42 echo SomeController :: someAction ( ... $arguments ); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { // Do something\u2026 }","title":"Map arguments of a callable"},{"location":"how-to/map-arguments-of-a-callable/#mapping-arguments-of-a-callable","text":"This library can map the arguments of a callable; it can be used to ensure a source has the right shape before calling a function/method. The mapper builder can be configured the same way it would be with a tree mapper, for instance to customize the type strictness . $someFunction = function ( string $foo , int $bar ) : string { return \" $foo / $bar \" ; } try { $arguments = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> argumentsMapper () -> mapArguments ( $someFunction , [ 'foo' => 'some value' , 'bar' => 42 , ]); // some value / 42 echo $someFunction ( ... $arguments ); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { // Do something\u2026 } Any callable can be given to the arguments mapper: final class SomeController { public static function someAction ( string $foo , int $bar ) : string { return \" $foo / $bar \" ; } } try { $arguments = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> argumentsMapper () -> mapArguments ( SomeController :: someAction ( ... ), [ 'foo' => 'some value' , 'bar' => 42 , ]); // some value / 42 echo SomeController :: someAction ( ... $arguments ); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { // Do something\u2026 }","title":"Mapping arguments of a callable"},{"location":"how-to/transform-input/","text":"Transforming input \u00b6 Any source can be given to the mapper, be it an array, some json, yaml or even a file: $mapper = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper (); $mapper -> map ( SomeClass :: class , \\CuyZ\\Valinor\\Mapper\\Source\\Source :: array ( $someData ) ); $mapper -> map ( SomeClass :: class , \\CuyZ\\Valinor\\Mapper\\Source\\Source :: json ( $jsonString ) ); $mapper -> map ( SomeClass :: class , \\CuyZ\\Valinor\\Mapper\\Source\\Source :: yaml ( $yamlString ) ); $mapper -> map ( SomeClass :: class , // File containing valid Json or Yaml content and with valid extension \\CuyZ\\Valinor\\Mapper\\Source\\Source :: file ( new SplFileObject ( 'path/to/my/file.json' ) ) ); Modifiers \u00b6 Sometimes the source is not in the same format and/or organised in the same way as a value object. Modifiers can be used to change a source before the mapping occurs. Camel case keys \u00b6 This modifier recursively forces all keys to be in camelCase format. final class SomeClass { public readonly string $someValue ; } $source = \\CuyZ\\Valinor\\Mapper\\Source\\Source :: array ([ 'some_value' => 'foo' , // \u2026or\u2026 'some-value' => 'foo' , // \u2026or\u2026 'some value' => 'foo' , // \u2026will be replaced by `['someValue' => 'foo']` ]) -> camelCaseKeys (); ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( SomeClass :: class , $source ); Path mapping \u00b6 This modifier can be used to change paths in the source data using a dot notation. The mapping is done using an associative array of path mappings. This array must have the source path as key and the target path as value. The source path uses the dot notation (eg A.B.C ) and can contain one * for array paths (eg A.B.*.C ). final class Country { /** @var non-empty-string */ public readonly string $name ; /** @var list<City> */ public readonly array $cities ; } final class City { /** @var non-empty-string */ public readonly string $name ; public readonly DateTimeZone $timeZone ; } $source = \\CuyZ\\Valinor\\Mapper\\Source\\Source :: array ([ 'identification' => 'France' , 'towns' => [ [ 'label' => 'Paris' , 'timeZone' => 'Europe/Paris' , ], [ 'label' => 'Lyon' , 'timeZone' => 'Europe/Paris' , ], ], ]) -> map ([ 'identification' => 'name' , 'towns' => 'cities' , 'towns.*.label' => 'name' , ]); // After modification this is what the source will look like: // [ // 'name' => 'France', // 'cities' => [ // [ // 'name' => 'Paris', // 'timeZone' => 'Europe/Paris', // ], // [ // 'name' => 'Lyon', // 'timeZone' => 'Europe/Paris', // ], // ], // ]; ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( Country :: class , $source ); Custom source \u00b6 The source is just an iterable, so it's easy to create a custom one. It can even be combined with the provided builder. final class AcmeSource implements IteratorAggregate { private iterable $source ; public function __construct ( iterable $source ) { $this -> source = $this -> doSomething ( $source ); } private function doSomething ( iterable $source ) : iterable { // Do something with $source return $source ; } public function getIterator () { yield from $this -> source ; } } $source = \\CuyZ\\Valinor\\Mapper\\Source\\Source :: iterable ( new AcmeSource ([ 'valueA' => 'foo' , 'valueB' => 'bar' , ]) ) -> camelCaseKeys (); ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( SomeClass :: class , $source );","title":"Transform input"},{"location":"how-to/transform-input/#transforming-input","text":"Any source can be given to the mapper, be it an array, some json, yaml or even a file: $mapper = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper (); $mapper -> map ( SomeClass :: class , \\CuyZ\\Valinor\\Mapper\\Source\\Source :: array ( $someData ) ); $mapper -> map ( SomeClass :: class , \\CuyZ\\Valinor\\Mapper\\Source\\Source :: json ( $jsonString ) ); $mapper -> map ( SomeClass :: class , \\CuyZ\\Valinor\\Mapper\\Source\\Source :: yaml ( $yamlString ) ); $mapper -> map ( SomeClass :: class , // File containing valid Json or Yaml content and with valid extension \\CuyZ\\Valinor\\Mapper\\Source\\Source :: file ( new SplFileObject ( 'path/to/my/file.json' ) ) );","title":"Transforming input"},{"location":"how-to/transform-input/#modifiers","text":"Sometimes the source is not in the same format and/or organised in the same way as a value object. Modifiers can be used to change a source before the mapping occurs.","title":"Modifiers"},{"location":"how-to/transform-input/#camel-case-keys","text":"This modifier recursively forces all keys to be in camelCase format. final class SomeClass { public readonly string $someValue ; } $source = \\CuyZ\\Valinor\\Mapper\\Source\\Source :: array ([ 'some_value' => 'foo' , // \u2026or\u2026 'some-value' => 'foo' , // \u2026or\u2026 'some value' => 'foo' , // \u2026will be replaced by `['someValue' => 'foo']` ]) -> camelCaseKeys (); ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( SomeClass :: class , $source );","title":"Camel case keys"},{"location":"how-to/transform-input/#path-mapping","text":"This modifier can be used to change paths in the source data using a dot notation. The mapping is done using an associative array of path mappings. This array must have the source path as key and the target path as value. The source path uses the dot notation (eg A.B.C ) and can contain one * for array paths (eg A.B.*.C ). final class Country { /** @var non-empty-string */ public readonly string $name ; /** @var list<City> */ public readonly array $cities ; } final class City { /** @var non-empty-string */ public readonly string $name ; public readonly DateTimeZone $timeZone ; } $source = \\CuyZ\\Valinor\\Mapper\\Source\\Source :: array ([ 'identification' => 'France' , 'towns' => [ [ 'label' => 'Paris' , 'timeZone' => 'Europe/Paris' , ], [ 'label' => 'Lyon' , 'timeZone' => 'Europe/Paris' , ], ], ]) -> map ([ 'identification' => 'name' , 'towns' => 'cities' , 'towns.*.label' => 'name' , ]); // After modification this is what the source will look like: // [ // 'name' => 'France', // 'cities' => [ // [ // 'name' => 'Paris', // 'timeZone' => 'Europe/Paris', // ], // [ // 'name' => 'Lyon', // 'timeZone' => 'Europe/Paris', // ], // ], // ]; ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( Country :: class , $source );","title":"Path mapping"},{"location":"how-to/transform-input/#custom-source","text":"The source is just an iterable, so it's easy to create a custom one. It can even be combined with the provided builder. final class AcmeSource implements IteratorAggregate { private iterable $source ; public function __construct ( iterable $source ) { $this -> source = $this -> doSomething ( $source ); } private function doSomething ( iterable $source ) : iterable { // Do something with $source return $source ; } public function getIterator () { yield from $this -> source ; } } $source = \\CuyZ\\Valinor\\Mapper\\Source\\Source :: iterable ( new AcmeSource ([ 'valueA' => 'foo' , 'valueB' => 'bar' , ]) ) -> camelCaseKeys (); ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( SomeClass :: class , $source );","title":"Custom source"},{"location":"how-to/use-custom-object-constructors/","text":"Using custom object constructors \u00b6 An object may have custom ways of being created, in such cases these constructors need to be registered to the mapper to be used. A constructor is a callable that can be either: A named constructor, also known as a static factory method The method of a service \u2014 for instance a repository A \"callable object\" \u2014 a class that declares an __invoke method Any other callable \u2014 including anonymous functions In any case, the return type of the callable will be resolved by the mapper to know when to use it. Any argument can be provided and will automatically be mapped using the given source. These arguments can then be used to instantiate the object in the desired way. Registering any constructor will disable the native constructor \u2014 the __construct method \u2014 of the targeted class. If for some reason it still needs to be handled as well, the name of the class must be given to the registration method. If several constructors are registered, they must provide distinct signatures to prevent collision during mapping \u2014 meaning that if two constructors require several arguments with the exact same names, the mapping will fail. ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> registerConstructor ( // Allow the native constructor to be used Color :: class , // Register a named constructor (1) Color :: fromHex ( ... ), /** * An anonymous function can also be used, for instance when the desired * object is an external dependency that cannot be modified. * * @param 'red'|'green'|'blue' $color * @param 'dark'|'light' $darkness */ function ( string $color , string $darkness ) : Color { $main = $darkness === 'dark' ? 128 : 255 ; $other = $darkness === 'dark' ? 0 : 128 ; return new Color ( $color === 'red' ? $main : $other , $color === 'green' ? $main : $other , $color === 'blue' ? $main : $other , ); } ) -> mapper () -> map ( Color :: class , [ /* \u2026 */ ]); final class Color { /** * @param int<0, 255> $red * @param int<0, 255> $green * @param int<0, 255> $blue */ public function __construct ( public readonly int $red , public readonly int $green , public readonly int $blue ) {} /** * @param non-empty-string $hex */ public static function fromHex ( string $hex ) : self { if ( strlen ( $hex ) !== 6 ) { throw new DomainException ( 'Must be 6 characters long' ); } /** @var int<0, 255> $red */ $red = hexdec ( substr ( $hex , 0 , 2 )); /** @var int<0, 255> $green */ $green = hexdec ( substr ( $hex , 2 , 2 )); /** @var int<0, 255> $blue */ $blue = hexdec ( substr ( $hex , 4 , 2 )); return new self ( $red , $green , $blue ); } } \u2026or for PHP < 8.1: [ Color :: class , 'fromHex' ], Dynamic constructors \u00b6 In some situations the type handled by a constructor is only known at runtime, in which case the constructor needs to know what class must be used to instantiate the object. For instance, an interface may declare a static constructor that is then implemented by several child classes. One solution would be to register the constructor for each child class, which leads to a lot of boilerplate code and would require a new registration each time a new child is created. Another way is to use the attribute \\CuyZ\\Valinor\\Mapper\\Object\\DynamicConstructor . When a constructor uses this attribute, its first parameter must be a string and will be filled with the name of the actual class that the mapper needs to build when the constructor is called. Other arguments may be added and will be mapped normally, depending on the source given to the mapper. interface InterfaceWithStaticConstructor { public static function from ( string $value ) : self ; } final class ClassWithInheritedStaticConstructor implements InterfaceWithStaticConstructor { private function __construct ( private SomeValueObject $value ) {} public static function from ( string $value ) : self { return new self ( new SomeValueObject ( $value )); } } ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> registerConstructor ( #[\\CuyZ\\Valinor\\Attribute\\DynamicConstructor] function ( string $className , string $value ) : InterfaceWithStaticConstructor { return $className :: from ( $value ); } ) -> mapper () -> map ( ClassWithInheritedStaticConstructor :: class , 'foo' );","title":"Use custom object constructors"},{"location":"how-to/use-custom-object-constructors/#using-custom-object-constructors","text":"An object may have custom ways of being created, in such cases these constructors need to be registered to the mapper to be used. A constructor is a callable that can be either: A named constructor, also known as a static factory method The method of a service \u2014 for instance a repository A \"callable object\" \u2014 a class that declares an __invoke method Any other callable \u2014 including anonymous functions In any case, the return type of the callable will be resolved by the mapper to know when to use it. Any argument can be provided and will automatically be mapped using the given source. These arguments can then be used to instantiate the object in the desired way. Registering any constructor will disable the native constructor \u2014 the __construct method \u2014 of the targeted class. If for some reason it still needs to be handled as well, the name of the class must be given to the registration method. If several constructors are registered, they must provide distinct signatures to prevent collision during mapping \u2014 meaning that if two constructors require several arguments with the exact same names, the mapping will fail. ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> registerConstructor ( // Allow the native constructor to be used Color :: class , // Register a named constructor (1) Color :: fromHex ( ... ), /** * An anonymous function can also be used, for instance when the desired * object is an external dependency that cannot be modified. * * @param 'red'|'green'|'blue' $color * @param 'dark'|'light' $darkness */ function ( string $color , string $darkness ) : Color { $main = $darkness === 'dark' ? 128 : 255 ; $other = $darkness === 'dark' ? 0 : 128 ; return new Color ( $color === 'red' ? $main : $other , $color === 'green' ? $main : $other , $color === 'blue' ? $main : $other , ); } ) -> mapper () -> map ( Color :: class , [ /* \u2026 */ ]); final class Color { /** * @param int<0, 255> $red * @param int<0, 255> $green * @param int<0, 255> $blue */ public function __construct ( public readonly int $red , public readonly int $green , public readonly int $blue ) {} /** * @param non-empty-string $hex */ public static function fromHex ( string $hex ) : self { if ( strlen ( $hex ) !== 6 ) { throw new DomainException ( 'Must be 6 characters long' ); } /** @var int<0, 255> $red */ $red = hexdec ( substr ( $hex , 0 , 2 )); /** @var int<0, 255> $green */ $green = hexdec ( substr ( $hex , 2 , 2 )); /** @var int<0, 255> $blue */ $blue = hexdec ( substr ( $hex , 4 , 2 )); return new self ( $red , $green , $blue ); } } \u2026or for PHP < 8.1: [ Color :: class , 'fromHex' ],","title":"Using custom object constructors"},{"location":"how-to/use-custom-object-constructors/#dynamic-constructors","text":"In some situations the type handled by a constructor is only known at runtime, in which case the constructor needs to know what class must be used to instantiate the object. For instance, an interface may declare a static constructor that is then implemented by several child classes. One solution would be to register the constructor for each child class, which leads to a lot of boilerplate code and would require a new registration each time a new child is created. Another way is to use the attribute \\CuyZ\\Valinor\\Mapper\\Object\\DynamicConstructor . When a constructor uses this attribute, its first parameter must be a string and will be filled with the name of the actual class that the mapper needs to build when the constructor is called. Other arguments may be added and will be mapped normally, depending on the source given to the mapper. interface InterfaceWithStaticConstructor { public static function from ( string $value ) : self ; } final class ClassWithInheritedStaticConstructor implements InterfaceWithStaticConstructor { private function __construct ( private SomeValueObject $value ) {} public static function from ( string $value ) : self { return new self ( new SomeValueObject ( $value )); } } ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> registerConstructor ( #[\\CuyZ\\Valinor\\Attribute\\DynamicConstructor] function ( string $className , string $value ) : InterfaceWithStaticConstructor { return $className :: from ( $value ); } ) -> mapper () -> map ( ClassWithInheritedStaticConstructor :: class , 'foo' );","title":"Dynamic constructors"},{"location":"other/performance-and-caching/","text":"Performance & caching \u00b6 This library needs to parse a lot of information in order to handle all provided features. Therefore, it is strongly advised to activate the cache to reduce heavy workload between runtimes, especially when the application runs in a production environment. The library provides a cache implementation out of the box, which saves cache entries into the file system. Note It is also possible to use any PSR-16 compliant implementation, as long as it is capable of caching the entries handled by the library. When the application runs in a development environment, the cache implementation should be decorated with FileWatchingCache , which will watch the files of the application and invalidate cache entries when a PHP file is modified by a developer \u2014 preventing the library not behaving as expected when the signature of a property or a method changes. $cache = new \\CuyZ\\Valinor\\Cache\\FileSystemCache ( 'path/to/cache-directory' ); if ( $isApplicationInDevelopmentEnvironment ) { $cache = new \\CuyZ\\Valinor\\Cache\\FileWatchingCache ( $cache ); } ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> withCache ( $cache ) -> mapper () -> map ( SomeClass :: class , [ /* \u2026 */ ]); Warming up cache \u00b6 The cache can be warmed up, for instance in a pipeline during the build and deployment of the application. Note The cache has to be registered first, otherwise the warmup will end up being useless. $cache = new \\CuyZ\\Valinor\\Cache\\FileSystemCache ( 'path/to/cache-dir' ); $mapperBuilder = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> withCache ( $cache ); // During the build: $mapperBuilder -> warmup ( SomeClass :: class , SomeOtherClass :: class ); // In the application: $mapper -> mapper () -> map ( SomeClass :: class , [ /* \u2026 */ ]);","title":"Performance & caching"},{"location":"other/performance-and-caching/#performance-caching","text":"This library needs to parse a lot of information in order to handle all provided features. Therefore, it is strongly advised to activate the cache to reduce heavy workload between runtimes, especially when the application runs in a production environment. The library provides a cache implementation out of the box, which saves cache entries into the file system. Note It is also possible to use any PSR-16 compliant implementation, as long as it is capable of caching the entries handled by the library. When the application runs in a development environment, the cache implementation should be decorated with FileWatchingCache , which will watch the files of the application and invalidate cache entries when a PHP file is modified by a developer \u2014 preventing the library not behaving as expected when the signature of a property or a method changes. $cache = new \\CuyZ\\Valinor\\Cache\\FileSystemCache ( 'path/to/cache-directory' ); if ( $isApplicationInDevelopmentEnvironment ) { $cache = new \\CuyZ\\Valinor\\Cache\\FileWatchingCache ( $cache ); } ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> withCache ( $cache ) -> mapper () -> map ( SomeClass :: class , [ /* \u2026 */ ]);","title":"Performance &amp; caching"},{"location":"other/performance-and-caching/#warming-up-cache","text":"The cache can be warmed up, for instance in a pipeline during the build and deployment of the application. Note The cache has to be registered first, otherwise the warmup will end up being useless. $cache = new \\CuyZ\\Valinor\\Cache\\FileSystemCache ( 'path/to/cache-dir' ); $mapperBuilder = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> withCache ( $cache ); // During the build: $mapperBuilder -> warmup ( SomeClass :: class , SomeOtherClass :: class ); // In the application: $mapper -> mapper () -> map ( SomeClass :: class , [ /* \u2026 */ ]);","title":"Warming up cache"},{"location":"other/static-analysis/","text":"Static analysis \u00b6 To help static analysis of a codebase using this library, an extension for PHPStan and a plugin for Psalm are provided. They enable these tools to better understand the behaviour of the mapper. Note To activate this feature, the plugin must be registered correcly: PHPStan Psalm phpstan.neon includes : - vendor/cuyz/valinor/qa/PHPStan/valinor-phpstan-configuration.php psalm.xml <plugins> <pluginClass class= \"CuyZ\\Valinor\\QA\\Psalm\\ValinorPsalmPlugin\" /> </plugins> Considering at least one of those tools are installed on a project, below are examples of the kind of errors that would be reported. Mapping to an array of classes final class SomeClass { public function __construct ( public readonly string $foo , public readonly int $bar , ) {} } $objects = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( 'array<' . SomeClass :: class . '>' , [ /* \u2026 */ ] ); foreach ( $objects as $object ) { // \u2705 echo $object -> foo ; // \u2705 echo $object -> bar * 2 ; // \u274c Cannot perform operation between `string` and `int` echo $object -> foo * $object -> bar ; // \u274c Property `SomeClass::$fiz` is not defined echo $object -> fiz ; } Mapping to a shaped array $array = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( 'array{foo: string, bar: int}' , [ /* \u2026 */ ] ); // \u2705 echo $array [ 'foo' ]; // \u274c Expected `string` but got `int` echo strtolower ( $array [ 'bar' ]); // \u274c Cannot perform operation between `string` and `int` echo $array [ 'foo' ] * $array [ 'bar' ]; // \u274c Offset `fiz` does not exist on array echo $array [ 'fiz' ]; Mapping arguments of a callable $someFunction = function ( string $foo , int $bar ) : string { return \" $foo / $bar \" ; }; $arguments = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> argumentsMapper () -> mapArguments ( $someFunction , [ 'foo' => 'some value' , 'bar' => 42 , ]); // \u2705 Arguments have a correct shape, no error reported echo $someFunction ( ... $arguments );","title":"Static analysis \u2014 PHPStan/Psalm"},{"location":"other/static-analysis/#static-analysis","text":"To help static analysis of a codebase using this library, an extension for PHPStan and a plugin for Psalm are provided. They enable these tools to better understand the behaviour of the mapper. Note To activate this feature, the plugin must be registered correcly: PHPStan Psalm phpstan.neon includes : - vendor/cuyz/valinor/qa/PHPStan/valinor-phpstan-configuration.php psalm.xml <plugins> <pluginClass class= \"CuyZ\\Valinor\\QA\\Psalm\\ValinorPsalmPlugin\" /> </plugins> Considering at least one of those tools are installed on a project, below are examples of the kind of errors that would be reported. Mapping to an array of classes final class SomeClass { public function __construct ( public readonly string $foo , public readonly int $bar , ) {} } $objects = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( 'array<' . SomeClass :: class . '>' , [ /* \u2026 */ ] ); foreach ( $objects as $object ) { // \u2705 echo $object -> foo ; // \u2705 echo $object -> bar * 2 ; // \u274c Cannot perform operation between `string` and `int` echo $object -> foo * $object -> bar ; // \u274c Property `SomeClass::$fiz` is not defined echo $object -> fiz ; } Mapping to a shaped array $array = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( 'array{foo: string, bar: int}' , [ /* \u2026 */ ] ); // \u2705 echo $array [ 'foo' ]; // \u274c Expected `string` but got `int` echo strtolower ( $array [ 'bar' ]); // \u274c Cannot perform operation between `string` and `int` echo $array [ 'foo' ] * $array [ 'bar' ]; // \u274c Offset `fiz` does not exist on array echo $array [ 'fiz' ]; Mapping arguments of a callable $someFunction = function ( string $foo , int $bar ) : string { return \" $foo / $bar \" ; }; $arguments = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> argumentsMapper () -> mapArguments ( $someFunction , [ 'foo' => 'some value' , 'bar' => 42 , ]); // \u2705 Arguments have a correct shape, no error reported echo $someFunction ( ... $arguments );","title":"Static analysis"},{"location":"project/changelog/","text":"Changelog \u00b6 Below are listed the changelogs for all released version of the library. Version 1.0 \u00b6 1.0.0 \u2014 28th of November 2022 Development phase \u00b6 0.17.0 \u2014 8th of November 2022 0.16.0 \u2014 19th of October 2022 0.15.0 \u2014 6th of October 2022 0.14.0 \u2014 1st of September 2022 0.13.0 \u2014 31st of July 2022 0.12.0 \u2014 10th of July 2022 0.11.0 \u2014 23rd of June 2022 0.10.0 \u2014 10th of June 2022 0.9.0 \u2014 23rd of May 2022 0.8.0 \u2014 9th of May 2022 0.7.0 \u2014 24th of March 2022 0.6.0 \u2014 24th of February 2022 0.5.0 \u2014 21st of January 2022 0.4.0 \u2014 7th of January 2022 0.3.0 \u2014 18th of December 2021 0.2.0 \u2014 7th of December 2021 0.1.1 \u2014 1st of December 2021","title":"Changelog"},{"location":"project/changelog/#changelog","text":"Below are listed the changelogs for all released version of the library.","title":"Changelog"},{"location":"project/changelog/#version-10","text":"1.0.0 \u2014 28th of November 2022","title":"Version 1.0"},{"location":"project/changelog/#development-phase","text":"0.17.0 \u2014 8th of November 2022 0.16.0 \u2014 19th of October 2022 0.15.0 \u2014 6th of October 2022 0.14.0 \u2014 1st of September 2022 0.13.0 \u2014 31st of July 2022 0.12.0 \u2014 10th of July 2022 0.11.0 \u2014 23rd of June 2022 0.10.0 \u2014 10th of June 2022 0.9.0 \u2014 23rd of May 2022 0.8.0 \u2014 9th of May 2022 0.7.0 \u2014 24th of March 2022 0.6.0 \u2014 24th of February 2022 0.5.0 \u2014 21st of January 2022 0.4.0 \u2014 7th of January 2022 0.3.0 \u2014 18th of December 2021 0.2.0 \u2014 7th of December 2021 0.1.1 \u2014 1st of December 2021","title":"Development phase"},{"location":"project/credits/","text":"Credits & thank you \u00b6 The development of this library is mainly motivated by the kind words and the help of many people. I am grateful to everyone, especially to the contributors of this repository who directly help to push the project forward. I also want to thank Blackfire for providing a license of their awesome tool, leading to notable performance gains when using this library.","title":"Credits"},{"location":"project/credits/#credits-thank-you","text":"The development of this library is mainly motivated by the kind words and the help of many people. I am grateful to everyone, especially to the contributors of this repository who directly help to push the project forward. I also want to thank Blackfire for providing a license of their awesome tool, leading to notable performance gains when using this library.","title":"Credits &amp; thank you"},{"location":"project/changelog/version-0.1.1/","text":"Changelog 0.1.1 \u2014 1st of December 2021 \u00b6 See release on GitHub \u26a0 BREAKING CHANGES \u00b6 Change license from GPL 3 to MIT ( a77b28 ) Features \u00b6 Handle multiline type declaration ( d99c59 ) Bug Fixes \u00b6 Filter type symbols with strict string comparison ( 6cdea3 ) Handle correctly iterable source during mapping ( dd4624 ) Handle shaped array integer key ( 5561d0 ) Resolve single/double quotes when parsing doc-block type ( 1c628b ) Other \u00b6 Change PHPStan stub file extension ( 8fc6af ) Delete unwanted code ( e3e169 ) Syntax highlight stub files (#9) ( 9ea95f ) Use composer runtime API ( 1f754a )","title":"Changelog 0.1.1 \u2014 1st of December 2021"},{"location":"project/changelog/version-0.1.1/#changelog-011-1st-of-december-2021","text":"See release on GitHub","title":"Changelog 0.1.1 \u2014 1st of December 2021"},{"location":"project/changelog/version-0.1.1/#breaking-changes","text":"Change license from GPL 3 to MIT ( a77b28 )","title":"\u26a0 BREAKING CHANGES"},{"location":"project/changelog/version-0.1.1/#features","text":"Handle multiline type declaration ( d99c59 )","title":"Features"},{"location":"project/changelog/version-0.1.1/#bug-fixes","text":"Filter type symbols with strict string comparison ( 6cdea3 ) Handle correctly iterable source during mapping ( dd4624 ) Handle shaped array integer key ( 5561d0 ) Resolve single/double quotes when parsing doc-block type ( 1c628b )","title":"Bug Fixes"},{"location":"project/changelog/version-0.1.1/#other","text":"Change PHPStan stub file extension ( 8fc6af ) Delete unwanted code ( e3e169 ) Syntax highlight stub files (#9) ( 9ea95f ) Use composer runtime API ( 1f754a )","title":"Other"},{"location":"project/changelog/version-0.10.0/","text":"Changelog 0.10.0 \u2014 10th of June 2022 \u00b6 See release on GitHub Notable changes \u00b6 Documentation is now available at valinor.cuyz.io . Features \u00b6 Support mapping to dates with no time ( e0a529 ) Bug Fixes \u00b6 Allow declaring promoted parameter type with @var annotation ( d8eb4d ) Allow mapping iterable to shaped array ( 628baf )","title":"Changelog 0.10.0 \u2014 10th of June 2022"},{"location":"project/changelog/version-0.10.0/#changelog-0100-10th-of-june-2022","text":"See release on GitHub","title":"Changelog 0.10.0 \u2014 10th of June 2022"},{"location":"project/changelog/version-0.10.0/#notable-changes","text":"Documentation is now available at valinor.cuyz.io .","title":"Notable changes"},{"location":"project/changelog/version-0.10.0/#features","text":"Support mapping to dates with no time ( e0a529 )","title":"Features"},{"location":"project/changelog/version-0.10.0/#bug-fixes","text":"Allow declaring promoted parameter type with @var annotation ( d8eb4d ) Allow mapping iterable to shaped array ( 628baf )","title":"Bug Fixes"},{"location":"project/changelog/version-0.11.0/","text":"Changelog 0.11.0 \u2014 23rd of June 2022 \u00b6 See release on GitHub Notable changes \u00b6 Strict mode The mapper is now more type-sensitive and will fail in the following situations: When a value does not match exactly the awaited scalar type, for instance a string \"42\" given to a node that awaits an integer. When unnecessary array keys are present, for instance mapping an array ['foo' => \u2026, 'bar' => \u2026, 'baz' => \u2026] to an object that needs only foo and bar . When permissive types like mixed or object are encountered. These limitations can be bypassed by enabling the flexible mode: ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> flexible () -> mapper (); -> map ( 'array{foo: int, bar: bool}' , [ 'foo' => '42' , // Will be cast from `string` to `int` 'bar' => 'true' , // Will be cast from `string` to `bool` 'baz' => '\u2026' , // Will be ignored ]); When using this library for a provider application \u2014 for instance an API endpoint that can be called with a JSON payload \u2014 it is recommended to use the strict mode. This ensures that the consumers of the API provide the exact awaited data structure, and prevents unknown values to be passed. When using this library as a consumer of an external source, it can make sense to enable the flexible mode. This allows for instance to convert string numeric values to integers or to ignore data that is present in the source but not needed in the application. Interface inferring It is now mandatory to list all possible class-types that can be inferred by the mapper. This change is a step towards the library being able to deliver powerful new features such as compiling a mapper for better performance. The existing calls to MapperBuilder::infer that could return several class-names must now add a signature to the callback. The callbacks that require no parameter and always return the same class-name can remain unchanged. For instance: $builder = ( new \\CuyZ\\Valinor\\MapperBuilder ()) // Can remain unchanged -> infer ( SomeInterface :: class , fn () => SomeImplementation :: class ); $builder = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> infer ( SomeInterface :: class , fn ( string $type ) => match ( $type ) { 'first' => ImplementationA :: class , 'second' => ImplementationB :: class , default => throw new DomainException ( \"Unhandled ` $type `.\" ) } ) // \u2026should be modified with: -> infer ( SomeInterface :: class , /** @return class-string<ImplementationA|ImplementationB> */ fn ( string $type ) => match ( $type ) { 'first' => ImplementationA :: class , 'second' => ImplementationB :: class , default => throw new DomainException ( \"Unhandled ` $type `.\" ) } ); Object constructors collision All these changes led to a new check that runs on all registered object constructors. If a collision is found between several constructors that have the same signature (the same parameter names), an exception will be thrown. final class SomeClass { public static function constructorA ( string $foo , string $bar ) : self { // \u2026 } public static function constructorB ( string $foo , string $bar ) : self { // \u2026 } } ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> registerConstructor ( SomeClass :: constructorA ( ... ), SomeClass :: constructorB ( ... ), ) -> mapper (); -> map ( SomeClass :: class , [ 'foo' => 'foo' , 'bar' => 'bar' , ]); // Exception: A collision was detected [\u2026] \u26a0 BREAKING CHANGES \u00b6 Handle exhaustive list of interface inferring ( 1b0ff3 ) Make mapper more strict and allow flexible mode ( 90dc58 ) Features \u00b6 Improve cache warmup ( 44c5f1 )","title":"Changelog 0.11.0 \u2014 23rd of June 2022"},{"location":"project/changelog/version-0.11.0/#changelog-0110-23rd-of-june-2022","text":"See release on GitHub","title":"Changelog 0.11.0 \u2014 23rd of June 2022"},{"location":"project/changelog/version-0.11.0/#notable-changes","text":"Strict mode The mapper is now more type-sensitive and will fail in the following situations: When a value does not match exactly the awaited scalar type, for instance a string \"42\" given to a node that awaits an integer. When unnecessary array keys are present, for instance mapping an array ['foo' => \u2026, 'bar' => \u2026, 'baz' => \u2026] to an object that needs only foo and bar . When permissive types like mixed or object are encountered. These limitations can be bypassed by enabling the flexible mode: ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> flexible () -> mapper (); -> map ( 'array{foo: int, bar: bool}' , [ 'foo' => '42' , // Will be cast from `string` to `int` 'bar' => 'true' , // Will be cast from `string` to `bool` 'baz' => '\u2026' , // Will be ignored ]); When using this library for a provider application \u2014 for instance an API endpoint that can be called with a JSON payload \u2014 it is recommended to use the strict mode. This ensures that the consumers of the API provide the exact awaited data structure, and prevents unknown values to be passed. When using this library as a consumer of an external source, it can make sense to enable the flexible mode. This allows for instance to convert string numeric values to integers or to ignore data that is present in the source but not needed in the application. Interface inferring It is now mandatory to list all possible class-types that can be inferred by the mapper. This change is a step towards the library being able to deliver powerful new features such as compiling a mapper for better performance. The existing calls to MapperBuilder::infer that could return several class-names must now add a signature to the callback. The callbacks that require no parameter and always return the same class-name can remain unchanged. For instance: $builder = ( new \\CuyZ\\Valinor\\MapperBuilder ()) // Can remain unchanged -> infer ( SomeInterface :: class , fn () => SomeImplementation :: class ); $builder = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> infer ( SomeInterface :: class , fn ( string $type ) => match ( $type ) { 'first' => ImplementationA :: class , 'second' => ImplementationB :: class , default => throw new DomainException ( \"Unhandled ` $type `.\" ) } ) // \u2026should be modified with: -> infer ( SomeInterface :: class , /** @return class-string<ImplementationA|ImplementationB> */ fn ( string $type ) => match ( $type ) { 'first' => ImplementationA :: class , 'second' => ImplementationB :: class , default => throw new DomainException ( \"Unhandled ` $type `.\" ) } ); Object constructors collision All these changes led to a new check that runs on all registered object constructors. If a collision is found between several constructors that have the same signature (the same parameter names), an exception will be thrown. final class SomeClass { public static function constructorA ( string $foo , string $bar ) : self { // \u2026 } public static function constructorB ( string $foo , string $bar ) : self { // \u2026 } } ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> registerConstructor ( SomeClass :: constructorA ( ... ), SomeClass :: constructorB ( ... ), ) -> mapper (); -> map ( SomeClass :: class , [ 'foo' => 'foo' , 'bar' => 'bar' , ]); // Exception: A collision was detected [\u2026]","title":"Notable changes"},{"location":"project/changelog/version-0.11.0/#breaking-changes","text":"Handle exhaustive list of interface inferring ( 1b0ff3 ) Make mapper more strict and allow flexible mode ( 90dc58 )","title":"\u26a0 BREAKING CHANGES"},{"location":"project/changelog/version-0.11.0/#features","text":"Improve cache warmup ( 44c5f1 )","title":"Features"},{"location":"project/changelog/version-0.12.0/","text":"Changelog 0.12.0 \u2014 10th of July 2022 \u00b6 See release on GitHub Notable changes \u00b6 SECURITY \u2014 Userland exception filtering See advisory GHSA-5pgm-3j3g-2rc7 for more information. Userland exception thrown in a constructor will not be automatically caught by the mapper anymore. This prevents messages with sensible information from reaching the final user \u2014 for instance an SQL exception showing a part of a query. To allow exceptions to be considered as safe, the new method MapperBuilder::filterExceptions() must be used, with caution. final class SomeClass { public function __construct ( private string $value ) { \\Webmozart\\Assert\\Assert :: startsWith ( $value , 'foo_' ); } } try { ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> filterExceptions ( function ( Throwable $exception ) { if ( $exception instanceof \\Webmozart\\Assert\\InvalidArgumentException ) { return \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\ThrowableMessage :: from ( $exception ); } // If the exception should not be caught by this library, it // must be thrown again. throw $exception ; }) -> mapper () -> map ( SomeClass :: class , 'bar_baz' ); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $exception ) { // Should print something similar to: // > Expected a value to start with \"foo_\". Got: \"bar_baz\" echo $exception -> node () -> messages ()[ 0 ]; } Tree node API rework The class \\CuyZ\\Valinor\\Mapper\\Tree\\Node has been refactored to remove access to unwanted methods that were not supposed to be part of the public API. Below are a list of all changes: New methods $node->sourceFilled() and $node->sourceValue() allow accessing the source value. The method $node->value() has been renamed to $node->mappedValue() and will throw an exception if the node is not valid. The method $node->type() now returns a string. The methods $message->name() , $message->path() , $message->type() and $message->value() have been deprecated in favor of the new method $message->node() . The message parameter {original_value} has been deprecated in favor of {source_value} . Access removal of several parts of the library public API The access to class/function definition, types and exceptions did not add value to the actual goal of the library. Keeping these features under the public API flag causes more maintenance burden whereas revoking their access allows more flexibility with the overall development of the library. \u26a0 BREAKING CHANGES \u00b6 Filter userland exceptions to hide potential sensible data ( 6ce1a4 ) Refactor tree node API ( d3b1dc ) Remove API access from several parts of library ( 316d91 ) Remove node visitor feature ( 63c87a ) Bug Fixes \u00b6 Handle inferring methods with same names properly ( dc45dd ) Process invalid type default value as unresolvable type ( 7c9ac1 ) Properly display unresolvable type ( 3020db ) Other \u00b6 Ignore .idea folder ( 84ead0 )","title":"Changelog 0.12.0 \u2014 10th of July 2022"},{"location":"project/changelog/version-0.12.0/#changelog-0120-10th-of-july-2022","text":"See release on GitHub","title":"Changelog 0.12.0 \u2014 10th of July 2022"},{"location":"project/changelog/version-0.12.0/#notable-changes","text":"SECURITY \u2014 Userland exception filtering See advisory GHSA-5pgm-3j3g-2rc7 for more information. Userland exception thrown in a constructor will not be automatically caught by the mapper anymore. This prevents messages with sensible information from reaching the final user \u2014 for instance an SQL exception showing a part of a query. To allow exceptions to be considered as safe, the new method MapperBuilder::filterExceptions() must be used, with caution. final class SomeClass { public function __construct ( private string $value ) { \\Webmozart\\Assert\\Assert :: startsWith ( $value , 'foo_' ); } } try { ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> filterExceptions ( function ( Throwable $exception ) { if ( $exception instanceof \\Webmozart\\Assert\\InvalidArgumentException ) { return \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\ThrowableMessage :: from ( $exception ); } // If the exception should not be caught by this library, it // must be thrown again. throw $exception ; }) -> mapper () -> map ( SomeClass :: class , 'bar_baz' ); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $exception ) { // Should print something similar to: // > Expected a value to start with \"foo_\". Got: \"bar_baz\" echo $exception -> node () -> messages ()[ 0 ]; } Tree node API rework The class \\CuyZ\\Valinor\\Mapper\\Tree\\Node has been refactored to remove access to unwanted methods that were not supposed to be part of the public API. Below are a list of all changes: New methods $node->sourceFilled() and $node->sourceValue() allow accessing the source value. The method $node->value() has been renamed to $node->mappedValue() and will throw an exception if the node is not valid. The method $node->type() now returns a string. The methods $message->name() , $message->path() , $message->type() and $message->value() have been deprecated in favor of the new method $message->node() . The message parameter {original_value} has been deprecated in favor of {source_value} . Access removal of several parts of the library public API The access to class/function definition, types and exceptions did not add value to the actual goal of the library. Keeping these features under the public API flag causes more maintenance burden whereas revoking their access allows more flexibility with the overall development of the library.","title":"Notable changes"},{"location":"project/changelog/version-0.12.0/#breaking-changes","text":"Filter userland exceptions to hide potential sensible data ( 6ce1a4 ) Refactor tree node API ( d3b1dc ) Remove API access from several parts of library ( 316d91 ) Remove node visitor feature ( 63c87a )","title":"\u26a0 BREAKING CHANGES"},{"location":"project/changelog/version-0.12.0/#bug-fixes","text":"Handle inferring methods with same names properly ( dc45dd ) Process invalid type default value as unresolvable type ( 7c9ac1 ) Properly display unresolvable type ( 3020db )","title":"Bug Fixes"},{"location":"project/changelog/version-0.12.0/#other","text":"Ignore .idea folder ( 84ead0 )","title":"Other"},{"location":"project/changelog/version-0.13.0/","text":"Changelog 0.13.0 \u2014 31st of July 2022 \u00b6 See release on GitHub Notable changes \u00b6 Reworking of messages body and parameters features The \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Message interface is no longer a Stringable , however it defines a new method body that must return the body of the message, which can contain placeholders that will be replaced by parameters. These parameters can now be defined by implementing the interface \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\HasParameters . This leads to the deprecation of the no longer needed interface \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\TranslatableMessage which had a confusing name. final class SomeException extends DomainException implements ErrorMessage , HasParameters , HasCode { private string $someParameter ; public function __construct ( string $someParameter ) { parent :: __construct (); $this -> someParameter = $someParameter ; } public function body () : string { return 'Some message / {some_parameter} / {source_value}' ; } public function parameters () : array { return [ 'some_parameter' => $this -> someParameter , ]; } public function code () : string { // A unique code that can help to identify the error return 'some_unique_code' ; } } Handle numeric-string type The new numeric-string type can be used in docblocks. It will accept any string value that is also numeric. ( new MapperBuilder ()) -> mapper () -> map ( 'numeric-string' , '42' ); // \u2705 ( new MapperBuilder ()) -> mapper () -> map ( 'numeric-string' , 'foo' ); // \u274c Better mapping error message The message of the exception will now contain more information, especially the total number of errors and the source that was given to the mapper. This change aims to have a better understanding of what is wrong when debugging. Before: Could not map type `array{foo: string, bar: int}` with the given source. After: Could not map type `array{foo: string, bar: int}`. An error occurred at path bar: Value 'some other string' does not match type `int`. \u26a0 BREAKING CHANGES \u00b6 Rework messages body and parameters features ( ad1207 ) Features \u00b6 Allow to declare parameter for message ( f61eb5 ) Display more information in mapping error message ( 9c1e7c ) Handle numeric string type ( 96a493 ) Make MessagesFlattener countable ( 2c1c7c ) Bug Fixes \u00b6 Handle native attribute on promoted parameter ( 897ca9 ) Other \u00b6 Add fixed value for root node path ( 0b37b4 ) Remove types stringable behavior ( b47a1b )","title":"Changelog 0.13.0 \u2014 31st of July 2022"},{"location":"project/changelog/version-0.13.0/#changelog-0130-31st-of-july-2022","text":"See release on GitHub","title":"Changelog 0.13.0 \u2014 31st of July 2022"},{"location":"project/changelog/version-0.13.0/#notable-changes","text":"Reworking of messages body and parameters features The \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Message interface is no longer a Stringable , however it defines a new method body that must return the body of the message, which can contain placeholders that will be replaced by parameters. These parameters can now be defined by implementing the interface \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\HasParameters . This leads to the deprecation of the no longer needed interface \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\TranslatableMessage which had a confusing name. final class SomeException extends DomainException implements ErrorMessage , HasParameters , HasCode { private string $someParameter ; public function __construct ( string $someParameter ) { parent :: __construct (); $this -> someParameter = $someParameter ; } public function body () : string { return 'Some message / {some_parameter} / {source_value}' ; } public function parameters () : array { return [ 'some_parameter' => $this -> someParameter , ]; } public function code () : string { // A unique code that can help to identify the error return 'some_unique_code' ; } } Handle numeric-string type The new numeric-string type can be used in docblocks. It will accept any string value that is also numeric. ( new MapperBuilder ()) -> mapper () -> map ( 'numeric-string' , '42' ); // \u2705 ( new MapperBuilder ()) -> mapper () -> map ( 'numeric-string' , 'foo' ); // \u274c Better mapping error message The message of the exception will now contain more information, especially the total number of errors and the source that was given to the mapper. This change aims to have a better understanding of what is wrong when debugging. Before: Could not map type `array{foo: string, bar: int}` with the given source. After: Could not map type `array{foo: string, bar: int}`. An error occurred at path bar: Value 'some other string' does not match type `int`.","title":"Notable changes"},{"location":"project/changelog/version-0.13.0/#breaking-changes","text":"Rework messages body and parameters features ( ad1207 )","title":"\u26a0 BREAKING CHANGES"},{"location":"project/changelog/version-0.13.0/#features","text":"Allow to declare parameter for message ( f61eb5 ) Display more information in mapping error message ( 9c1e7c ) Handle numeric string type ( 96a493 ) Make MessagesFlattener countable ( 2c1c7c )","title":"Features"},{"location":"project/changelog/version-0.13.0/#bug-fixes","text":"Handle native attribute on promoted parameter ( 897ca9 )","title":"Bug Fixes"},{"location":"project/changelog/version-0.13.0/#other","text":"Add fixed value for root node path ( 0b37b4 ) Remove types stringable behavior ( b47a1b )","title":"Other"},{"location":"project/changelog/version-0.14.0/","text":"Changelog 0.14.0 \u2014 1st of September 2022 \u00b6 See release on GitHub Notable changes \u00b6 Until this release, the behaviour of the date objects creation was very opinionated: a huge list of date formats were tested out, and if one was working it was used to create the date. This approach resulted in two problems. First, it led to (minor) performance issues, because a lot of date formats were potentially tested for nothing. More importantly, it was not possible to define which format(s) were to be allowed (and in result deny other formats). A new method can now be used in the MapperBuilder : ( new \\CuyZ\\Valinor\\MapperBuilder ()) // Both `Cookie` and `ATOM` formats will be accepted -> supportDateFormats ( DATE_COOKIE , DATE_ATOM ) -> mapper () -> map ( DateTimeInterface :: class , 'Monday, 08-Nov-1971 13:37:42 UTC' ); Please note that the old behaviour has been removed. From now on, only valid timestamp or ATOM-formatted value will be accepted by default. If needed and to help with the migration, the following deprecated constructor can be registered to reactivate the previous behaviour: ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> registerConstructor ( new \\CuyZ\\Valinor\\Mapper\\Object\\BackwardCompatibilityDateTimeConstructor () ) -> mapper () -> map ( DateTimeInterface :: class , 'Monday, 08-Nov-1971 13:37:42 UTC' ); \u26a0 BREAKING CHANGES \u00b6 Introduce constructor for custom date formats ( f232cc ) Features \u00b6 Handle abstract constructor registration ( c37ac1 ) Introduce attribute DynamicConstructor ( e437d9 ) Introduce helper method to describe supported date formats ( 11a7ea ) Bug Fixes \u00b6 Allow trailing comma in shaped array ( bf445b ) Correctly fetch file system cache entries ( 48208c ) Detect invalid constructor handle type ( b3cb59 ) Handle classes in a case-sensitive way in type parser ( 254074 ) Handle concurrent cache file creation ( fd39ae ) Handle inherited private constructor in class definition ( 73b622 ) Handle invalid nodes recursively ( a401c2 ) Prevent illegal characters in PSR-16 cache keys ( 3c4d29 ) Properly handle callable objects of the same class ( ae7ddc ) Other \u00b6 Add singleton usage of ClassStringType ( 4bc50e ) Change ObjectBuilderFactory::for return signature ( 57849c ) Extract native constructor object builder ( 2b46a6 ) Fetch attributes for function definition ( ec494c ) Refactor arguments instantiation ( 6414e9 )","title":"Changelog 0.14.0 \u2014 1st of September 2022"},{"location":"project/changelog/version-0.14.0/#changelog-0140-1st-of-september-2022","text":"See release on GitHub","title":"Changelog 0.14.0 \u2014 1st of September 2022"},{"location":"project/changelog/version-0.14.0/#notable-changes","text":"Until this release, the behaviour of the date objects creation was very opinionated: a huge list of date formats were tested out, and if one was working it was used to create the date. This approach resulted in two problems. First, it led to (minor) performance issues, because a lot of date formats were potentially tested for nothing. More importantly, it was not possible to define which format(s) were to be allowed (and in result deny other formats). A new method can now be used in the MapperBuilder : ( new \\CuyZ\\Valinor\\MapperBuilder ()) // Both `Cookie` and `ATOM` formats will be accepted -> supportDateFormats ( DATE_COOKIE , DATE_ATOM ) -> mapper () -> map ( DateTimeInterface :: class , 'Monday, 08-Nov-1971 13:37:42 UTC' ); Please note that the old behaviour has been removed. From now on, only valid timestamp or ATOM-formatted value will be accepted by default. If needed and to help with the migration, the following deprecated constructor can be registered to reactivate the previous behaviour: ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> registerConstructor ( new \\CuyZ\\Valinor\\Mapper\\Object\\BackwardCompatibilityDateTimeConstructor () ) -> mapper () -> map ( DateTimeInterface :: class , 'Monday, 08-Nov-1971 13:37:42 UTC' );","title":"Notable changes"},{"location":"project/changelog/version-0.14.0/#breaking-changes","text":"Introduce constructor for custom date formats ( f232cc )","title":"\u26a0 BREAKING CHANGES"},{"location":"project/changelog/version-0.14.0/#features","text":"Handle abstract constructor registration ( c37ac1 ) Introduce attribute DynamicConstructor ( e437d9 ) Introduce helper method to describe supported date formats ( 11a7ea )","title":"Features"},{"location":"project/changelog/version-0.14.0/#bug-fixes","text":"Allow trailing comma in shaped array ( bf445b ) Correctly fetch file system cache entries ( 48208c ) Detect invalid constructor handle type ( b3cb59 ) Handle classes in a case-sensitive way in type parser ( 254074 ) Handle concurrent cache file creation ( fd39ae ) Handle inherited private constructor in class definition ( 73b622 ) Handle invalid nodes recursively ( a401c2 ) Prevent illegal characters in PSR-16 cache keys ( 3c4d29 ) Properly handle callable objects of the same class ( ae7ddc )","title":"Bug Fixes"},{"location":"project/changelog/version-0.14.0/#other","text":"Add singleton usage of ClassStringType ( 4bc50e ) Change ObjectBuilderFactory::for return signature ( 57849c ) Extract native constructor object builder ( 2b46a6 ) Fetch attributes for function definition ( ec494c ) Refactor arguments instantiation ( 6414e9 )","title":"Other"},{"location":"project/changelog/version-0.15.0/","text":"Changelog 0.15.0 \u2014 6th of October 2022 \u00b6 See release on GitHub Notable changes \u00b6 Two similar features are introduced in this release: constants and enums wildcard notations. This is mainly useful when several cases of an enum or class constants share a common prefix. Example for class constants: final class SomeClassWithConstants { public const FOO = 1337 ; public const BAR = 'bar' ; public const BAZ = 'baz' ; } $mapper = ( new MapperBuilder ()) -> mapper (); $mapper -> map ( 'SomeClassWithConstants::BA*' , 1337 ); // error $mapper -> map ( 'SomeClassWithConstants::BA*' , 'bar' ); // ok $mapper -> map ( 'SomeClassWithConstants::BA*' , 'baz' ); // ok Example for enum: enum SomeEnum : string { case FOO = 'foo' ; case BAR = 'bar' ; case BAZ = 'baz' ; } $mapper = ( new MapperBuilder ()) -> mapper (); $mapper -> map ( 'SomeEnum::BA*' , 'foo' ); // error $mapper -> map ( 'SomeEnum::BA*' , 'bar' ); // ok $mapper -> map ( 'SomeEnum::BA*' , 'baz' ); // ok Features \u00b6 Add support for class constant type ( 1244c2 ) Add support for wildcard in enumeration type ( 69ebd1 ) Introduce utility class to build messages ( cb8792 ) Bug Fixes \u00b6 Add return types for cache implementations ( 0e8f12 ) Correctly handle type inferring during mapping ( 37f96f ) Fetch correct node value for children ( 3ee526 ) Improve scalar values casting ( 212b77 ) Properly handle static anonymous functions ( c009ab ) Other \u00b6 Import namespace token parser inside library ( 0b8ca9 ) Remove unused code ( b2889a , de8aa9 ) Save type token symbols during lexing ( ad0f8f )","title":"Changelog 0.15.0 \u2014 6th of October 2022"},{"location":"project/changelog/version-0.15.0/#changelog-0150-6th-of-october-2022","text":"See release on GitHub","title":"Changelog 0.15.0 \u2014 6th of October 2022"},{"location":"project/changelog/version-0.15.0/#notable-changes","text":"Two similar features are introduced in this release: constants and enums wildcard notations. This is mainly useful when several cases of an enum or class constants share a common prefix. Example for class constants: final class SomeClassWithConstants { public const FOO = 1337 ; public const BAR = 'bar' ; public const BAZ = 'baz' ; } $mapper = ( new MapperBuilder ()) -> mapper (); $mapper -> map ( 'SomeClassWithConstants::BA*' , 1337 ); // error $mapper -> map ( 'SomeClassWithConstants::BA*' , 'bar' ); // ok $mapper -> map ( 'SomeClassWithConstants::BA*' , 'baz' ); // ok Example for enum: enum SomeEnum : string { case FOO = 'foo' ; case BAR = 'bar' ; case BAZ = 'baz' ; } $mapper = ( new MapperBuilder ()) -> mapper (); $mapper -> map ( 'SomeEnum::BA*' , 'foo' ); // error $mapper -> map ( 'SomeEnum::BA*' , 'bar' ); // ok $mapper -> map ( 'SomeEnum::BA*' , 'baz' ); // ok","title":"Notable changes"},{"location":"project/changelog/version-0.15.0/#features","text":"Add support for class constant type ( 1244c2 ) Add support for wildcard in enumeration type ( 69ebd1 ) Introduce utility class to build messages ( cb8792 )","title":"Features"},{"location":"project/changelog/version-0.15.0/#bug-fixes","text":"Add return types for cache implementations ( 0e8f12 ) Correctly handle type inferring during mapping ( 37f96f ) Fetch correct node value for children ( 3ee526 ) Improve scalar values casting ( 212b77 ) Properly handle static anonymous functions ( c009ab )","title":"Bug Fixes"},{"location":"project/changelog/version-0.15.0/#other","text":"Import namespace token parser inside library ( 0b8ca9 ) Remove unused code ( b2889a , de8aa9 ) Save type token symbols during lexing ( ad0f8f )","title":"Other"},{"location":"project/changelog/version-0.16.0/","text":"Changelog 0.16.0 \u2014 19th of October 2022 \u00b6 See release on GitHub Features \u00b6 Add support for PHP 8.2 ( a92360 ) Bug Fixes \u00b6 Properly handle quote char in type definition ( c71d6a ) Other \u00b6 Update dependencies ( c2de32 )","title":"Changelog 0.16.0 \u2014 19th of October 2022"},{"location":"project/changelog/version-0.16.0/#changelog-0160-19th-of-october-2022","text":"See release on GitHub","title":"Changelog 0.16.0 \u2014 19th of October 2022"},{"location":"project/changelog/version-0.16.0/#features","text":"Add support for PHP 8.2 ( a92360 )","title":"Features"},{"location":"project/changelog/version-0.16.0/#bug-fixes","text":"Properly handle quote char in type definition ( c71d6a )","title":"Bug Fixes"},{"location":"project/changelog/version-0.16.0/#other","text":"Update dependencies ( c2de32 )","title":"Other"},{"location":"project/changelog/version-0.17.0/","text":"Changelog 0.17.0 \u2014 8th of November 2022 \u00b6 See release on GitHub Notable changes \u00b6 The main feature introduced in this release is the split of the flexible mode in three distinct modes: The flexible casting Changes the behaviours explained below: $flexibleMapper = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> enableFlexibleCasting () -> mapper (); // --- // Scalar types will accept non-strict values; for instance an // integer type will accept any valid numeric value like the // *string* \"42\". $flexibleMapper -> map ( 'int' , '42' ); // => 42 // --- // List type will accept non-incremental keys. $flexibleMapper -> map ( 'list<int>' , [ 'foo' => 42 , 'bar' => 1337 ]); // => [0 => 42, 1 => 1338] // --- // If a value is missing in a source for a node that accepts `null`, // the node will be filled with `null`. $flexibleMapper -> map ( 'array{foo: string, bar: null|string}' , [ 'foo' => 'foo' ] // `bar` is missing ); // => ['foo' => 'foo', 'bar' => null] // --- // Array and list types will convert `null` or missing values to an // empty array. $flexibleMapper -> map ( 'array{foo: string, bar: array<string>}' , [ 'foo' => 'foo' ] // `bar` is missing ); // => ['foo' => 'foo', 'bar' => []] The superfluous keys Superfluous keys in source arrays will be allowed, preventing errors when a value is not bound to any object property/parameter or shaped array element. ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> allowSuperfluousKeys () -> mapper () -> map ( 'array{foo: string, bar: int}' , [ 'foo' => 'foo' , 'bar' => 42 , 'baz' => 1337.404 , // `baz` will be ignored ] ); The permissive types Allows permissive types mixed and object to be used during mapping. ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> allowPermissiveTypes () -> mapper () -> map ( 'array{foo: string, bar: mixed}' , [ 'foo' => 'foo' , 'bar' => 42 , // Could be any value ] ); Features \u00b6 Add support for strict-array type ( d456eb ) Introduce new callback message formatter ( 93f898 ) Introduce new helper class to list messages ( 513827 ) Split mapper flexible mode in three distinct modes ( 549e5f ) Bug Fixes \u00b6 Allow missing and null value for array node in flexible mode ( 034f1c ) Allow missing value for shaped array nullable node in flexible mode ( 08fb0e ) Handle scalar value casting in union types only in flexible mode ( 752ad9 ) Other \u00b6 Do not use uniqid() ( b81847 ) Transform missing source value to null in flexible mode ( 92a41a )","title":"Changelog 0.17.0 \u2014 8th of November 2022"},{"location":"project/changelog/version-0.17.0/#changelog-0170-8th-of-november-2022","text":"See release on GitHub","title":"Changelog 0.17.0 \u2014 8th of November 2022"},{"location":"project/changelog/version-0.17.0/#notable-changes","text":"The main feature introduced in this release is the split of the flexible mode in three distinct modes: The flexible casting Changes the behaviours explained below: $flexibleMapper = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> enableFlexibleCasting () -> mapper (); // --- // Scalar types will accept non-strict values; for instance an // integer type will accept any valid numeric value like the // *string* \"42\". $flexibleMapper -> map ( 'int' , '42' ); // => 42 // --- // List type will accept non-incremental keys. $flexibleMapper -> map ( 'list<int>' , [ 'foo' => 42 , 'bar' => 1337 ]); // => [0 => 42, 1 => 1338] // --- // If a value is missing in a source for a node that accepts `null`, // the node will be filled with `null`. $flexibleMapper -> map ( 'array{foo: string, bar: null|string}' , [ 'foo' => 'foo' ] // `bar` is missing ); // => ['foo' => 'foo', 'bar' => null] // --- // Array and list types will convert `null` or missing values to an // empty array. $flexibleMapper -> map ( 'array{foo: string, bar: array<string>}' , [ 'foo' => 'foo' ] // `bar` is missing ); // => ['foo' => 'foo', 'bar' => []] The superfluous keys Superfluous keys in source arrays will be allowed, preventing errors when a value is not bound to any object property/parameter or shaped array element. ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> allowSuperfluousKeys () -> mapper () -> map ( 'array{foo: string, bar: int}' , [ 'foo' => 'foo' , 'bar' => 42 , 'baz' => 1337.404 , // `baz` will be ignored ] ); The permissive types Allows permissive types mixed and object to be used during mapping. ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> allowPermissiveTypes () -> mapper () -> map ( 'array{foo: string, bar: mixed}' , [ 'foo' => 'foo' , 'bar' => 42 , // Could be any value ] );","title":"Notable changes"},{"location":"project/changelog/version-0.17.0/#features","text":"Add support for strict-array type ( d456eb ) Introduce new callback message formatter ( 93f898 ) Introduce new helper class to list messages ( 513827 ) Split mapper flexible mode in three distinct modes ( 549e5f )","title":"Features"},{"location":"project/changelog/version-0.17.0/#bug-fixes","text":"Allow missing and null value for array node in flexible mode ( 034f1c ) Allow missing value for shaped array nullable node in flexible mode ( 08fb0e ) Handle scalar value casting in union types only in flexible mode ( 752ad9 )","title":"Bug Fixes"},{"location":"project/changelog/version-0.17.0/#other","text":"Do not use uniqid() ( b81847 ) Transform missing source value to null in flexible mode ( 92a41a )","title":"Other"},{"location":"project/changelog/version-0.2.0/","text":"Changelog 0.2.0 \u2014 7th of December 2021 \u00b6 See release on GitHub Features \u00b6 Handle integer range type ( 9f99a2 ) Handle local type aliasing in class definition ( 56142d ) Handle type alias import in class definition ( fa3ce5 ) Bug Fixes \u00b6 Do not accept shaped array with excessive key(s) ( 5a578e ) Handle integer value match properly ( 9ee2cc ) Other \u00b6 Delete commented code ( 4f5612 ) Move exceptions to more specific folder ( 185edf ) Rename GenericAssignerLexer to TypeAliasLexer ( 680941 ) Use marcocesarato/php-conventional-changelog for changelog ( 178aa9 )","title":"Changelog 0.2.0 \u2014 7th of December 2021"},{"location":"project/changelog/version-0.2.0/#changelog-020-7th-of-december-2021","text":"See release on GitHub","title":"Changelog 0.2.0 \u2014 7th of December 2021"},{"location":"project/changelog/version-0.2.0/#features","text":"Handle integer range type ( 9f99a2 ) Handle local type aliasing in class definition ( 56142d ) Handle type alias import in class definition ( fa3ce5 )","title":"Features"},{"location":"project/changelog/version-0.2.0/#bug-fixes","text":"Do not accept shaped array with excessive key(s) ( 5a578e ) Handle integer value match properly ( 9ee2cc )","title":"Bug Fixes"},{"location":"project/changelog/version-0.2.0/#other","text":"Delete commented code ( 4f5612 ) Move exceptions to more specific folder ( 185edf ) Rename GenericAssignerLexer to TypeAliasLexer ( 680941 ) Use marcocesarato/php-conventional-changelog for changelog ( 178aa9 )","title":"Other"},{"location":"project/changelog/version-0.3.0/","text":"Changelog 0.3.0 \u2014 18th of December 2021 \u00b6 See release on GitHub Features \u00b6 Handle common database datetime formats (#40) ( 179ba3 ) Other \u00b6 Change Composer scripts calls ( 0b507c ) Raise version of friendsofphp/php-cs-fixer ( e5ccbe )","title":"Changelog 0.3.0 \u2014 18th of December 2021"},{"location":"project/changelog/version-0.3.0/#changelog-030-18th-of-december-2021","text":"See release on GitHub","title":"Changelog 0.3.0 \u2014 18th of December 2021"},{"location":"project/changelog/version-0.3.0/#features","text":"Handle common database datetime formats (#40) ( 179ba3 )","title":"Features"},{"location":"project/changelog/version-0.3.0/#other","text":"Change Composer scripts calls ( 0b507c ) Raise version of friendsofphp/php-cs-fixer ( e5ccbe )","title":"Other"},{"location":"project/changelog/version-0.4.0/","text":"Changelog 0.4.0 \u2014 7th of January 2022 \u00b6 See release on GitHub Notable changes \u00b6 Allow mapping to any type Previously, the method TreeMapper::map would allow mapping only to an object. It is now possible to map to any type handled by the library. It is for instance possible to map to an array of objects: $objects = ( new MapperBuilder ()) -> mapper () -> map ( 'array<' . SomeClass :: class . '>' , [ /* \u2026 */ ] ); For simple use-cases, an array shape can be used: $array = ( new MapperBuilder ()) -> mapper () -> map ( 'array{foo: string, bar: int}' , [ /* \u2026 */ ] ); echo $array [ 'foo' ]; echo $array [ 'bar' ] * 2 ; This new feature changes the possible behaviour of the mapper, meaning static analysis tools need help to understand the types correctly. An extension for PHPStan and a plugin for Psalm are now provided and can be included in a project to automatically increase the type coverage. Better handling of messages When working with messages, it can sometimes be useful to customize the content of a message \u2014 for instance to translate it. The helper class \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\MessageMapFormatter can be used to provide a list of new formats. It can be instantiated with an array where each key represents either: The code of the message to be replaced The content of the message to be replaced The class name of the message to be replaced If none of those is found, the content of the message will stay unchanged unless a default one is given to the class. If one of these keys is found, the array entry will be used to replace the content of the message. This entry can be either a plain text or a callable that takes the message as a parameter and returns a string; it is for instance advised to use a callable in cases where a translation service is used \u2014 to avoid useless greedy operations. In any case, the content can contain placeholders that will automatically be replaced by, in order: The original code of the message The original content of the message A string representation of the node type The name of the node The path of the node try { ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( SomeClass :: class , [ /* \u2026 */ ]); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { $node = $error -> node (); $messages = new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\MessagesFlattener ( $node ); $formatter = ( new MessageMapFormatter ([ // Will match if the given message has this exact code 'some_code' => 'new content / previous code was: %1$s' , // Will match if the given message has this exact content 'Some message content' => 'new content / previous message: %2$s' , // Will match if the given message is an instance of `SomeError` SomeError :: class => ' - Original code of the message: %1$s - Original content of the message: %2$s - Node type: %3$s - Node name: %4$s - Node path: %5$s ' , // A callback can be used to get access to the message instance OtherError :: class => function ( NodeMessage $message ) : string { if (( string ) $message -> type () === 'string|int' ) { // \u2026 } return 'Some message content' ; }, // For greedy operation, it is advised to use a lazy-callback 'bar' => fn () => $this -> translator -> translate ( 'foo.bar' ), ])) -> defaultsTo ( 'some default message' ) // \u2026or\u2026 -> defaultsTo ( fn () => $this -> translator -> translate ( 'default_message' )); foreach ( $messages as $message ) { echo $formatter -> format ( $message ); } } Automatic union of objects inferring during mapping When the mapper needs to map a source to a union of objects, it will try to guess which object it will map to, based on the needed arguments of the objects, and the values contained in the source. final class UnionOfObjects { public readonly SomeFooObject | SomeBarObject $object ; } final class SomeFooObject { public readonly string $foo ; } final class SomeBarObject { public readonly string $bar ; } // Will map to an instance of `SomeFooObject` ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( UnionOfObjects :: class , [ 'foo' => 'foo' ]); // Will map to an instance of `SomeBarObject` ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( UnionOfObjects :: class , [ 'bar' => 'bar' ]); \u26a0 BREAKING CHANGES \u00b6 Add access to root node when error occurs during mapping ( 54f608 ) Allow mapping to any type ( b2e810 ) Allow object builder to yield arguments without source ( 8a7414 ) Wrap node messages in proper class ( a805ba ) Features \u00b6 Introduce automatic union of objects inferring during mapping ( 79d7c2 ) Introduce helper class MessageMapFormatter ( ddf69e ) Introduce helper class MessagesFlattener ( a97b40 ) Introduce helper NodeTraverser for recursive operations on nodes ( cc1bc6 ) Bug Fixes \u00b6 Handle nested attributes compilation ( d2795b ) Treat forbidden mixed type as invalid type ( 36bd36 ) Treat union type resolving error as message ( e834cd ) Use locked package versions for quality assurance workflow ( 626f13 ) Other \u00b6 Ignore changelog configuration file in git export ( 85a6a4 ) Raise PHPStan version ( 0144bf )","title":"Changelog 0.4.0 \u2014 7th of January 2022"},{"location":"project/changelog/version-0.4.0/#changelog-040-7th-of-january-2022","text":"See release on GitHub","title":"Changelog 0.4.0 \u2014 7th of January 2022"},{"location":"project/changelog/version-0.4.0/#notable-changes","text":"Allow mapping to any type Previously, the method TreeMapper::map would allow mapping only to an object. It is now possible to map to any type handled by the library. It is for instance possible to map to an array of objects: $objects = ( new MapperBuilder ()) -> mapper () -> map ( 'array<' . SomeClass :: class . '>' , [ /* \u2026 */ ] ); For simple use-cases, an array shape can be used: $array = ( new MapperBuilder ()) -> mapper () -> map ( 'array{foo: string, bar: int}' , [ /* \u2026 */ ] ); echo $array [ 'foo' ]; echo $array [ 'bar' ] * 2 ; This new feature changes the possible behaviour of the mapper, meaning static analysis tools need help to understand the types correctly. An extension for PHPStan and a plugin for Psalm are now provided and can be included in a project to automatically increase the type coverage. Better handling of messages When working with messages, it can sometimes be useful to customize the content of a message \u2014 for instance to translate it. The helper class \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\MessageMapFormatter can be used to provide a list of new formats. It can be instantiated with an array where each key represents either: The code of the message to be replaced The content of the message to be replaced The class name of the message to be replaced If none of those is found, the content of the message will stay unchanged unless a default one is given to the class. If one of these keys is found, the array entry will be used to replace the content of the message. This entry can be either a plain text or a callable that takes the message as a parameter and returns a string; it is for instance advised to use a callable in cases where a translation service is used \u2014 to avoid useless greedy operations. In any case, the content can contain placeholders that will automatically be replaced by, in order: The original code of the message The original content of the message A string representation of the node type The name of the node The path of the node try { ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( SomeClass :: class , [ /* \u2026 */ ]); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { $node = $error -> node (); $messages = new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\MessagesFlattener ( $node ); $formatter = ( new MessageMapFormatter ([ // Will match if the given message has this exact code 'some_code' => 'new content / previous code was: %1$s' , // Will match if the given message has this exact content 'Some message content' => 'new content / previous message: %2$s' , // Will match if the given message is an instance of `SomeError` SomeError :: class => ' - Original code of the message: %1$s - Original content of the message: %2$s - Node type: %3$s - Node name: %4$s - Node path: %5$s ' , // A callback can be used to get access to the message instance OtherError :: class => function ( NodeMessage $message ) : string { if (( string ) $message -> type () === 'string|int' ) { // \u2026 } return 'Some message content' ; }, // For greedy operation, it is advised to use a lazy-callback 'bar' => fn () => $this -> translator -> translate ( 'foo.bar' ), ])) -> defaultsTo ( 'some default message' ) // \u2026or\u2026 -> defaultsTo ( fn () => $this -> translator -> translate ( 'default_message' )); foreach ( $messages as $message ) { echo $formatter -> format ( $message ); } } Automatic union of objects inferring during mapping When the mapper needs to map a source to a union of objects, it will try to guess which object it will map to, based on the needed arguments of the objects, and the values contained in the source. final class UnionOfObjects { public readonly SomeFooObject | SomeBarObject $object ; } final class SomeFooObject { public readonly string $foo ; } final class SomeBarObject { public readonly string $bar ; } // Will map to an instance of `SomeFooObject` ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( UnionOfObjects :: class , [ 'foo' => 'foo' ]); // Will map to an instance of `SomeBarObject` ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( UnionOfObjects :: class , [ 'bar' => 'bar' ]);","title":"Notable changes"},{"location":"project/changelog/version-0.4.0/#breaking-changes","text":"Add access to root node when error occurs during mapping ( 54f608 ) Allow mapping to any type ( b2e810 ) Allow object builder to yield arguments without source ( 8a7414 ) Wrap node messages in proper class ( a805ba )","title":"\u26a0 BREAKING CHANGES"},{"location":"project/changelog/version-0.4.0/#features","text":"Introduce automatic union of objects inferring during mapping ( 79d7c2 ) Introduce helper class MessageMapFormatter ( ddf69e ) Introduce helper class MessagesFlattener ( a97b40 ) Introduce helper NodeTraverser for recursive operations on nodes ( cc1bc6 )","title":"Features"},{"location":"project/changelog/version-0.4.0/#bug-fixes","text":"Handle nested attributes compilation ( d2795b ) Treat forbidden mixed type as invalid type ( 36bd36 ) Treat union type resolving error as message ( e834cd ) Use locked package versions for quality assurance workflow ( 626f13 )","title":"Bug Fixes"},{"location":"project/changelog/version-0.4.0/#other","text":"Ignore changelog configuration file in git export ( 85a6a4 ) Raise PHPStan version ( 0144bf )","title":"Other"},{"location":"project/changelog/version-0.5.0/","text":"Changelog 0.5.0 \u2014 21st of January 2022 \u00b6 See release on GitHub Features \u00b6 Introduce automatic named constructor resolution ( 718d3c ) Set up dependabot for automated weekly dependency upgrades ( 23b611 ) Simplify type signature of TreeMapper#map() ( e28003 ) Bug Fixes \u00b6 Correct regex that detects @internal or @api annotations ( 39f0b7 ) Improve type definitions to allow Psalm automatic inferring ( f9b04c ) Return indexed list of attributes when filtering on type ( 66aa4d )","title":"Changelog 0.5.0 \u2014 21st of January 2022"},{"location":"project/changelog/version-0.5.0/#changelog-050-21st-of-january-2022","text":"See release on GitHub","title":"Changelog 0.5.0 \u2014 21st of January 2022"},{"location":"project/changelog/version-0.5.0/#features","text":"Introduce automatic named constructor resolution ( 718d3c ) Set up dependabot for automated weekly dependency upgrades ( 23b611 ) Simplify type signature of TreeMapper#map() ( e28003 )","title":"Features"},{"location":"project/changelog/version-0.5.0/#bug-fixes","text":"Correct regex that detects @internal or @api annotations ( 39f0b7 ) Improve type definitions to allow Psalm automatic inferring ( f9b04c ) Return indexed list of attributes when filtering on type ( 66aa4d )","title":"Bug Fixes"},{"location":"project/changelog/version-0.6.0/","text":"Changelog 0.6.0 \u2014 24th of February 2022 \u00b6 See release on GitHub \u26a0 BREAKING CHANGES \u00b6 Improve interface inferring API ( 1eb6e6 ) Improve object binding API ( 6d4270 ) Features \u00b6 Handle variadic parameters in constructors ( b6b329 ) Improve value altering API ( 422e6a ) Introduce a camel case source key modifier ( d94652 ) Introduce function definition repository ( b49ebf ) Introduce method to get parameter by index ( 380961 ) Bug Fixes \u00b6 Change license in composer.json ( 6fdd62 ) Ensure native mixed types remain valid ( 18ccbe ) Remove string keys when unpacking variadic parameter values ( cbf4e1 ) Transform exception thrown during object binding into a message ( 359e32 ) Write temporary cache file inside cache subdirectory ( 1b80a1 ) Other \u00b6 Check value acceptance in separate node builder ( 30d447 ) Narrow union types during node build ( 06e9de )","title":"Changelog 0.6.0 \u2014 24th of February 2022"},{"location":"project/changelog/version-0.6.0/#changelog-060-24th-of-february-2022","text":"See release on GitHub","title":"Changelog 0.6.0 \u2014 24th of February 2022"},{"location":"project/changelog/version-0.6.0/#breaking-changes","text":"Improve interface inferring API ( 1eb6e6 ) Improve object binding API ( 6d4270 )","title":"\u26a0 BREAKING CHANGES"},{"location":"project/changelog/version-0.6.0/#features","text":"Handle variadic parameters in constructors ( b6b329 ) Improve value altering API ( 422e6a ) Introduce a camel case source key modifier ( d94652 ) Introduce function definition repository ( b49ebf ) Introduce method to get parameter by index ( 380961 )","title":"Features"},{"location":"project/changelog/version-0.6.0/#bug-fixes","text":"Change license in composer.json ( 6fdd62 ) Ensure native mixed types remain valid ( 18ccbe ) Remove string keys when unpacking variadic parameter values ( cbf4e1 ) Transform exception thrown during object binding into a message ( 359e32 ) Write temporary cache file inside cache subdirectory ( 1b80a1 )","title":"Bug Fixes"},{"location":"project/changelog/version-0.6.0/#other","text":"Check value acceptance in separate node builder ( 30d447 ) Narrow union types during node build ( 06e9de )","title":"Other"},{"location":"project/changelog/version-0.7.0/","text":"Changelog 0.7.0 \u2014 24th of March 2022 \u00b6 See release on GitHub Notable changes \u00b6 Warning This release introduces a major breaking change that must be considered before updating Constructor registration The automatic named constructor discovery has been disabled . It is now mandatory to explicitly register custom constructors that can be used by the mapper. This decision was made because of a security issue reported by @Ocramius and described in advisory advisory GHSA-xhr8-mpwq-2rr2 . As a result, existing code must list all named constructors that were previously automatically used by the mapper, and registerer them using the method MapperBuilder::registerConstructor() . The method MapperBuilder::bind() has been deprecated in favor of the method above that should be used instead. final class SomeClass { public static function namedConstructor ( string $foo ) : self { // \u2026 } } ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> registerConstructor ( SomeClass :: namedConstructor ( ... ), // \u2026or for PHP < 8.1: [ SomeClass :: class , 'namedConstructor' ], ) -> mapper () -> map ( SomeClass :: class , [ // \u2026 ]); See documentation for more information. Source builder The Source class is a new entry point for sources that are not plain array or iterable. It allows accessing other features like camel-case keys or custom paths mapping in a convenient way. It should be used as follows: $source = \\CuyZ\\Valinor\\Mapper\\Source\\Source :: json ( $jsonString ) -> camelCaseKeys () -> map ([ 'towns' => 'cities' , 'towns.*.label' => 'name' , ]); $result = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( SomeClass :: class , $source ); See documentation for more details about its usage. \u26a0 BREAKING CHANGES \u00b6 Change Attributes::ofType return type to array ( 1a599b ) Introduce method to register constructors used during mapping ( ecafba ) Features \u00b6 Introduce a path-mapping source modifier ( b7a7d2 ) Introduce a source builder ( ad5103 ) Bug Fixes \u00b6 Handle numeric key with camel case source key modifier ( b8a18f ) Handle parameter default object value compilation ( fdef93 ) Handle variadic arguments in callable constructors ( b646cc ) Properly handle alias types for function reflection ( e5b515 ) Other \u00b6 Add Striker HTML report when running infection ( 79c7a4 ) Handle class name in function definition ( e2451d ) Introduce functions container to wrap definition handling ( fd1117 )","title":"Changelog 0.7.0 \u2014 24th of March 2022"},{"location":"project/changelog/version-0.7.0/#changelog-070-24th-of-march-2022","text":"See release on GitHub","title":"Changelog 0.7.0 \u2014 24th of March 2022"},{"location":"project/changelog/version-0.7.0/#notable-changes","text":"Warning This release introduces a major breaking change that must be considered before updating Constructor registration The automatic named constructor discovery has been disabled . It is now mandatory to explicitly register custom constructors that can be used by the mapper. This decision was made because of a security issue reported by @Ocramius and described in advisory advisory GHSA-xhr8-mpwq-2rr2 . As a result, existing code must list all named constructors that were previously automatically used by the mapper, and registerer them using the method MapperBuilder::registerConstructor() . The method MapperBuilder::bind() has been deprecated in favor of the method above that should be used instead. final class SomeClass { public static function namedConstructor ( string $foo ) : self { // \u2026 } } ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> registerConstructor ( SomeClass :: namedConstructor ( ... ), // \u2026or for PHP < 8.1: [ SomeClass :: class , 'namedConstructor' ], ) -> mapper () -> map ( SomeClass :: class , [ // \u2026 ]); See documentation for more information. Source builder The Source class is a new entry point for sources that are not plain array or iterable. It allows accessing other features like camel-case keys or custom paths mapping in a convenient way. It should be used as follows: $source = \\CuyZ\\Valinor\\Mapper\\Source\\Source :: json ( $jsonString ) -> camelCaseKeys () -> map ([ 'towns' => 'cities' , 'towns.*.label' => 'name' , ]); $result = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( SomeClass :: class , $source ); See documentation for more details about its usage.","title":"Notable changes"},{"location":"project/changelog/version-0.7.0/#breaking-changes","text":"Change Attributes::ofType return type to array ( 1a599b ) Introduce method to register constructors used during mapping ( ecafba )","title":"\u26a0 BREAKING CHANGES"},{"location":"project/changelog/version-0.7.0/#features","text":"Introduce a path-mapping source modifier ( b7a7d2 ) Introduce a source builder ( ad5103 )","title":"Features"},{"location":"project/changelog/version-0.7.0/#bug-fixes","text":"Handle numeric key with camel case source key modifier ( b8a18f ) Handle parameter default object value compilation ( fdef93 ) Handle variadic arguments in callable constructors ( b646cc ) Properly handle alias types for function reflection ( e5b515 )","title":"Bug Fixes"},{"location":"project/changelog/version-0.7.0/#other","text":"Add Striker HTML report when running infection ( 79c7a4 ) Handle class name in function definition ( e2451d ) Introduce functions container to wrap definition handling ( fd1117 )","title":"Other"},{"location":"project/changelog/version-0.8.0/","text":"Changelog 0.8.0 \u2014 9th of May 2022 \u00b6 See release on GitHub Notable changes \u00b6 Float values handling Allows the usage of float values, as follows: class Foo { /** @var 404.42|1337.42 */ public readonly float $value ; } Literal boolean true / false values handling Thanks @danog for this feature! Allows the usage of boolean values, as follows: class Foo { /** @var int|false */ public readonly int | bool $value ; } Class string of union of object handling Allows to declare several class names in a class-string : class Foo { /** @var class-string<SomeClass|SomeOtherClass> */ public readonly string $className ; } Allow psalm and phpstan prefix in docblocks Thanks @boesing for this feature! The following annotations are now properly handled: @psalm-param , @phpstan-param , @psalm-return and @phpstan-return . If one of those is found along with a basic @param or @return annotation, it will take precedence over the basic value. Features \u00b6 Allow psalm and phpstan prefix in docblocks ( 64e0a2 ) Handle class string of union of object ( b7923b ) Handle filename in function definition ( 0b042b ) Handle float value type ( 790df8 ) Handle literal boolean true / false types ( afcedf ) Introduce composite types ( 892f38 ) Bug Fixes \u00b6 Call value altering function only if value is accepted ( 2f08e1 ) Handle function definition cache invalidation when file is modified ( 511a0d ) Other \u00b6 Add configuration for Composer allowed plugins ( 2f310c ) Add Psalm configuration file to .gitattributes ( 979272 ) Bump dev-dependencies ( 844384 ) Declare code type in docblocks ( 03c84a ) Ignore Polyfill coverage ( c08fe5 ) Remove symfony/polyfill-php80 dependency ( 368737 )","title":"Changelog 0.8.0 \u2014 9th of May 2022"},{"location":"project/changelog/version-0.8.0/#changelog-080-9th-of-may-2022","text":"See release on GitHub","title":"Changelog 0.8.0 \u2014 9th of May 2022"},{"location":"project/changelog/version-0.8.0/#notable-changes","text":"Float values handling Allows the usage of float values, as follows: class Foo { /** @var 404.42|1337.42 */ public readonly float $value ; } Literal boolean true / false values handling Thanks @danog for this feature! Allows the usage of boolean values, as follows: class Foo { /** @var int|false */ public readonly int | bool $value ; } Class string of union of object handling Allows to declare several class names in a class-string : class Foo { /** @var class-string<SomeClass|SomeOtherClass> */ public readonly string $className ; } Allow psalm and phpstan prefix in docblocks Thanks @boesing for this feature! The following annotations are now properly handled: @psalm-param , @phpstan-param , @psalm-return and @phpstan-return . If one of those is found along with a basic @param or @return annotation, it will take precedence over the basic value.","title":"Notable changes"},{"location":"project/changelog/version-0.8.0/#features","text":"Allow psalm and phpstan prefix in docblocks ( 64e0a2 ) Handle class string of union of object ( b7923b ) Handle filename in function definition ( 0b042b ) Handle float value type ( 790df8 ) Handle literal boolean true / false types ( afcedf ) Introduce composite types ( 892f38 )","title":"Features"},{"location":"project/changelog/version-0.8.0/#bug-fixes","text":"Call value altering function only if value is accepted ( 2f08e1 ) Handle function definition cache invalidation when file is modified ( 511a0d )","title":"Bug Fixes"},{"location":"project/changelog/version-0.8.0/#other","text":"Add configuration for Composer allowed plugins ( 2f310c ) Add Psalm configuration file to .gitattributes ( 979272 ) Bump dev-dependencies ( 844384 ) Declare code type in docblocks ( 03c84a ) Ignore Polyfill coverage ( c08fe5 ) Remove symfony/polyfill-php80 dependency ( 368737 )","title":"Other"},{"location":"project/changelog/version-0.9.0/","text":"Changelog 0.9.0 \u2014 23rd of May 2022 \u00b6 See release on GitHub Notable changes \u00b6 Cache injection and warmup The cache feature has been revisited, to give more control to the user on how and when to use it. The method MapperBuilder::withCacheDir() has been deprecated in favor of a new method MapperBuilder::withCache() which accepts any PSR-16 compliant implementation. Warning These changes lead up to the default cache not being automatically registered anymore. If you still want to enable the cache (which you should), you will have to explicitly inject it (see below). A default implementation is provided out of the box, which saves cache entries into the file system. When the application runs in a development environment, the cache implementation should be decorated with FileWatchingCache , which will watch the files of the application and invalidate cache entries when a PHP file is modified by a developer \u2014 preventing the library not behaving as expected when the signature of a property or a method changes. The cache can be warmed up, for instance in a pipeline during the build and deployment of the application \u2014 kudos to @boesing for the feature! Note The cache has to be registered first, otherwise the warmup will end up being useless. $cache = new \\CuyZ\\Valinor\\Cache\\FileSystemCache ( 'path/to/cache-directory' ); if ( $isApplicationInDevelopmentEnvironment ) { $cache = new \\CuyZ\\Valinor\\Cache\\FileWatchingCache ( $cache ); } $mapperBuilder = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> withCache ( $cache ); // During the build: $mapperBuilder -> warmup ( SomeClass :: class , SomeOtherClass :: class ); // In the application: $mapperBuilder -> mapper () -> map ( SomeClass :: class , [ /* \u2026 */ ]); Message formatting & translation Major changes have been made to the messages being returned in case of a mapping error: the actual texts are now more accurate and show better information. Warning The method NodeMessage::format has been removed, message formatters should be used instead. If needed, the old behaviour can be retrieved with the formatter PlaceHolderMessageFormatter , although it is strongly advised to use the new placeholders feature (see below). The signature of the method MessageFormatter::format has changed as well. It is now also easier to format the messages, for instance when they need to be translated. Placeholders can now be used in a message body, and will be replaced with useful information. Placeholder Description {message_code} the code of the message {node_name} name of the node to which the message is bound {node_path} path of the node to which the message is bound {node_type} type of the node to which the message is bound {original_value} the source value that was given to the node {original_message} the original message before being customized try { ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( SomeClass :: class , [ /* \u2026 */ ]); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { $node = $error -> node (); $messages = new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\MessagesFlattener ( $node ); foreach ( $messages as $message ) { if ( $message -> code () === 'some_code' ) { $message = $message -> withBody ( 'new message / {original_message}' ); } echo $message ; } } The messages are formatted using the ICU library , enabling the placeholders to use advanced syntax to perform proper translations, for instance currency support. try { ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( 'int<0, 100>' , 1337 ); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { $message = $error -> node () -> messages ()[ 0 ]; if ( is_numeric ( $message -> value ())) { $message = $message -> withBody ( 'Invalid amount {original_value, number, currency}' ); } // Invalid amount: $1,337.00 echo $message -> withLocale ( 'en_US' ); // Invalid amount: \u00a31,337.00 echo $message -> withLocale ( 'en_GB' ); // Invalid amount: 1 337,00 \u20ac echo $message -> withLocale ( 'fr_FR' ); } See ICU documentation for more information on available syntax. Warning If the intl extension is not installed, a shim will be available to replace the placeholders, but it won't handle advanced syntax as described above. The formatter TranslationMessageFormatter can be used to translate the content of messages. The library provides a list of all messages that can be returned; this list can be filled or modified with custom translations. \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\TranslationMessageFormatter :: default () // Create/override a single entry\u2026 -> withTranslation ( 'fr' , 'some custom message' , 'un message personnalis\u00e9' ) // \u2026or several entries. -> withTranslations ([ 'some custom message' => [ 'en' => 'Some custom message' , 'fr' => 'Un message personnalis\u00e9' , 'es' => 'Un mensaje personalizado' , ], 'some other message' => [ // \u2026 ], ]) -> format ( $message ); It is possible to join several formatters into one formatter by using the AggregateMessageFormatter . This instance can then easily be injected in a service that will handle messages. The formatters will be called in the same order they are given to the aggregate. ( new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\AggregateMessageFormatter ( new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\LocaleMessageFormatter ( 'fr' ), new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\MessageMapFormatter ([ // \u2026 ], \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\TranslationMessageFormatter :: default (), )) -> format ( $message ) \u26a0 BREAKING CHANGES \u00b6 Improve message customization with formatters ( 60a665 ) Revoke ObjectBuilder API access ( 11e126 ) Features \u00b6 Allow injecting a cache implementation that is used by the mapper ( 69ad3f ) Extract file watching feature in own cache implementation ( 2d70ef ) Improve mapping error messages ( 05cf4a ) Introduce method to warm the cache up ( ccf09f ) Bug Fixes \u00b6 Make interface type match undefined object type ( 105eef ) Other \u00b6 Change InvalidParameterIndex exception inheritance type ( b75adb ) Introduce layer for object builder arguments ( 48f936 )","title":"Changelog 0.9.0 \u2014 23rd of May 2022"},{"location":"project/changelog/version-0.9.0/#changelog-090-23rd-of-may-2022","text":"See release on GitHub","title":"Changelog 0.9.0 \u2014 23rd of May 2022"},{"location":"project/changelog/version-0.9.0/#notable-changes","text":"Cache injection and warmup The cache feature has been revisited, to give more control to the user on how and when to use it. The method MapperBuilder::withCacheDir() has been deprecated in favor of a new method MapperBuilder::withCache() which accepts any PSR-16 compliant implementation. Warning These changes lead up to the default cache not being automatically registered anymore. If you still want to enable the cache (which you should), you will have to explicitly inject it (see below). A default implementation is provided out of the box, which saves cache entries into the file system. When the application runs in a development environment, the cache implementation should be decorated with FileWatchingCache , which will watch the files of the application and invalidate cache entries when a PHP file is modified by a developer \u2014 preventing the library not behaving as expected when the signature of a property or a method changes. The cache can be warmed up, for instance in a pipeline during the build and deployment of the application \u2014 kudos to @boesing for the feature! Note The cache has to be registered first, otherwise the warmup will end up being useless. $cache = new \\CuyZ\\Valinor\\Cache\\FileSystemCache ( 'path/to/cache-directory' ); if ( $isApplicationInDevelopmentEnvironment ) { $cache = new \\CuyZ\\Valinor\\Cache\\FileWatchingCache ( $cache ); } $mapperBuilder = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> withCache ( $cache ); // During the build: $mapperBuilder -> warmup ( SomeClass :: class , SomeOtherClass :: class ); // In the application: $mapperBuilder -> mapper () -> map ( SomeClass :: class , [ /* \u2026 */ ]); Message formatting & translation Major changes have been made to the messages being returned in case of a mapping error: the actual texts are now more accurate and show better information. Warning The method NodeMessage::format has been removed, message formatters should be used instead. If needed, the old behaviour can be retrieved with the formatter PlaceHolderMessageFormatter , although it is strongly advised to use the new placeholders feature (see below). The signature of the method MessageFormatter::format has changed as well. It is now also easier to format the messages, for instance when they need to be translated. Placeholders can now be used in a message body, and will be replaced with useful information. Placeholder Description {message_code} the code of the message {node_name} name of the node to which the message is bound {node_path} path of the node to which the message is bound {node_type} type of the node to which the message is bound {original_value} the source value that was given to the node {original_message} the original message before being customized try { ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( SomeClass :: class , [ /* \u2026 */ ]); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { $node = $error -> node (); $messages = new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\MessagesFlattener ( $node ); foreach ( $messages as $message ) { if ( $message -> code () === 'some_code' ) { $message = $message -> withBody ( 'new message / {original_message}' ); } echo $message ; } } The messages are formatted using the ICU library , enabling the placeholders to use advanced syntax to perform proper translations, for instance currency support. try { ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( 'int<0, 100>' , 1337 ); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { $message = $error -> node () -> messages ()[ 0 ]; if ( is_numeric ( $message -> value ())) { $message = $message -> withBody ( 'Invalid amount {original_value, number, currency}' ); } // Invalid amount: $1,337.00 echo $message -> withLocale ( 'en_US' ); // Invalid amount: \u00a31,337.00 echo $message -> withLocale ( 'en_GB' ); // Invalid amount: 1 337,00 \u20ac echo $message -> withLocale ( 'fr_FR' ); } See ICU documentation for more information on available syntax. Warning If the intl extension is not installed, a shim will be available to replace the placeholders, but it won't handle advanced syntax as described above. The formatter TranslationMessageFormatter can be used to translate the content of messages. The library provides a list of all messages that can be returned; this list can be filled or modified with custom translations. \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\TranslationMessageFormatter :: default () // Create/override a single entry\u2026 -> withTranslation ( 'fr' , 'some custom message' , 'un message personnalis\u00e9' ) // \u2026or several entries. -> withTranslations ([ 'some custom message' => [ 'en' => 'Some custom message' , 'fr' => 'Un message personnalis\u00e9' , 'es' => 'Un mensaje personalizado' , ], 'some other message' => [ // \u2026 ], ]) -> format ( $message ); It is possible to join several formatters into one formatter by using the AggregateMessageFormatter . This instance can then easily be injected in a service that will handle messages. The formatters will be called in the same order they are given to the aggregate. ( new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\AggregateMessageFormatter ( new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\LocaleMessageFormatter ( 'fr' ), new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\MessageMapFormatter ([ // \u2026 ], \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\TranslationMessageFormatter :: default (), )) -> format ( $message )","title":"Notable changes"},{"location":"project/changelog/version-0.9.0/#breaking-changes","text":"Improve message customization with formatters ( 60a665 ) Revoke ObjectBuilder API access ( 11e126 )","title":"\u26a0 BREAKING CHANGES"},{"location":"project/changelog/version-0.9.0/#features","text":"Allow injecting a cache implementation that is used by the mapper ( 69ad3f ) Extract file watching feature in own cache implementation ( 2d70ef ) Improve mapping error messages ( 05cf4a ) Introduce method to warm the cache up ( ccf09f )","title":"Features"},{"location":"project/changelog/version-0.9.0/#bug-fixes","text":"Make interface type match undefined object type ( 105eef )","title":"Bug Fixes"},{"location":"project/changelog/version-0.9.0/#other","text":"Change InvalidParameterIndex exception inheritance type ( b75adb ) Introduce layer for object builder arguments ( 48f936 )","title":"Other"},{"location":"project/changelog/version-1.0.0/","text":"Changelog 1.0.0 \u2014 28th of November 2022 \u00b6 See release on GitHub First stable version! \ud83e\udd73 \ud83c\udf89 This release marks the end of the initial development phase. The library has been live for exactly one year at this date and is stable enough to start following the semantic versioning \u2014 it means that any backward incompatible change (aka breaking change) will lead to a bump of the major version. This is the biggest milestone achieved by this project (yet\u2122); I want to thank everyone who has been involved to make it possible, especially the contributors who submitted high-quality pull requests to improve the library. There is also one person that I want to thank even more: my best friend Nathan , who has always been so supportive with my side-projects. Thanks, bro! \ud83d\ude4c The last year marked a bigger investment of my time in OSS contributions; I've proven to myself that I am able to follow a stable way of managing my engagement to this community, and this is why I enabled sponsorship on my profile to allow people to \u2764\ufe0f sponsor my work on GitHub \u2014 if you use this library in your applications, please consider offering me a \ud83c\udf7a from time to time! \ud83e\udd17 Notable changes \u00b6 End of PHP 7.4 support PHP 7.4 security support has ended on the 28th of November 2022 ; the minimum version supported by this library is now PHP 8.0. New mapper to map arguments of a callable This new mapper can be used to ensure a source has the right shape before calling a function/method. The mapper builder can be configured the same way it would be with a tree mapper, for instance to customize the type strictness. $someFunction = function ( string $foo , int $bar ) : string { return \" $foo / $bar \" ; }; try { $arguments = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> argumentsMapper () -> mapArguments ( $someFunction , [ 'foo' => 'some value' , 'bar' => 42 , ]); // some value / 42 echo $someFunction ( ... $arguments ); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { // Do something\u2026 } Support for TimeZone objects Native TimeZone objects construction is now supported with a proper error handling. try { ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( DateTimeZone :: class , 'Jupiter/Europa' ); } catch ( MappingError $exception ) { $error = $exception -> node () -> messages ()[ 0 ]; // Value 'Jupiter/Europa' is not a valid timezone. echo $error -> toString (); } Mapping object with one property When a class needs only one value, the source given to the mapper must match the type of the single property/parameter. This change aims to bring consistency on how the mapper behaves when mapping an object that needs one argument. Before this change, the source could either match the needed type, or be an array with a single entry and a key named after the argument. See example below: final class Identifier { public readonly string $value ; } final class SomeClass { public readonly Identifier $identifier ; public readonly string $description ; } ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( SomeClass :: class , [ 'identifier' => [ 'value' => 'some-identifier' ], // \u274c 'description' => 'Lorem ipsum\u2026' , ]); ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( SomeClass :: class , [ 'identifier' => 'some-identifier' , // \u2705 'description' => 'Lorem ipsum\u2026' , ]); Upgrading from 0.x to 1.0 \u00b6 As this is a major release, all deprecated features have been removed, leading to an important number of breaking changes. You can click on the entries below to get advice on available replacements. Doctrine annotations support removal Doctrine annotations cannot be used anymore, PHP attributes must be used. BackwardCompatibilityDateTimeConstructor class removal You must use the method available in the mapper builder, see dealing with dates chapter . Mapper builder flexible method removal The flexible has been splitted in three disctint modes, see type strictness & flexibility chapter . Mapper builder withCacheDir method removal You must now register a cache instance directly, see performance & caching chapter . StaticMethodConstructor class removal You must now register the constructors using the mapper builder, see custom object constructors chapter . Mapper builder bind method removal You must now register the constructors using the mapper builder, see custom object constructors chapter . ThrowableMessage class removal You must now use the MessageBuilder class, see error handling chapter . MessagesFlattener class removal You must now use the Messages class, see error handling chapter . TranslatableMessage class removal You must now use the HasParameters class, see custom exception chapter . Message methods removal The following methods have been removed: \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\NodeMessage::name() \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\NodeMessage::path() \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\NodeMessage::type() \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\NodeMessage::value() \\CuyZ\\Valinor\\Mapper\\Tree\\Node::value() It is still possible to get the wanted values using the method \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\NodeMessage::node() . The placeholder {original_value} has also been removed, the same value can be fetched with {source_value} . PlaceHolderMessageFormatter class removal Other features are available to format message, see error messages customization chapter . Identifier attribute removal This feature has been part of the library since its first public release, but it was never documented because it did not fit one of the library's main philosophy which is to be almost entirely decoupled from an application's domain layer. The feature is entirely removed and not planned to be replaced by an alternative, unless the community really feels like there is a need for something alike. \u26a0 BREAKING CHANGES \u00b6 Disallow array when mapping to object with one argument ( 72cba3 ) Mark tree mapper and arguments mapper as @pure ( 0d9855 ) Remove deprecated backward compatibility datetime constructor ( a65e8d ) Remove deprecated class ThrowableMessage ( d36ca9 ) Remove deprecated class to flatten messages ( f9ed93 ) Remove deprecated interface TranslatableMessage ( ceb197 ) Remove deprecated message methods ( e6557d ) Remove deprecated method constructor attribute ( d76467 ) Remove deprecated method to enable flexible mode ( a2bef3 ) Remove deprecated method to set cache directory ( b0d6d2 ) Remove deprecated method used to bind a callback ( b79ed8 ) Remove deprecated placeholder message formatter ( c2723d ) Remove Doctrine annotations support ( 66c182 ) Remove identifier attribute ( 8a7486 ) Remove PHP 7.4 support ( 5f5a50 ) Remove support for strict-array type ( 22c3b4 ) Features \u00b6 Add constructor for DateTimeZone with error support ( a0a4d6 ) Introduce mapper to map arguments of a callable ( 9c7e88 ) Bug Fixes \u00b6 Allow mapping null to single node nullable type ( 0a98ec ) Handle single argument mapper properly ( d7bf6a ) Handle tree mapper call without argument in PHPStan extension ( 3f3a01 ) Handle tree mapper call without argument in Psalm plugin ( b425af ) Other \u00b6 Activate value altering feature only when callbacks are registered ( 0f33a5 ) Bump psr/simple-cache supported version ( e4059a ) Remove @ from comments for future PHP versions changes ( 68774c ) Update dependencies ( 4afcda )","title":"Changelog 1.0.0 \u2014 28th of November 2022"},{"location":"project/changelog/version-1.0.0/#changelog-100-28th-of-november-2022","text":"See release on GitHub First stable version! \ud83e\udd73 \ud83c\udf89 This release marks the end of the initial development phase. The library has been live for exactly one year at this date and is stable enough to start following the semantic versioning \u2014 it means that any backward incompatible change (aka breaking change) will lead to a bump of the major version. This is the biggest milestone achieved by this project (yet\u2122); I want to thank everyone who has been involved to make it possible, especially the contributors who submitted high-quality pull requests to improve the library. There is also one person that I want to thank even more: my best friend Nathan , who has always been so supportive with my side-projects. Thanks, bro! \ud83d\ude4c The last year marked a bigger investment of my time in OSS contributions; I've proven to myself that I am able to follow a stable way of managing my engagement to this community, and this is why I enabled sponsorship on my profile to allow people to \u2764\ufe0f sponsor my work on GitHub \u2014 if you use this library in your applications, please consider offering me a \ud83c\udf7a from time to time! \ud83e\udd17","title":"Changelog 1.0.0 \u2014 28th of November 2022"},{"location":"project/changelog/version-1.0.0/#notable-changes","text":"End of PHP 7.4 support PHP 7.4 security support has ended on the 28th of November 2022 ; the minimum version supported by this library is now PHP 8.0. New mapper to map arguments of a callable This new mapper can be used to ensure a source has the right shape before calling a function/method. The mapper builder can be configured the same way it would be with a tree mapper, for instance to customize the type strictness. $someFunction = function ( string $foo , int $bar ) : string { return \" $foo / $bar \" ; }; try { $arguments = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> argumentsMapper () -> mapArguments ( $someFunction , [ 'foo' => 'some value' , 'bar' => 42 , ]); // some value / 42 echo $someFunction ( ... $arguments ); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { // Do something\u2026 } Support for TimeZone objects Native TimeZone objects construction is now supported with a proper error handling. try { ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( DateTimeZone :: class , 'Jupiter/Europa' ); } catch ( MappingError $exception ) { $error = $exception -> node () -> messages ()[ 0 ]; // Value 'Jupiter/Europa' is not a valid timezone. echo $error -> toString (); } Mapping object with one property When a class needs only one value, the source given to the mapper must match the type of the single property/parameter. This change aims to bring consistency on how the mapper behaves when mapping an object that needs one argument. Before this change, the source could either match the needed type, or be an array with a single entry and a key named after the argument. See example below: final class Identifier { public readonly string $value ; } final class SomeClass { public readonly Identifier $identifier ; public readonly string $description ; } ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( SomeClass :: class , [ 'identifier' => [ 'value' => 'some-identifier' ], // \u274c 'description' => 'Lorem ipsum\u2026' , ]); ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( SomeClass :: class , [ 'identifier' => 'some-identifier' , // \u2705 'description' => 'Lorem ipsum\u2026' , ]);","title":"Notable changes"},{"location":"project/changelog/version-1.0.0/#upgrading-from-0x-to-10","text":"As this is a major release, all deprecated features have been removed, leading to an important number of breaking changes. You can click on the entries below to get advice on available replacements. Doctrine annotations support removal Doctrine annotations cannot be used anymore, PHP attributes must be used. BackwardCompatibilityDateTimeConstructor class removal You must use the method available in the mapper builder, see dealing with dates chapter . Mapper builder flexible method removal The flexible has been splitted in three disctint modes, see type strictness & flexibility chapter . Mapper builder withCacheDir method removal You must now register a cache instance directly, see performance & caching chapter . StaticMethodConstructor class removal You must now register the constructors using the mapper builder, see custom object constructors chapter . Mapper builder bind method removal You must now register the constructors using the mapper builder, see custom object constructors chapter . ThrowableMessage class removal You must now use the MessageBuilder class, see error handling chapter . MessagesFlattener class removal You must now use the Messages class, see error handling chapter . TranslatableMessage class removal You must now use the HasParameters class, see custom exception chapter . Message methods removal The following methods have been removed: \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\NodeMessage::name() \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\NodeMessage::path() \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\NodeMessage::type() \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\NodeMessage::value() \\CuyZ\\Valinor\\Mapper\\Tree\\Node::value() It is still possible to get the wanted values using the method \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\NodeMessage::node() . The placeholder {original_value} has also been removed, the same value can be fetched with {source_value} . PlaceHolderMessageFormatter class removal Other features are available to format message, see error messages customization chapter . Identifier attribute removal This feature has been part of the library since its first public release, but it was never documented because it did not fit one of the library's main philosophy which is to be almost entirely decoupled from an application's domain layer. The feature is entirely removed and not planned to be replaced by an alternative, unless the community really feels like there is a need for something alike.","title":"Upgrading from 0.x to 1.0"},{"location":"project/changelog/version-1.0.0/#breaking-changes","text":"Disallow array when mapping to object with one argument ( 72cba3 ) Mark tree mapper and arguments mapper as @pure ( 0d9855 ) Remove deprecated backward compatibility datetime constructor ( a65e8d ) Remove deprecated class ThrowableMessage ( d36ca9 ) Remove deprecated class to flatten messages ( f9ed93 ) Remove deprecated interface TranslatableMessage ( ceb197 ) Remove deprecated message methods ( e6557d ) Remove deprecated method constructor attribute ( d76467 ) Remove deprecated method to enable flexible mode ( a2bef3 ) Remove deprecated method to set cache directory ( b0d6d2 ) Remove deprecated method used to bind a callback ( b79ed8 ) Remove deprecated placeholder message formatter ( c2723d ) Remove Doctrine annotations support ( 66c182 ) Remove identifier attribute ( 8a7486 ) Remove PHP 7.4 support ( 5f5a50 ) Remove support for strict-array type ( 22c3b4 )","title":"\u26a0 BREAKING CHANGES"},{"location":"project/changelog/version-1.0.0/#features","text":"Add constructor for DateTimeZone with error support ( a0a4d6 ) Introduce mapper to map arguments of a callable ( 9c7e88 )","title":"Features"},{"location":"project/changelog/version-1.0.0/#bug-fixes","text":"Allow mapping null to single node nullable type ( 0a98ec ) Handle single argument mapper properly ( d7bf6a ) Handle tree mapper call without argument in PHPStan extension ( 3f3a01 ) Handle tree mapper call without argument in Psalm plugin ( b425af )","title":"Bug Fixes"},{"location":"project/changelog/version-1.0.0/#other","text":"Activate value altering feature only when callbacks are registered ( 0f33a5 ) Bump psr/simple-cache supported version ( e4059a ) Remove @ from comments for future PHP versions changes ( 68774c ) Update dependencies ( 4afcda )","title":"Other"},{"location":"usage/error-handling/","text":"Error handling \u00b6 The source given to a mapper can never be trusted, this is actually the very goal of this library: transforming an unstructured input to a well-defined object structure. If the mapper cannot guess how to cast a certain value, it means that it is not able to guarantee the validity of the desired object thus it will fail. Any issue encountered during the mapping will add an error to an upstream exception of type \\CuyZ\\Valinor\\Mapper\\MappingError . It is therefore always recommended wrapping the mapping function call with a try/catch statement and handle the error properly. When the mapping fails, the exception gives access to the root node. This recursive object allows retrieving all needed information through the whole mapping tree: path, values, types and messages, including the issues that caused the exception. Node messages can be customized and iterated through with the usage of the class \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Messages . try { ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( SomeClass :: class , [ /* \u2026 */ ]); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { // Get flatten list of all messages through the whole nodes tree $messages = \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Messages :: flattenFromNode ( $error -> node () ); // Formatters can be added and will be applied on all messages $messages = $messages -> formatWith ( new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\MessageMapFormatter ([ // \u2026 ]), ( new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\TranslationMessageFormatter ()) -> withTranslations ([ // \u2026 ]) ); // If only errors are wanted, they can be filtered $errorMessages = $messages -> errors (); foreach ( $errorMessages as $message ) { echo $message ; } } Custom exception messages \u00b6 More specific validation should be done in the constructor of the object, by throwing an exception if something is wrong with the given data. For security reasons, exceptions thrown in a constructor will not be caught by the mapper, unless one of the three options below is used. 1. Custom exception classes \u00b6 An exception that implements \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\ErrorMessage can be thrown. The body can contain placeholders, see message customization chapter for more information. If more parameters can be provided, the exception can also implement the interface \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\HasParameters that returns a list of string values, using keys as parameters names. To help identifying an error, a unique code can be provided by implementing the interface CuyZ\\Valinor\\Mapper\\Tree\\Message\\HasCode . final class SomeClass { public function __construct ( private string $value ) { if ( $this -> value === 'foo' ) { throw new SomeException ( 'some custom parameter' ); } } } use CuyZ\\Valinor\\Mapper\\Tree\\Message\\ErrorMessage ; use CuyZ\\Valinor\\Mapper\\Tree\\Message\\HasCode ; use CuyZ\\Valinor\\Mapper\\Tree\\Message\\HasParameters ; final class SomeException extends DomainException implements ErrorMessage , HasParameters , HasCode { private string $someParameter ; public function __construct ( string $someParameter ) { parent :: __construct (); $this -> someParameter = $someParameter ; } public function body () : string { return 'Some custom message / {some_parameter} / {source_value}' ; } public function parameters () : array { return [ 'some_parameter' => $this -> someParameter , ]; } public function code () : string { // A unique code that can help to identify the error return 'some_unique_code' ; } } try { ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( SomeClass :: class , 'foo' ); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $exception ) { // Should print: // Some custom message / some custom parameter / 'foo' echo $exception -> node () -> messages ()[ 0 ]; } 2. Use provided message builder \u00b6 The utility class \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\MessageBuilder can be used to build a message. final class SomeClass { public function __construct ( private string $value ) { if ( str_starts_with ( $this -> value , 'foo_' )) { throw \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\MessageBuilder :: newError ( 'Some custom error message: {value}.' ) -> withCode ( 'some_code' ) -> withParameter ( 'value' , $this -> value ) -> build (); } } } try { ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( SomeClass :: class , 'foo_bar' ); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $exception ) { // Should print: // > Some custom error message: foo_bar. echo $exception -> node () -> messages ()[ 0 ]; } 3. Allow third party exceptions \u00b6 It is possible to set up a list of exceptions that can be caught by the mapper, for instance when using lightweight validation tools like Webmozart Assert . It is advised to use this feature with caution: userland exceptions may contain sensible information \u2014 for instance an SQL exception showing a part of a query should never be allowed. Therefore, only an exhaustive list of carefully chosen exceptions should be filtered. final class SomeClass { public function __construct ( private string $value ) { \\Webmozart\\Assert\\Assert :: startsWith ( $value , 'foo_' ); } } try { ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> filterExceptions ( function ( Throwable $exception ) { if ( $exception instanceof \\Webmozart\\Assert\\InvalidArgumentException ) { return \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\MessageBuilder :: from ( $exception ); } // If the exception should not be caught by this library, it // must be thrown again. throw $exception ; }) -> mapper () -> map ( SomeClass :: class , 'bar_baz' ); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $exception ) { // Should print something similar to: // > Expected a value to start with \"foo_\". Got: \"bar_baz\" echo $exception -> node () -> messages ()[ 0 ]; }","title":"Error handling"},{"location":"usage/error-handling/#error-handling","text":"The source given to a mapper can never be trusted, this is actually the very goal of this library: transforming an unstructured input to a well-defined object structure. If the mapper cannot guess how to cast a certain value, it means that it is not able to guarantee the validity of the desired object thus it will fail. Any issue encountered during the mapping will add an error to an upstream exception of type \\CuyZ\\Valinor\\Mapper\\MappingError . It is therefore always recommended wrapping the mapping function call with a try/catch statement and handle the error properly. When the mapping fails, the exception gives access to the root node. This recursive object allows retrieving all needed information through the whole mapping tree: path, values, types and messages, including the issues that caused the exception. Node messages can be customized and iterated through with the usage of the class \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Messages . try { ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( SomeClass :: class , [ /* \u2026 */ ]); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $error ) { // Get flatten list of all messages through the whole nodes tree $messages = \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Messages :: flattenFromNode ( $error -> node () ); // Formatters can be added and will be applied on all messages $messages = $messages -> formatWith ( new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\MessageMapFormatter ([ // \u2026 ]), ( new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\TranslationMessageFormatter ()) -> withTranslations ([ // \u2026 ]) ); // If only errors are wanted, they can be filtered $errorMessages = $messages -> errors (); foreach ( $errorMessages as $message ) { echo $message ; } }","title":"Error handling"},{"location":"usage/error-handling/#custom-exception-messages","text":"More specific validation should be done in the constructor of the object, by throwing an exception if something is wrong with the given data. For security reasons, exceptions thrown in a constructor will not be caught by the mapper, unless one of the three options below is used.","title":"Custom exception messages"},{"location":"usage/error-handling/#1-custom-exception-classes","text":"An exception that implements \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\ErrorMessage can be thrown. The body can contain placeholders, see message customization chapter for more information. If more parameters can be provided, the exception can also implement the interface \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\HasParameters that returns a list of string values, using keys as parameters names. To help identifying an error, a unique code can be provided by implementing the interface CuyZ\\Valinor\\Mapper\\Tree\\Message\\HasCode . final class SomeClass { public function __construct ( private string $value ) { if ( $this -> value === 'foo' ) { throw new SomeException ( 'some custom parameter' ); } } } use CuyZ\\Valinor\\Mapper\\Tree\\Message\\ErrorMessage ; use CuyZ\\Valinor\\Mapper\\Tree\\Message\\HasCode ; use CuyZ\\Valinor\\Mapper\\Tree\\Message\\HasParameters ; final class SomeException extends DomainException implements ErrorMessage , HasParameters , HasCode { private string $someParameter ; public function __construct ( string $someParameter ) { parent :: __construct (); $this -> someParameter = $someParameter ; } public function body () : string { return 'Some custom message / {some_parameter} / {source_value}' ; } public function parameters () : array { return [ 'some_parameter' => $this -> someParameter , ]; } public function code () : string { // A unique code that can help to identify the error return 'some_unique_code' ; } } try { ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( SomeClass :: class , 'foo' ); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $exception ) { // Should print: // Some custom message / some custom parameter / 'foo' echo $exception -> node () -> messages ()[ 0 ]; }","title":"1. Custom exception classes"},{"location":"usage/error-handling/#2-use-provided-message-builder","text":"The utility class \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\MessageBuilder can be used to build a message. final class SomeClass { public function __construct ( private string $value ) { if ( str_starts_with ( $this -> value , 'foo_' )) { throw \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\MessageBuilder :: newError ( 'Some custom error message: {value}.' ) -> withCode ( 'some_code' ) -> withParameter ( 'value' , $this -> value ) -> build (); } } } try { ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper () -> map ( SomeClass :: class , 'foo_bar' ); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $exception ) { // Should print: // > Some custom error message: foo_bar. echo $exception -> node () -> messages ()[ 0 ]; }","title":"2. Use provided message builder"},{"location":"usage/error-handling/#3-allow-third-party-exceptions","text":"It is possible to set up a list of exceptions that can be caught by the mapper, for instance when using lightweight validation tools like Webmozart Assert . It is advised to use this feature with caution: userland exceptions may contain sensible information \u2014 for instance an SQL exception showing a part of a query should never be allowed. Therefore, only an exhaustive list of carefully chosen exceptions should be filtered. final class SomeClass { public function __construct ( private string $value ) { \\Webmozart\\Assert\\Assert :: startsWith ( $value , 'foo_' ); } } try { ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> filterExceptions ( function ( Throwable $exception ) { if ( $exception instanceof \\Webmozart\\Assert\\InvalidArgumentException ) { return \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\MessageBuilder :: from ( $exception ); } // If the exception should not be caught by this library, it // must be thrown again. throw $exception ; }) -> mapper () -> map ( SomeClass :: class , 'bar_baz' ); } catch ( \\CuyZ\\Valinor\\Mapper\\MappingError $exception ) { // Should print something similar to: // > Expected a value to start with \"foo_\". Got: \"bar_baz\" echo $exception -> node () -> messages ()[ 0 ]; }","title":"3. Allow third party exceptions"},{"location":"usage/object-construction/","text":"Object construction \u00b6 During the mapping, instances of objects are recursively created and hydrated with values coming from the input. The values of an object are filled either with a constructor \u2014 which is the recommended way \u2014 or using the class properties. If a constructor exists, it will be used to create the object, otherwise the properties will be filled directly. By default, the library will use a native constructor of a class if it is public; for advanced use cases, the library also allows the usage of custom constructors . Class with a single value \u00b6 When an object needs only one value (one constructor argument or one property), the source given to the mapper must match the type of the value. See example below: final class Identifier { public readonly string $value ; } final class SomeClass { public readonly Identifier $identifier ; public readonly string $description ; } $mapper = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper (); $mapper -> map ( SomeClass :: class , [ 'identifier' => [ 'value' => 'some-identifier' ], // \u274c 'description' => 'Lorem ipsum\u2026' , ]); $mapper -> map ( SomeClass :: class , [ 'identifier' => 'some-identifier' , // \u2705 'description' => 'Lorem ipsum\u2026' , ]);","title":"Object construction"},{"location":"usage/object-construction/#object-construction","text":"During the mapping, instances of objects are recursively created and hydrated with values coming from the input. The values of an object are filled either with a constructor \u2014 which is the recommended way \u2014 or using the class properties. If a constructor exists, it will be used to create the object, otherwise the properties will be filled directly. By default, the library will use a native constructor of a class if it is public; for advanced use cases, the library also allows the usage of custom constructors .","title":"Object construction"},{"location":"usage/object-construction/#class-with-a-single-value","text":"When an object needs only one value (one constructor argument or one property), the source given to the mapper must match the type of the value. See example below: final class Identifier { public readonly string $value ; } final class SomeClass { public readonly Identifier $identifier ; public readonly string $description ; } $mapper = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> mapper (); $mapper -> map ( SomeClass :: class , [ 'identifier' => [ 'value' => 'some-identifier' ], // \u274c 'description' => 'Lorem ipsum\u2026' , ]); $mapper -> map ( SomeClass :: class , [ 'identifier' => 'some-identifier' , // \u2705 'description' => 'Lorem ipsum\u2026' , ]);","title":"Class with a single value"},{"location":"usage/type-reference/","text":"Type reference \u00b6 To prevent conflicts or duplication of the type annotations, this library tries to handle most of the type annotations that are accepted by PHPStan and Psalm . Scalar \u00b6 final class SomeClass { public function __construct ( private bool $boolean , private float $float , private int $integer , /** @var positive-int */ private int $positiveInteger , /** @var negative-int */ private int $negativeInteger , /** @var int<-42, 1337> */ private int $integerRange , /** @var int<min, 0> */ private int $integerRangeWithMinRange , /** @var int<0, max> */ private int $integerRangeWithMaxRange , private string $string , /** @var non-empty-string */ private string $nonEmptyString , /** @var numeric-string */ private string $numericString , /** @var class-string */ private string $classString , /** @var class-string<SomeInterface> */ private string $classStringOfAnInterface , ) {} } Object \u00b6 final class SomeClass { public function __construct ( private SomeClass $class , private DateTimeInterface $interface , /** @var SomeInterface&AnotherInterface */ private object $intersection , /** @var SomeCollection<SomeClass> */ private SomeCollection $classWithGeneric , ) {} } /** * @template T of object */ final class SomeCollection { public function __construct ( /** @var array<T> */ private array $objects , ) {} } Array & lists \u00b6 final class SomeClass { public function __construct ( /** @var string[] */ private array $simpleArray , /** @var array<string> */ private array $arrayOfStrings , /** @var array<string, SomeClass> */ private array $arrayOfClassWithStringKeys , /** @var array<int, SomeClass> */ private array $arrayOfClassWithIntegerKeys , /** @var non-empty-array<string> */ private array $nonEmptyArrayOfStrings , /** @var non-empty-array<string, SomeClass> */ private array $nonEmptyArrayWithStringKeys , /** @var list<string> */ private array $listOfStrings , /** @var non-empty-list<string> */ private array $nonEmptyListOfStrings , /** @var array{foo: string, bar: int} */ private array $shapedArray , /** @var array{foo: string, bar?: int} */ private array $shapedArrayWithOptionalElement , /** @var array{string, bar: int} */ private array $shapedArrayWithUndefinedKey , ) {} } Union \u00b6 final class SomeClass { public function __construct ( private int | string $simpleUnion , /** @var class-string<SomeInterface|AnotherInterface> */ private string $unionOfClassString , /** @var array<SomeInterface|AnotherInterface> */ private array $unionInsideArray , /** @var int|true */ private int | bool $unionWithLiteralTrueType ; /** @var int|false */ private int | bool $unionWithLiteralFalseType ; /** @var 404.42|1337.42 */ private float $unionOfFloatValues , /** @var 42|1337 */ private int $unionOfIntegerValues , /** @var 'foo'|'bar' */ private string $unionOfStringValues , ) {} } Class constants \u00b6 final class SomeClassWithConstants { public const FOO = 1337 ; public const BAR = 'bar' ; public const BAZ = 'baz' ; } final class SomeClass { public function __construct ( /** @var SomeClassWithConstants::FOO|SomeClassWithConstants::BAR */ private int | string $oneOfTwoCasesOfConstants , /** @param SomeClassWithConstants::BA* (matches `bar` or `baz`) */ private string $casesOfConstantsMatchingPattern , ) {} } Enums \u00b6 enum SomeEnum { case FOO ; case BAR ; case BAZ ; } final class SomeClass { public function __construct ( private SomeEnum $enum , /** @var SomeEnum::FOO|SomeEnum::BAR */ private SomeEnum $oneOfTwoCasesOfEnum , /** @var SomeEnum::BA* (matches BAR or BAZ) */ private SomeEnum $casesOfEnumMatchingPattern , ) {} }","title":"Type reference"},{"location":"usage/type-reference/#type-reference","text":"To prevent conflicts or duplication of the type annotations, this library tries to handle most of the type annotations that are accepted by PHPStan and Psalm .","title":"Type reference"},{"location":"usage/type-reference/#scalar","text":"final class SomeClass { public function __construct ( private bool $boolean , private float $float , private int $integer , /** @var positive-int */ private int $positiveInteger , /** @var negative-int */ private int $negativeInteger , /** @var int<-42, 1337> */ private int $integerRange , /** @var int<min, 0> */ private int $integerRangeWithMinRange , /** @var int<0, max> */ private int $integerRangeWithMaxRange , private string $string , /** @var non-empty-string */ private string $nonEmptyString , /** @var numeric-string */ private string $numericString , /** @var class-string */ private string $classString , /** @var class-string<SomeInterface> */ private string $classStringOfAnInterface , ) {} }","title":"Scalar"},{"location":"usage/type-reference/#object","text":"final class SomeClass { public function __construct ( private SomeClass $class , private DateTimeInterface $interface , /** @var SomeInterface&AnotherInterface */ private object $intersection , /** @var SomeCollection<SomeClass> */ private SomeCollection $classWithGeneric , ) {} } /** * @template T of object */ final class SomeCollection { public function __construct ( /** @var array<T> */ private array $objects , ) {} }","title":"Object"},{"location":"usage/type-reference/#array-lists","text":"final class SomeClass { public function __construct ( /** @var string[] */ private array $simpleArray , /** @var array<string> */ private array $arrayOfStrings , /** @var array<string, SomeClass> */ private array $arrayOfClassWithStringKeys , /** @var array<int, SomeClass> */ private array $arrayOfClassWithIntegerKeys , /** @var non-empty-array<string> */ private array $nonEmptyArrayOfStrings , /** @var non-empty-array<string, SomeClass> */ private array $nonEmptyArrayWithStringKeys , /** @var list<string> */ private array $listOfStrings , /** @var non-empty-list<string> */ private array $nonEmptyListOfStrings , /** @var array{foo: string, bar: int} */ private array $shapedArray , /** @var array{foo: string, bar?: int} */ private array $shapedArrayWithOptionalElement , /** @var array{string, bar: int} */ private array $shapedArrayWithUndefinedKey , ) {} }","title":"Array &amp; lists"},{"location":"usage/type-reference/#union","text":"final class SomeClass { public function __construct ( private int | string $simpleUnion , /** @var class-string<SomeInterface|AnotherInterface> */ private string $unionOfClassString , /** @var array<SomeInterface|AnotherInterface> */ private array $unionInsideArray , /** @var int|true */ private int | bool $unionWithLiteralTrueType ; /** @var int|false */ private int | bool $unionWithLiteralFalseType ; /** @var 404.42|1337.42 */ private float $unionOfFloatValues , /** @var 42|1337 */ private int $unionOfIntegerValues , /** @var 'foo'|'bar' */ private string $unionOfStringValues , ) {} }","title":"Union"},{"location":"usage/type-reference/#class-constants","text":"final class SomeClassWithConstants { public const FOO = 1337 ; public const BAR = 'bar' ; public const BAZ = 'baz' ; } final class SomeClass { public function __construct ( /** @var SomeClassWithConstants::FOO|SomeClassWithConstants::BAR */ private int | string $oneOfTwoCasesOfConstants , /** @param SomeClassWithConstants::BA* (matches `bar` or `baz`) */ private string $casesOfConstantsMatchingPattern , ) {} }","title":"Class constants"},{"location":"usage/type-reference/#enums","text":"enum SomeEnum { case FOO ; case BAR ; case BAZ ; } final class SomeClass { public function __construct ( private SomeEnum $enum , /** @var SomeEnum::FOO|SomeEnum::BAR */ private SomeEnum $oneOfTwoCasesOfEnum , /** @var SomeEnum::BA* (matches BAR or BAZ) */ private SomeEnum $casesOfEnumMatchingPattern , ) {} }","title":"Enums"},{"location":"usage/type-strictness-and-flexibility/","text":"Type strictness & flexibility \u00b6 The mapper is sensitive to the types of the data that is recursively populated \u2014 for instance a string \"42\" given to a node that expects an integer will make the mapping fail because the type is not strictly respected. Array keys that are not bound to any node are forbidden. Mapping an array ['foo' => \u2026, 'bar' => \u2026, 'baz' => \u2026] to an object that needs only foo and bar will fail, because baz is superfluous. The same rule applies for shaped arrays. When mapping to a list, the given array must have sequential integer keys starting at 0; if any gap or invalid key is found it will fail, like for instance trying to map ['foo' => 'foo', 'bar' => 'bar'] to list<string> . Types that are too permissive are not permitted \u2014 if the mapper encounters a type like mixed , object or array it will fail because those types are not precise enough. If these limitations are too restrictive, the mapper can be made more flexible to disable one or several rule(s) declared above. Enabling flexible casting \u00b6 This setting changes the behaviours explained below: $flexibleMapper = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> enableFlexibleCasting () -> mapper (); // --- // Scalar types will accept non-strict values; for instance an integer // type will accept any valid numeric value like the *string* \"42\". $flexibleMapper -> map ( 'int' , '42' ); // => 42 // --- // List type will accept non-incremental keys. $flexibleMapper -> map ( 'list<int>' , [ 'foo' => 42 , 'bar' => 1337 ]); // => [0 => 42, 1 => 1338] // --- // If a value is missing in a source for a node that accepts `null`, the // node will be filled with `null`. $flexibleMapper -> map ( 'array{foo: string, bar: null|string}' , [ 'foo' => 'foo' ] // `bar` is missing ); // => ['foo' => 'foo', 'bar' => null] // --- // Array and list types will convert `null` or missing values to an empty // array. $flexibleMapper -> map ( 'array{foo: string, bar: array<string>}' , [ 'foo' => 'foo' ] // `bar` is missing ); // => ['foo' => 'foo', 'bar' => []] Allowing superfluous keys \u00b6 With this setting enabled, superfluous keys in source arrays will be allowed, preventing errors when a value is not bound to any object property/parameter or shaped array element. ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> allowSuperfluousKeys () -> mapper () -> map ( 'array{foo: string, bar: int}' , [ 'foo' => 'foo' , 'bar' => 42 , 'baz' => 1337.404 , // `baz` will be ignored ] ); Allowing permissive types \u00b6 This setting allows permissive types mixed and object to be used during mapping. ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> allowPermissiveTypes () -> mapper () -> map ( 'array{foo: string, bar: mixed}' , [ 'foo' => 'foo' , 'bar' => 42 , // Could be any value ] );","title":"Type strictness & flexibility"},{"location":"usage/type-strictness-and-flexibility/#type-strictness-flexibility","text":"The mapper is sensitive to the types of the data that is recursively populated \u2014 for instance a string \"42\" given to a node that expects an integer will make the mapping fail because the type is not strictly respected. Array keys that are not bound to any node are forbidden. Mapping an array ['foo' => \u2026, 'bar' => \u2026, 'baz' => \u2026] to an object that needs only foo and bar will fail, because baz is superfluous. The same rule applies for shaped arrays. When mapping to a list, the given array must have sequential integer keys starting at 0; if any gap or invalid key is found it will fail, like for instance trying to map ['foo' => 'foo', 'bar' => 'bar'] to list<string> . Types that are too permissive are not permitted \u2014 if the mapper encounters a type like mixed , object or array it will fail because those types are not precise enough. If these limitations are too restrictive, the mapper can be made more flexible to disable one or several rule(s) declared above.","title":"Type strictness &amp; flexibility"},{"location":"usage/type-strictness-and-flexibility/#enabling-flexible-casting","text":"This setting changes the behaviours explained below: $flexibleMapper = ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> enableFlexibleCasting () -> mapper (); // --- // Scalar types will accept non-strict values; for instance an integer // type will accept any valid numeric value like the *string* \"42\". $flexibleMapper -> map ( 'int' , '42' ); // => 42 // --- // List type will accept non-incremental keys. $flexibleMapper -> map ( 'list<int>' , [ 'foo' => 42 , 'bar' => 1337 ]); // => [0 => 42, 1 => 1338] // --- // If a value is missing in a source for a node that accepts `null`, the // node will be filled with `null`. $flexibleMapper -> map ( 'array{foo: string, bar: null|string}' , [ 'foo' => 'foo' ] // `bar` is missing ); // => ['foo' => 'foo', 'bar' => null] // --- // Array and list types will convert `null` or missing values to an empty // array. $flexibleMapper -> map ( 'array{foo: string, bar: array<string>}' , [ 'foo' => 'foo' ] // `bar` is missing ); // => ['foo' => 'foo', 'bar' => []]","title":"Enabling flexible casting"},{"location":"usage/type-strictness-and-flexibility/#allowing-superfluous-keys","text":"With this setting enabled, superfluous keys in source arrays will be allowed, preventing errors when a value is not bound to any object property/parameter or shaped array element. ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> allowSuperfluousKeys () -> mapper () -> map ( 'array{foo: string, bar: int}' , [ 'foo' => 'foo' , 'bar' => 42 , 'baz' => 1337.404 , // `baz` will be ignored ] );","title":"Allowing superfluous keys"},{"location":"usage/type-strictness-and-flexibility/#allowing-permissive-types","text":"This setting allows permissive types mixed and object to be used during mapping. ( new \\CuyZ\\Valinor\\MapperBuilder ()) -> allowPermissiveTypes () -> mapper () -> map ( 'array{foo: string, bar: mixed}' , [ 'foo' => 'foo' , 'bar' => 42 , // Could be any value ] );","title":"Allowing permissive types"}]}