{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"","text":"\u2014 From boring old arrays to shiny typed objects \u2014 <p>Valinor takes care of the construction and validation of raw inputs (JSON, plain arrays, etc.) into objects, ensuring a perfectly valid state. It allows the  objects to be used without having to worry about their integrity during the  whole application lifecycle.</p> <p>The validation system will detect any incorrect value and help the developers by providing precise and human-readable error messages. </p> <p>The mapper can handle native PHP types as well as other advanced types supported by PHPStan and Psalm like shaped arrays, generics, integer ranges and more.</p>"},{"location":"#why","title":"Why?","text":"<p>There are many benefits of using objects instead of plain arrays in a codebase:</p> <ol> <li>Type safety \u2014 the structure of an object is known and guaranteed, no     need for type checks once the object is constructed.</li> <li>Data integrity \u2014 the object cannot be in an invalid state, it will always    contain valid data.</li> <li>Encapsulation \u2014 the logic of an object is isolated from the outside.</li> </ol>"},{"location":"#what-about-serialization","title":"What about serialization?","text":"<p>This library also provides a serialization system that can help transform a given input into a data format (JSON, CSV, \u2026), while preserving the original structure.</p> <p>You can find more information on this topic in the normalizer chapter.</p> <p>Validating and transforming raw data into an object can be achieved easily with  native PHP, but it requires a lot a boilerplate code.</p> <p>Below is a simple example of doing that without a mapper:</p> <pre><code>final class Person\n{\n    public readonly string $name;\n\n    public readonly DateTimeInterface $birthDate;\n}\n\n$data = $client-&gt;request('GET', 'https://example.com/person/42')-&gt;toArray();\n\nif (! isset($data['name']) || ! is_string($data['name'])) {\n    // Cumbersome error handling\n}\n\nif (! isset($data['birthDate']) || ! is_string($data['birthDate'])) {\n    // Another cumbersome error handling\n}\n\n$birthDate = DateTimeImmutable::createFromFormat('Y-m-d', $data['birthDate']);\n\nif (! $birthDate instanceof DateTimeInterface) {\n    // Yet another cumbersome error handling\n}\n\n$person = new Person($data['name'], $birthDate);\n</code></pre> <p>Using a mapper saves a lot of time and energy, especially on objects with a lot of properties:</p> <pre><code>$data = $client-&gt;request('GET', 'https://example.com/person/42')-&gt;toArray();\n\ntry {\n    $person = (new \\CuyZ\\Valinor\\MapperBuilder())\n        -&gt;mapper()\n        -&gt;map(Person::class, $data);\n} catch (\\CuyZ\\Valinor\\Mapper\\MappingError $error) {\n    // Detailed error handling\n}\n</code></pre> <p>This library provides advanced features for more complex cases, check out the next chapter to get started.</p>"},{"location":"getting-started/","title":"Getting started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<pre><code>composer require cuyz/valinor\n</code></pre>"},{"location":"getting-started/#example","title":"Example","text":"<p>An application must handle the data coming from an external API; the response has a JSON format and describes a thread and its answers. The validity of this input is unsure, besides manipulating a raw JSON string is laborious and inefficient.</p> <pre><code>{\n    \"id\": 1337,\n    \"content\": \"Do you like potatoes?\",\n    \"date\": \"1957-07-23 13:37:42\",\n    \"answers\": [\n        {\n            \"user\": \"Ella F.\",\n            \"message\": \"I like potatoes\",\n            \"date\": \"1957-07-31 15:28:12\"\n        },\n        {\n            \"user\": \"Louis A.\",\n            \"message\": \"And I like tomatoes\",\n            \"date\": \"1957-08-13 09:05:24\"\n        }\n    ]\n}\n</code></pre> <p>The application must be certain that it can handle this data correctly; wrapping the input in a value object will help.</p> <p>A schema representing the needed structure must be provided, using classes.</p> <pre><code>final class Thread\n{\n    public function __construct(\n        public readonly int $id,\n        public readonly string $content,\n        public readonly DateTimeInterface $date,\n        /** @var Answer[] */\n        public readonly array $answers, \n    ) {}\n}\n\nfinal class Answer\n{\n    public function __construct(\n        public readonly string $user,\n        public readonly string $message,\n        public readonly DateTimeInterface $date,\n    ) {}\n}\n</code></pre> <p>Then a mapper is used to hydrate a source into these objects.</p> <pre><code>public function getThread(int $id): Thread\n{\n    $rawJson = $this-&gt;client-&gt;request(\"https://example.com/thread/$id\");\n\n    try {   \n        return (new \\CuyZ\\Valinor\\MapperBuilder())\n            -&gt;mapper()\n            -&gt;map(\n                Thread::class,\n                new \\CuyZ\\Valinor\\Mapper\\Source\\JsonSource($rawJson)\n            );\n    } catch (\\CuyZ\\Valinor\\Mapper\\MappingError $error) {\n        // Do something\u2026\n    }\n}\n</code></pre>"},{"location":"getting-started/#mapping-advanced-types","title":"Mapping advanced types","text":"<p>Although it is recommended to map an input to a value object, in some cases mapping to another type can be easier/more flexible.</p> <p>It is for instance possible to map to an array of objects:</p> <pre><code>try {\n    $objects = (new \\CuyZ\\Valinor\\MapperBuilder())\n        -&gt;mapper()\n        -&gt;map(\n            'array&lt;' . SomeClass::class . '&gt;',\n            [/* \u2026 */]\n        );\n} catch (\\CuyZ\\Valinor\\Mapper\\MappingError $error) {\n    // Do something\u2026\n}\n</code></pre> <p>For simple use-cases, an array shape can be used:</p> <pre><code>try {\n    $array = (new \\CuyZ\\Valinor\\MapperBuilder())\n        -&gt;mapper()\n        -&gt;map(\n            'array{foo: string, bar: int}',\n            [/* \u2026 */]\n        );\n\n    echo $array['foo'];\n    echo $array['bar'] * 2;\n} catch (\\CuyZ\\Valinor\\Mapper\\MappingError $error) {\n    // Do something\u2026\n}\n</code></pre>"},{"location":"how-to/customize-error-messages/","title":"Customizing error messages","text":"<p>The content of a message can be changed to fit custom use cases; it can contain placeholders that will be replaced with useful information.</p> <p>The placeholders below are always available; even more may be used depending on the original message.</p> Placeholder Description <code>{message_code}</code> the code of the message <code>{node_name}</code> name of the node to which the message is bound <code>{node_path}</code> path of the node to which the message is bound <code>{node_type}</code> type of the node to which the message is bound <code>{source_value}</code> the source value that was given to the node <code>{original_message}</code> the original message before being customized <p>Usage:</p> <pre><code>try {\n    (new \\CuyZ\\Valinor\\MapperBuilder())\n        -&gt;mapper()\n        -&gt;map(SomeClass::class, [/* \u2026 */]);\n} catch (\\CuyZ\\Valinor\\Mapper\\MappingError $error) {\n    $messages = \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Messages::flattenFromNode(\n        $error-&gt;node()\n    );\n\n    foreach ($messages as $message) {\n        if ($message-&gt;code() === 'some_code') {\n            $message = $message\n                -&gt;withParameter('some_parameter', 'some custom value')\n                -&gt;withBody('new message / {message_code} / {some_parameter}');\n        }\n\n        // new message / some_code / some custom value\n        echo $message;\n    }\n}\n</code></pre> <p>The messages are formatted using the ICU library, enabling the placeholders to use advanced syntax to perform proper translations, for instance currency support.</p> <pre><code>try {\n    (new \\CuyZ\\Valinor\\MapperBuilder())-&gt;mapper()-&gt;map('int&lt;0, 100&gt;', 1337);\n} catch (\\CuyZ\\Valinor\\Mapper\\MappingError $error) {\n    $message = $error-&gt;node()-&gt;messages()[0];\n\n    if (is_numeric($message-&gt;node()-&gt;mappedValue())) {\n        $message = $message-&gt;withBody(\n            'Invalid amount {source_value, number, currency}'\n        );    \n    } \n\n    // Invalid amount: $1,337.00\n    echo $message-&gt;withLocale('en_US');\n\n    // Invalid amount: \u00a31,337.00\n    echo $message-&gt;withLocale('en_GB');\n\n    // Invalid amount: 1 337,00 \u20ac\n    echo $message-&gt;withLocale('fr_FR');\n}\n</code></pre> <p>See ICU documentation for more information on available syntax.</p> <p>Warning</p> <p>If the <code>intl</code> extension is not installed, a shim will be available to replace the placeholders, but it won't handle advanced syntax as described above.</p>"},{"location":"how-to/customize-error-messages/#deeper-message-customization-translation","title":"Deeper message customization / translation","text":"<p>For deeper message changes, formatters can be used to customize body and  parameters.</p> <p>Note</p> <p>Formatters can be added to messages</p>"},{"location":"how-to/customize-error-messages/#translation","title":"Translation","text":"<p>The formatter <code>TranslationMessageFormatter</code> can be used to translate the content of messages.</p> <p>The library provides a list of all messages that can be returned; this list can be filled or modified with custom translations.</p> <pre><code>\\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\TranslationMessageFormatter::default()\n    // Create/override a single entry\u2026\n    -&gt;withTranslation('fr', 'some custom message', 'un message personnalis\u00e9')\n    // \u2026or several entries.\n    -&gt;withTranslations([\n        'some custom message' =&gt; [\n            'en' =&gt; 'Some custom message',\n            'fr' =&gt; 'Un message personnalis\u00e9',\n            'es' =&gt; 'Un mensaje personalizado',\n        ], \n        'some other message' =&gt; [\n            // \u2026\n        ], \n    ])\n    -&gt;format($message);\n</code></pre>"},{"location":"how-to/customize-error-messages/#replacement-map","title":"Replacement map","text":"<p>The formatter <code>MessageMapFormatter</code> can be used to provide a list of messages replacements. It can be instantiated with an array where each key represents either:</p> <ul> <li>The code of the message to be replaced</li> <li>The body of the message to be replaced</li> <li>The class name of the message to be replaced</li> </ul> <p>If none of those is found, the content of the message will stay unchanged unless a default one is given to the class.</p> <p>If one of these keys is found, the array entry will be used to replace the content of the message. This entry can be either a plain text or a callable that takes the message as a parameter and returns a string; it is for instance advised to use a callable in cases where a custom translation service is used \u2014 to avoid useless greedy operations.</p> <p>In any case, the content can contain placeholders as described above.</p> <pre><code>(new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\MessageMapFormatter([\n    // Will match if the given message has this exact code\n    'some_code' =&gt; 'New content / code: {message_code}',\n\n    // Will match if the given message has this exact content\n    'Some message content' =&gt; 'New content / previous: {original_message}',\n\n    // Will match if the given message is an instance of `SomeError`\n    SomeError::class =&gt; 'New content / value: {source_value}',\n\n    // A callback can be used to get access to the message instance\n    OtherError::class =&gt; function (NodeMessage $message): string {\n        if ($message-&gt;path() === 'foo.bar') {\n            return 'Some custom message';\n        }\n\n        return $message-&gt;body();\n    },\n\n    // For greedy operation, it is advised to use a lazy-callback\n    'foo' =&gt; fn () =&gt; $this-&gt;customTranslator-&gt;translate('foo.bar'),\n]))\n    -&gt;defaultsTo('some default message')\n    // \u2026or\u2026\n    -&gt;defaultsTo(fn () =&gt; $this-&gt;customTranslator-&gt;translate('default_message'))\n    -&gt;format($message);\n</code></pre>"},{"location":"how-to/customize-error-messages/#several-formatters","title":"Several formatters","text":"<p>It is possible to join several formatters into one formatter by using the <code>AggregateMessageFormatter</code>. This instance can then easily be injected in a service that will handle messages.</p> <p>The formatters will be called in the same order they are given to the aggregate.</p> <pre><code>(new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\AggregateMessageFormatter(\n    new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\LocaleMessageFormatter('fr'),\n    new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\MessageMapFormatter([\n        // \u2026\n    ],\n    \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\TranslationMessageFormatter::default(),\n))-&gt;format($message)\n</code></pre>"},{"location":"how-to/deal-with-dates/","title":"Dealing with dates","text":"<p>When the mapper builds a date object, it has to know which format(s) are supported. By default, any valid timestamp or RFC 3339-formatted value will be accepted.</p> <p>If other formats are to be supported, they need to be registered using the following method:</p> <pre><code>(new \\CuyZ\\Valinor\\MapperBuilder())\n    // Both `Cookie` and `ATOM` formats will be accepted\n    -&gt;supportDateFormats(DATE_COOKIE, DATE_ATOM)\n    -&gt;mapper()\n    -&gt;map(DateTimeInterface::class, 'Monday, 08-Nov-1971 13:37:42 UTC');\n</code></pre>"},{"location":"how-to/deal-with-dates/#custom-date-class-implementation","title":"Custom date class implementation","text":"<p>By default, the library will map a <code>DateTimeInterface</code> to a <code>DateTimeImmutable</code> instance. If other implementations are to be supported, custom constructors can be used.</p> <p>Here is an implementation example for the nesbot/carbon library:</p> <pre><code>(new MapperBuilder())\n    // When the mapper meets a `DateTimeInterface` it will convert it to Carbon\n    -&gt;infer(DateTimeInterface::class, fn () =&gt; \\Carbon\\Carbon::class)\n\n    // We teach the mapper how to create a Carbon instance\n    -&gt;registerConstructor(function (string $time): \\Carbon\\Carbon {\n        // Only `Cookie` format will be accepted\n        return Carbon::createFromFormat(DATE_COOKIE, $time);\n    })\n\n    // Carbon uses its own exceptions, so we need to wrap it for the mapper\n    -&gt;filterExceptions(function (Throwable $exception) {\n        if ($exception instanceof \\Carbon\\Exceptions\\Exception) {\n            return \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\MessageBuilder::from($exception);\n        }\n\n        throw $exception;\n    })\n\n    -&gt;mapper()\n    -&gt;map(DateTimeInterface::class, 'Monday, 08-Nov-1971 13:37:42 UTC');\n</code></pre>"},{"location":"how-to/infer-interfaces/","title":"Inferring interfaces","text":"<p>When the mapper meets an interface, it needs to understand which implementation (a class that implements this interface) will be used \u2014 this information must be provided in the mapper builder, using the method <code>infer()</code>.</p> <p>The callback given to this method must return the name of a class that implements the interface. Any arguments can be required by the callback; they will be mapped properly using the given source.</p> <p>If the callback can return several class names, it needs to provide a return signature with the list of all class-strings that can be returned.</p> <pre><code>$mapper = (new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;infer(UuidInterface::class, fn () =&gt; MyUuid::class)\n    -&gt;infer(\n        SomeInterface::class, \n        /** @return class-string&lt;FirstImplementation|SecondImplementation&gt; */\n        fn (string $type) =&gt; match($type) {\n            'first' =&gt; FirstImplementation::class,\n            'second' =&gt; SecondImplementation::class,\n            default =&gt; throw new DomainException(\"Unhandled type `$type`.\")\n        }\n    )-&gt;mapper();\n\n// Will return an instance of `FirstImplementation`\n$mapper-&gt;map(SomeInterface::class, [\n    'type' =&gt; 'first',\n    'uuid' =&gt; 'a6868d61-acba-406d-bcff-30ecd8c0ceb6',\n    'someString' =&gt; 'foo',\n]);\n\n// Will return an instance of `SecondImplementation`\n$mapper-&gt;map(SomeInterface::class, [\n    'type' =&gt; 'second',\n    'uuid' =&gt; 'a6868d61-acba-406d-bcff-30ecd8c0ceb6',\n    'someInt' =&gt; 42,\n]);\n\ninterface SomeInterface {}\n\nfinal class FirstImplementation implements SomeInterface\n{\n    public readonly UuidInterface $uuid;\n\n    public readonly string $someString;\n}\n\nfinal class SecondImplementation implements SomeInterface\n{\n    public readonly UuidInterface $uuid;\n\n    public readonly int $someInt;\n}\n</code></pre>"},{"location":"how-to/infer-interfaces/#inferring-classes","title":"Inferring classes","text":"<p>The same mechanics can be applied to infer abstract or parent classes.</p> <p>Example with an abstract class:</p> <pre><code>abstract class SomeAbstractClass\n{\n    public string $foo;\n\n    public string $bar;\n}\n\nfinal class SomeChildClass extends SomeAbstractClass\n{\n    public string $baz;\n}\n\n$result = (new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;infer(\n        SomeAbstractClass::class, \n        fn () =&gt; SomeChildClass::class\n    )\n    -&gt;mapper()\n    -&gt;map(SomeAbstractClass::class, [\n        'foo' =&gt; 'foo',\n        'bar' =&gt; 'bar',\n        'baz' =&gt; 'baz',\n    ]);\n\nassert($result instanceof SomeChildClass);\nassert($result-&gt;foo === 'foo');\nassert($result-&gt;bar === 'bar');\nassert($result-&gt;baz === 'baz');\n</code></pre> <p>Example with inheritance:</p> <pre><code>class SomeParentClass\n{\n    public string $foo;\n\n    public string $bar;\n}\n\nfinal class SomeChildClass extends SomeParentClass\n{\n    public string $baz;\n}\n\n$result = (new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;infer(\n        SomeParentClass::class, \n        fn () =&gt; SomeChildClass::class\n    )\n    -&gt;mapper()\n    -&gt;map(SomeParentClass::class, [\n        'foo' =&gt; 'foo',\n        'bar' =&gt; 'bar',\n        'baz' =&gt; 'baz',\n    ]);\n\nassert($result instanceof SomeChildClass);\nassert($result-&gt;foo === 'foo');\nassert($result-&gt;bar === 'bar');\nassert($result-&gt;baz === 'baz');\n</code></pre>"},{"location":"how-to/map-arguments-of-a-callable/","title":"Mapping arguments of a callable","text":"<p>This library can map the arguments of a callable; it can be used to ensure a source has the right shape before calling a function/method.</p> <p>The mapper builder can be configured the same way it would be with a tree  mapper, for instance to customize the type strictness.</p> <pre><code>$someFunction = function(string $foo, int $bar): string {\n    return \"$foo / $bar\";\n}\n\ntry {\n    $arguments = (new \\CuyZ\\Valinor\\MapperBuilder())\n        -&gt;argumentsMapper()\n        -&gt;mapArguments($someFunction, [\n            'foo' =&gt; 'some value',\n            'bar' =&gt; 42,\n        ]);\n\n    // some value / 42\n    echo $someFunction(...$arguments);\n} catch (\\CuyZ\\Valinor\\Mapper\\MappingError $error) {\n    // Do something\u2026\n}\n</code></pre> <p>Any callable can be given to the arguments mapper:</p> <pre><code>final class SomeController\n{\n    public static function someAction(string $foo, int $bar): string\n    {\n        return \"$foo / $bar\";\n    }\n}\n\ntry {\n    $arguments = (new \\CuyZ\\Valinor\\MapperBuilder())\n        -&gt;argumentsMapper()\n        -&gt;mapArguments(SomeController::someAction(...), [\n            'foo' =&gt; 'some value',\n            'bar' =&gt; 42,\n        ]);\n\n    // some value / 42\n    echo SomeController::someAction(...$arguments);\n} catch (\\CuyZ\\Valinor\\Mapper\\MappingError $error) {\n    // Do something\u2026\n}\n</code></pre>"},{"location":"how-to/transform-input/","title":"Transforming input","text":"<p>Any source can be given to the mapper, be it an array, some JSON, YAML or even a file:</p> <pre><code>$mapper = (new \\CuyZ\\Valinor\\MapperBuilder())-&gt;mapper();\n\n$mapper-&gt;map(\n    SomeClass::class,\n    \\CuyZ\\Valinor\\Mapper\\Source\\Source::array($someData)\n);\n\n$mapper-&gt;map(\n    SomeClass::class,\n    \\CuyZ\\Valinor\\Mapper\\Source\\Source::json($jsonString)\n);\n\n$mapper-&gt;map(\n    SomeClass::class,\n    \\CuyZ\\Valinor\\Mapper\\Source\\Source::yaml($yamlString)\n);\n\n$mapper-&gt;map(\n    SomeClass::class,\n    // File containing valid Json or Yaml content and with valid extension\n    \\CuyZ\\Valinor\\Mapper\\Source\\Source::file(\n        new SplFileObject('path/to/my/file.json')\n    )\n);\n</code></pre> <p>Info</p> <p>JSON or YAML given to a source may be invalid, in which case an exception  can be caught and manipulated.</p> <pre><code>try {\n    $source = \\CuyZ\\Valinor\\Mapper\\Source\\Source::json('invalid JSON');\n} catch (\\CuyZ\\Valinor\\Mapper\\Source\\Exception\\InvalidSource $exception) {\n    // Let the application handle the exception in the desired way.\n    // It is possible to get the original source with `$exception-&gt;source()`\n}\n</code></pre>"},{"location":"how-to/transform-input/#modifiers","title":"Modifiers","text":"<p>Sometimes the source is not in the same format and/or organised in the same way as a value object. Modifiers can be used to change a source before the mapping occurs.</p>"},{"location":"how-to/transform-input/#camel-case-keys","title":"Camel case keys","text":"<p>This modifier recursively forces all keys to be in camelCase format.</p> <pre><code>final class SomeClass\n{\n    public readonly string $someValue;\n}\n\n$source = \\CuyZ\\Valinor\\Mapper\\Source\\Source::array([\n        'some_value' =&gt; 'foo',\n        // \u2026or\u2026\n        'some-value' =&gt; 'foo',\n        // \u2026or\u2026\n        'some value' =&gt; 'foo',\n        // \u2026will be replaced by `['someValue' =&gt; 'foo']`\n    ])\n    -&gt;camelCaseKeys();\n\n(new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;mapper()\n    -&gt;map(SomeClass::class, $source);\n</code></pre>"},{"location":"how-to/transform-input/#path-mapping","title":"Path mapping","text":"<p>This modifier can be used to change paths in the source data using a dot notation.</p> <p>The mapping is done using an associative array of path mappings. This array must have the source path as key and the target path as value.</p> <p>The source path uses the dot notation (eg <code>A.B.C</code>) and can contain one <code>*</code> for array paths (eg <code>A.B.*.C</code>).</p> <pre><code>final class Country\n{\n    /** @var non-empty-string */\n    public readonly string $name;\n\n    /** @var list&lt;City&gt; */\n    public readonly array $cities;\n}\n\nfinal class City\n{\n    /** @var non-empty-string */\n    public readonly string $name;\n\n    public readonly DateTimeZone $timeZone;\n}\n\n$source = \\CuyZ\\Valinor\\Mapper\\Source\\Source::array([\n    'identification' =&gt; 'France',\n    'towns' =&gt; [\n        [\n            'label' =&gt; 'Paris',\n            'timeZone' =&gt; 'Europe/Paris',\n        ],\n        [\n            'label' =&gt; 'Lyon',\n            'timeZone' =&gt; 'Europe/Paris',\n        ],\n    ],\n])-&gt;map([\n    'identification' =&gt; 'name',\n    'towns' =&gt; 'cities',\n    'towns.*.label' =&gt; 'name',\n]);\n\n// After modification this is what the source will look like:\n// [\n//     'name' =&gt; 'France',\n//     'cities' =&gt; [\n//         [\n//             'name' =&gt; 'Paris',\n//             'timeZone' =&gt; 'Europe/Paris',\n//         ],\n//         [\n//             'name' =&gt; 'Lyon',\n//             'timeZone' =&gt; 'Europe/Paris',\n//         ],\n//     ],\n// ];\n\n(new \\CuyZ\\Valinor\\MapperBuilder())-&gt;mapper()-&gt;map(Country::class, $source);\n</code></pre>"},{"location":"how-to/transform-input/#custom-source","title":"Custom source","text":"<p>The source is just an iterable, so it's easy to create a custom one. It can even be combined with the provided builder.</p> <pre><code>final class AcmeSource implements IteratorAggregate\n{\n    private iterable $source;\n\n    public function __construct(iterable $source)\n    {\n        $this-&gt;source = $this-&gt;doSomething($source);\n    }\n\n    private function doSomething(iterable $source): iterable\n    {\n        // Do something with $source\n\n        return $source;\n    }\n\n    public function getIterator()\n    {\n        yield from $this-&gt;source;\n    }\n}\n\n$source = \\CuyZ\\Valinor\\Mapper\\Source\\Source::iterable(\n    new AcmeSource([\n        'valueA' =&gt; 'foo',\n        'valueB' =&gt; 'bar',\n    ])\n)-&gt;camelCaseKeys();\n\n(new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;mapper()\n    -&gt;map(SomeClass::class, $source);\n</code></pre>"},{"location":"how-to/use-custom-object-constructors/","title":"Using custom object constructors","text":"<p>An object may have custom ways of being created, in such cases these constructors need to be registered to the mapper to be used. A constructor is a callable that can be either:</p> <ol> <li>A named constructor, also known as a static factory method</li> <li>The method of a service \u2014 for instance a repository</li> <li>A \"callable object\" \u2014 a class that declares an <code>__invoke</code> method</li> <li>Any other callable \u2014 including anonymous functions</li> </ol> <p>In any case, the return type of the callable will be resolved by the mapper to know when to use it. Any argument can be provided and will automatically be mapped using the given source. These arguments can then be used to instantiate the object in the desired way.</p> <p>Registering any constructor will disable the native constructor \u2014 the <code>__construct</code> method \u2014 of the targeted class. If for some reason it still needs to be handled as well, the name of the class must be given to the registration method.</p> <p>If several constructors are registered, they must provide distinct signatures to prevent collision during mapping \u2014 meaning that if two constructors require several arguments with the exact same names, the mapping will fail.</p> <pre><code>(new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;registerConstructor(\n        // Allow the native constructor to be used\n        Color::class,\n\n        // Register a named constructor (1)\n        Color::fromHex(...),\n\n        /**\n         * An anonymous function can also be used, for instance when the desired\n         * object is an external dependency that cannot be modified.\n         * \n         * @param 'red'|'green'|'blue' $color\n         * @param 'dark'|'light' $darkness\n         */\n        function (string $color, string $darkness): Color {\n            $main = $darkness === 'dark' ? 128 : 255;\n            $other = $darkness === 'dark' ? 0 : 128;\n\n            return new Color(\n                $color === 'red' ? $main : $other,\n                $color === 'green' ? $main : $other,\n                $color === 'blue' ? $main : $other,\n            );\n        }\n    )\n    -&gt;mapper()\n    -&gt;map(Color::class, [/* \u2026 */]);\n\nfinal class Color\n{\n    /**\n     * @param int&lt;0, 255&gt; $red\n     * @param int&lt;0, 255&gt; $green\n     * @param int&lt;0, 255&gt; $blue\n     */\n    public function __construct(\n        public readonly int $red,\n        public readonly int $green,\n        public readonly int $blue\n    ) {}\n\n    /**\n     * @param non-empty-string $hex\n     */\n    public static function fromHex(string $hex): self\n    {\n        if (strlen($hex) !== 6) {\n            throw new DomainException('Must be 6 characters long');\n        }\n\n        /** @var int&lt;0, 255&gt; $red */\n        $red = hexdec(substr($hex, 0, 2));\n        /** @var int&lt;0, 255&gt; $green */\n        $green = hexdec(substr($hex, 2, 2));\n        /** @var int&lt;0, 255&gt; $blue */\n        $blue = hexdec(substr($hex, 4, 2));\n\n        return new self($red, $green, $blue);\n    }\n}\n</code></pre> <ol> <li> <p>\u2026or for PHP &lt; 8.1:</p> <pre><code>[Color::class, 'fromHex'],\n</code></pre> </li> </ol>"},{"location":"how-to/use-custom-object-constructors/#custom-enum-constructor","title":"Custom enum constructor","text":"<p>Registering a constructor for an enum works the same way as for a class, as described above.</p> <pre><code>(new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;registerConstructor(\n        // Allow the native constructor to be used\n        SomeEnum::class,\n\n        // Register a named constructor\n        SomeEnum::fromMatrix(...)\n    )\n    -&gt;mapper()\n    -&gt;map(SomeEnum::class, [\n        'type' =&gt; 'FOO',\n        'number' =&gt; 2,\n    ]);\n\nenum SomeEnum: string\n{\n    case CASE_A = 'FOO_VALUE_1';\n    case CASE_B = 'FOO_VALUE_2';\n    case CASE_C = 'BAR_VALUE_1';\n    case CASE_D = 'BAR_VALUE_2';\n\n    /**\n     * @param 'FOO'|'BAR' $type\n     * @param int&lt;1, 2&gt; $number\n     */\n    public static function fromMatrix(string $type, int $number): self\n    {\n        return self::from(\"{$type}_VALUE_{$number}\");\n    }\n}\n</code></pre> <p>Note</p> <p>An enum constructor can be for a specific pattern:</p> <pre><code>enum SomeEnum\n{\n    case FOO;\n    case BAR;\n    case BAZ;\n}\n\n(new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;registerConstructor(\n        /**\n         * This constructor will be called only when pattern `SomeEnum::BA*`\n         * is requested during mapping.\n         * \n         * @return SomeEnum::BA*\n         */\n        fn (string $value): SomeEnum =&gt; /* Some custom domain logic */\n    )\n    -&gt;mapper()\n    -&gt;map(SomeEnum::class . '::BA*', 'some custom value');\n</code></pre>"},{"location":"how-to/use-custom-object-constructors/#dynamic-constructors","title":"Dynamic constructors","text":"<p>In some situations the type handled by a constructor is only known at runtime, in which case the constructor needs to know what class must be used to instantiate the object.</p> <p>For instance, an interface may declare a static constructor that is then implemented by several child classes. One solution would be to register the constructor for each child class, which leads to a lot of boilerplate code and would require a new registration each time a new child is created. Another way is to use the attribute <code>\\CuyZ\\Valinor\\Mapper\\Object\\DynamicConstructor</code>.</p> <p>When a constructor uses this attribute, its first parameter must be a string and will be filled with the name of the actual class that the mapper needs to build when the constructor is called. Other arguments may be added and will be mapped normally, depending on the source given to the mapper.</p> <pre><code>interface InterfaceWithStaticConstructor\n{\n    public static function from(string $value): self;\n}\n\nfinal class ClassWithInheritedStaticConstructor implements InterfaceWithStaticConstructor\n{\n    private function __construct(private SomeValueObject $value) {}\n\n    public static function from(string $value): self\n    {\n        return new self(new SomeValueObject($value));\n    }\n}\n\n(new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;registerConstructor(\n        #[\\CuyZ\\Valinor\\Attribute\\DynamicConstructor]\n        function (string $className, string $value): InterfaceWithStaticConstructor {\n            return $className::from($value);\n        }\n    )\n    -&gt;mapper()\n    -&gt;map(ClassWithInheritedStaticConstructor::class, 'foo');\n</code></pre>"},{"location":"other/app-and-framework-integration/","title":"Application and framework integration","text":"<p>This library is framework-agnostic, but using it in an application that relies on a framework is still possible.</p> <p>For Symfony applications, check out the chapter below. For other frameworks, check out the custom integration chapter.</p>"},{"location":"other/app-and-framework-integration/#symfony-bundle","title":"Symfony bundle","text":"<p>A bundle is available to automatically integrate this library into a Symfony application.</p> <pre><code>composer require cuyz/valinor-bundle\n</code></pre> <p>The documentation of this bundle can be found on the GitHub repository.</p>"},{"location":"other/app-and-framework-integration/#custom-integration","title":"Custom integration","text":"<p>If the application does not have a dedicated framework integration, it is still possible to integrate this library manually.</p>"},{"location":"other/app-and-framework-integration/#mapper-registration","title":"Mapper registration","text":"<p>The most important task of the integration is to correctly register the mapper(s) used in the application. Mapper instance(s) should be shared between services whenever possible; this is important because heavy operations are cached internally to improve performance during runtime.</p> <p>If the framework uses a service container, it should be configured in a way where the mapper(s) are registered as shared services. In other cases, direct instantiation of the mapper(s) should be avoided.</p> <pre><code>$mapperBuilder = new \\CuyZ\\Valinor\\MapperBuilder();\n\n// \u2026customization of the mapper builder\u2026\n\n$container-&gt;addSharedService('mapper', $mapperBuilder-&gt;mapper());\n</code></pre>"},{"location":"other/app-and-framework-integration/#registering-a-cache","title":"Registering a cache","text":"<p>As mentioned above, caching is important to allow the mapper to perform well. The application really should provide a cache implementation to the mapper builder.</p> <p>As stated in the performance chapter, the library provides a cache implementation out of the box which can be used in any application. Custom cache can be used as well, as long as it is PSR-16 compliant.</p> <pre><code>$cache = new \\CuyZ\\Valinor\\Cache\\FileSystemCache('path/to/cache-directory');\n\n// If the application can detect when it is in development environment, it is\n// advised to wrap the cache with a `FileWatchingCache` instance, to avoid\n// having to manually clear the cache when a file changes during development.\nif ($isApplicationInDevelopmentEnvironment) {\n    $cache = new \\CuyZ\\Valinor\\Cache\\FileWatchingCache($cache);\n}\n\n$mapperBuilder = $mapperBuilder-&gt;withCache($cache);\n</code></pre>"},{"location":"other/app-and-framework-integration/#warming-up-the-cache","title":"Warming up the cache","text":"<p>The cache can be warmed up to ease the application cold start. If the framework has a way to automatically detect which classes will be used by the mapper, they should be given to the <code>warmup</code> method, as stated in the cache warmup chapter.</p>"},{"location":"other/app-and-framework-integration/#other-configurations","title":"Other configurations","text":"<p>Concerning other configurations, such as enabling flexible casting, configuring supported date formats or registering custom constructors, an integration should be provided to configure the mapper builder in a convenient way \u2014 how it is done will mostly depend on the framework features and its main philosophy.</p>"},{"location":"other/performance-and-caching/","title":"Performance &amp; caching","text":"<p>This library needs to parse a lot of information in order to handle all provided features. Therefore, it is strongly advised to activate the cache to reduce heavy workload between runtimes, especially when the application runs in a production environment.</p> <p>The library provides a cache implementation out of the box, which saves cache entries into the file system.</p> <p>Note</p> <p>It is also possible to use any PSR-16 compliant implementation, as long as it is capable of caching the entries handled by the library.</p> <p>When the application runs in a development environment, the cache implementation should be decorated with <code>FileWatchingCache</code>, which will watch the files of the application and invalidate cache entries when a PHP file is modified by a developer \u2014 preventing the library not behaving as expected when the signature of a property or a method changes.</p> <pre><code>$cache = new \\CuyZ\\Valinor\\Cache\\FileSystemCache('path/to/cache-directory');\n\nif ($isApplicationInDevelopmentEnvironment) {\n    $cache = new \\CuyZ\\Valinor\\Cache\\FileWatchingCache($cache);\n}\n\n(new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;withCache($cache)\n    -&gt;mapper()\n    -&gt;map(SomeClass::class, [/* \u2026 */]);\n</code></pre>"},{"location":"other/performance-and-caching/#warming-up-cache","title":"Warming up cache","text":"<p>The cache can be warmed up, for instance in a pipeline during the build and deployment of the application.</p> <p>Note</p> <p>The cache has to be registered first, otherwise the warmup will end up being useless.</p> <pre><code>$cache = new \\CuyZ\\Valinor\\Cache\\FileSystemCache('path/to/cache-dir');\n\n$mapperBuilder = (new \\CuyZ\\Valinor\\MapperBuilder())-&gt;withCache($cache);\n\n// During the build:\n$mapperBuilder-&gt;warmup(SomeClass::class, SomeOtherClass::class);\n\n// In the application:\n$mapper-&gt;mapper()-&gt;map(SomeClass::class, [/* \u2026 */]);\n</code></pre>"},{"location":"other/static-analysis/","title":"Static analysis","text":"<p>To help static analysis of a codebase using this library, an extension for PHPStan and a plugin for Psalm are provided. They enable these tools to better understand the behaviour of the mapper.</p> <p>Note</p> <p>To activate this feature, the plugin must be registered correctly:</p> PHPStanPsalm phpstan.neon<pre><code>includes:\n    - vendor/cuyz/valinor/qa/PHPStan/valinor-phpstan-configuration.php\n</code></pre> composer.json<pre><code>\"autoload-dev\": {\n    \"files\": [\n        \"vendor/cuyz/valinor/qa/Psalm/ValinorPsalmPlugin.php\"\n    ]\n}\n</code></pre> psalm.xml<pre><code>&lt;plugins&gt;\n    &lt;pluginClass class=\"CuyZ\\Valinor\\QA\\Psalm\\ValinorPsalmPlugin\"/&gt;\n&lt;/plugins&gt;\n</code></pre> <p>Considering at least one of those tools are installed on a project, below are examples of the kind of errors that would be reported.</p> <p>Mapping to an array of classes</p> <pre><code>final class SomeClass\n{\n    public function __construct(\n        public readonly string $foo,\n        public readonly int $bar,\n    ) {}\n}\n\n$objects = (new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;mapper()\n    -&gt;map(\n        'array&lt;' . SomeClass::class . '&gt;',\n        [/* \u2026 */]\n    );\n\nforeach ($objects as $object) {\n    // \u2705\n    echo $object-&gt;foo;\n\n    // \u2705\n    echo $object-&gt;bar * 2;\n\n    // \u274c Cannot perform operation between `string` and `int`\n    echo $object-&gt;foo * $object-&gt;bar;\n\n    // \u274c Property `SomeClass::$fiz` is not defined\n    echo $object-&gt;fiz;\n}\n</code></pre> <p>Mapping to a shaped array</p> <pre><code>$array = (new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;mapper()\n    -&gt;map(\n        'array{foo: string, bar: int}',\n        [/* \u2026 */]\n    );\n\n// \u2705\necho $array['foo'];\n\n// \u274c Expected `string` but got `int`\necho strtolower($array['bar']);\n\n// \u274c Cannot perform operation between `string` and `int`\necho $array['foo'] * $array['bar'];\n\n// \u274c Offset `fiz` does not exist on array\necho $array['fiz']; \n</code></pre> <p>Mapping arguments of a callable</p> <pre><code>$someFunction = function(string $foo, int $bar): string {\n    return \"$foo / $bar\";\n};\n\n$arguments = (new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;argumentsMapper()\n    -&gt;mapArguments($someFunction, [\n        'foo' =&gt; 'some value',\n        'bar' =&gt; 42,\n    ]);\n\n// \u2705 Arguments have a correct shape, no error reported\necho $someFunction(...$arguments);\n</code></pre>"},{"location":"project/alternatives/","title":"Alternatives to this library","text":"<p>Mapping and hydration have been available in the PHP world for a long time. This library aims to bring powerful features to this aspect, some of which are missing in similar packages:</p> <ul> <li>Objects have a valid state when mapping is over.</li> <li>Validation is recursively applied on the input during mapping, reported    error messages bring clarity to missing or invalid values.  </li> <li>Type declaration follow community standards developed by popular packages,    meaning that advanced types like <code>list&lt;string&gt;</code>, <code>non-empty-string</code>,    <code>positive-int</code>, <code>int&lt;0, 42&gt;</code>, shaped arrays, generic classes and more are    handled and validated properly.</li> <li>The mapper can be flexible, allowing for instance type casting when needed.</li> <li>Mapped objects should not rely on inheritance.</li> </ul> <p>You may take a look at alternative projects, but some features listed above might be missing:</p> <ul> <li><code>symfony/serializer</code></li> <li><code>eventsauce/object-hydrator</code></li> <li><code>crell/serde</code></li> <li><code>spatie/laravel-data</code></li> <li><code>jms/serializer</code></li> <li><code>netresearch/jsonmapper</code></li> <li><code>json-mapper/json-mapper</code></li> <li><code>brick/json-mapper</code></li> </ul>"},{"location":"project/changelog/","title":"Changelog","text":"<p>Below are listed the changelogs for all released versions of the library.</p>"},{"location":"project/changelog/#version-1","title":"Version 1","text":"<ul> <li><code>1.8.2</code> \u2014 8th of January 2024</li> <li><code>1.8.1</code> \u2014 8th of January 2024</li> <li><code>1.8.0</code> \u2014 26th of December 2023</li> <li><code>1.7.0</code> \u2014 23rd of October 2023</li> <li><code>1.6.1</code> \u2014 11th of October 2023</li> <li><code>1.6.0</code> \u2014 25th of August 2023</li> <li><code>1.5.0</code> \u2014 7th of August 2023</li> <li><code>1.4.0</code> \u2014 17th of April 2023</li> <li><code>1.3.1</code> \u2014 13th of February 2023</li> <li><code>1.3.0</code> \u2014 8th of February 2023</li> <li><code>1.2.0</code> \u2014 9th of January 2023</li> <li><code>1.1.0</code> \u2014 20th of December 2022</li> <li><code>1.0.0</code> \u2014 28th of November 2022</li> </ul>"},{"location":"project/changelog/#development-phase","title":"Development phase","text":"<ul> <li><code>0.17.0</code> \u2014 8th of November 2022</li> <li><code>0.16.0</code> \u2014 19th of October 2022</li> <li><code>0.15.0</code> \u2014 6th of October 2022</li> <li><code>0.14.0</code> \u2014 1st of September 2022</li> <li><code>0.13.0</code> \u2014 31st of July 2022</li> <li><code>0.12.0</code> \u2014 10th of July 2022</li> <li><code>0.11.0</code> \u2014 23rd of June 2022</li> <li><code>0.10.0</code> \u2014 10th of June 2022</li> <li><code>0.9.0</code> \u2014 23rd of May 2022</li> <li><code>0.8.0</code> \u2014 9th of May 2022</li> <li><code>0.7.0</code> \u2014 24th of March 2022</li> <li><code>0.6.0</code> \u2014 24th of February 2022</li> <li><code>0.5.0</code> \u2014 21st of January 2022</li> <li><code>0.4.0</code> \u2014 7th of January 2022</li> <li><code>0.3.0</code> \u2014 18th of December 2021</li> <li><code>0.2.0</code> \u2014 7th of December 2021</li> <li><code>0.1.1</code> \u2014 1st of December 2021</li> </ul>"},{"location":"project/credits/","title":"Credits &amp; thank you","text":"<p>The development of this library is mainly motivated by the kind words and the help of many people. I am grateful to everyone, especially to the contributors of this repository who directly help to push the project forward.</p> <p>I have to give JetBrains credits for providing a free   PhpStorm license for the development of this open-source package.</p> <p>I also want to thank  Blackfire for providing a license of their awesome tool, leading to notable performance gains when using this library.</p>"},{"location":"project/changelog/version-0.1.1/","title":"Changelog 0.1.1 \u2014 1st of December 2021","text":"<p>See release on GitHub</p>"},{"location":"project/changelog/version-0.1.1/#breaking-changes","title":"\u26a0 BREAKING CHANGES","text":"<ul> <li>Change license from GPL 3 to MIT (a77b28)</li> </ul>"},{"location":"project/changelog/version-0.1.1/#features","title":"Features","text":"<ul> <li>Handle multiline type declaration (d99c59)</li> </ul>"},{"location":"project/changelog/version-0.1.1/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Filter type symbols with strict string comparison (6cdea3)</li> <li>Handle correctly iterable source during mapping (dd4624)</li> <li>Handle shaped array integer key (5561d0)</li> <li>Resolve single/double quotes when parsing doc-block type (1c628b)</li> </ul>"},{"location":"project/changelog/version-0.1.1/#other","title":"Other","text":"<ul> <li>Change PHPStan stub file extension (8fc6af)</li> <li>Delete unwanted code (e3e169)</li> <li>Syntax highlight stub files (#9) (9ea95f)</li> <li>Use composer runtime API (1f754a)</li> </ul>"},{"location":"project/changelog/version-0.10.0/","title":"Changelog 0.10.0 \u2014 10th of June 2022","text":"<p>See release on GitHub</p>"},{"location":"project/changelog/version-0.10.0/#notable-changes","title":"Notable changes","text":"<p>Documentation is now available at valinor.cuyz.io.</p>"},{"location":"project/changelog/version-0.10.0/#features","title":"Features","text":"<ul> <li>Support mapping to dates with no time (e0a529)</li> </ul>"},{"location":"project/changelog/version-0.10.0/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Allow declaring promoted parameter type with <code>@var</code> annotation (d8eb4d)</li> <li>Allow mapping iterable to shaped array (628baf)</li> </ul>"},{"location":"project/changelog/version-0.11.0/","title":"Changelog 0.11.0 \u2014 23rd of June 2022","text":"<p>See release on GitHub</p>"},{"location":"project/changelog/version-0.11.0/#notable-changes","title":"Notable changes","text":"<p>Strict mode</p> <p>The mapper is now more type-sensitive and will fail in the following situations:</p> <ul> <li> <p>When a value does not match exactly the awaited scalar type, for instance a   string <code>\"42\"</code> given to a node that awaits an integer.</p> </li> <li> <p>When unnecessary array keys are present, for instance mapping an array   <code>['foo' =&gt; \u2026, 'bar' =&gt; \u2026, 'baz' =&gt; \u2026]</code> to an object that needs only <code>foo</code> and   <code>bar</code>.</p> </li> <li> <p>When permissive types like <code>mixed</code> or <code>object</code> are encountered.</p> </li> </ul> <p>These limitations can be bypassed by enabling the flexible mode:</p> <pre><code>(new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;flexible()\n    -&gt;mapper();\n    -&gt;map('array{foo: int, bar: bool}', [\n        'foo' =&gt; '42', // Will be cast from `string` to `int`\n        'bar' =&gt; 'true', // Will be cast from `string` to `bool`\n        'baz' =&gt; '\u2026', // Will be ignored\n    ]);\n</code></pre> <p>When using this library for a provider application \u2014 for instance an API  endpoint that can be called with a JSON payload \u2014 it is recommended to use the strict mode. This ensures that the consumers of the API provide the exact  awaited data structure, and prevents unknown values to be passed.</p> <p>When using this library as a consumer of an external source, it can make sense to enable the flexible mode. This allows for instance to convert string numeric  values to integers or to ignore data that is present in the source but not needed in the application.</p> <p>Interface inferring</p> <p>It is now mandatory to list all possible class-types that can be inferred by the mapper. This change is a step towards the library being able to deliver powerful  new features such as compiling a mapper for better performance.</p> <p>The existing calls to <code>MapperBuilder::infer</code> that could return several  class-names must now add a signature to the callback. The callbacks that require no parameter and always return the same class-name can remain unchanged.</p> <p>For instance:</p> <pre><code>$builder = (new \\CuyZ\\Valinor\\MapperBuilder())\n    // Can remain unchanged\n    -&gt;infer(SomeInterface::class, fn () =&gt; SomeImplementation::class);\n</code></pre> <pre><code>$builder = (new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;infer(\n        SomeInterface::class,\n        fn (string $type) =&gt; match($type) {\n            'first' =&gt; ImplementationA::class,\n            'second' =&gt; ImplementationB::class,\n            default =&gt; throw new DomainException(\"Unhandled `$type`.\")\n        }\n    )\n    // \u2026should be modified with:\n    -&gt;infer(\n        SomeInterface::class,\n        /** @return class-string&lt;ImplementationA|ImplementationB&gt; */\n        fn (string $type) =&gt; match($type) {\n            'first' =&gt; ImplementationA::class,\n            'second' =&gt; ImplementationB::class,\n            default =&gt; throw new DomainException(\"Unhandled `$type`.\")\n        }\n    );\n</code></pre> <p>Object constructors collision</p> <p>All these changes led to a new check that runs on all registered object  constructors. If a collision is found between several constructors that have the same signature (the same parameter names), an exception will be thrown.</p> <pre><code>final class SomeClass\n{\n    public static function constructorA(string $foo, string $bar): self\n    {\n        // \u2026\n    }\n\n    public static function constructorB(string $foo, string $bar): self\n    {\n        // \u2026\n    }\n}\n\n(new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;registerConstructor(\n        SomeClass::constructorA(...),\n        SomeClass::constructorB(...),\n    )\n    -&gt;mapper();\n    -&gt;map(SomeClass::class, [\n        'foo' =&gt; 'foo',\n        'bar' =&gt; 'bar',\n    ]);\n\n// Exception: A collision was detected [\u2026]\n</code></pre>"},{"location":"project/changelog/version-0.11.0/#breaking-changes","title":"\u26a0 BREAKING CHANGES","text":"<ul> <li>Handle exhaustive list of interface inferring (1b0ff3)</li> <li>Make mapper more strict and allow flexible mode (90dc58)</li> </ul>"},{"location":"project/changelog/version-0.11.0/#features","title":"Features","text":"<ul> <li>Improve cache warmup (44c5f1)</li> </ul>"},{"location":"project/changelog/version-0.12.0/","title":"Changelog 0.12.0 \u2014 10th of July 2022","text":"<p>See release on GitHub</p>"},{"location":"project/changelog/version-0.12.0/#notable-changes","title":"Notable changes","text":"<p>SECURITY \u2014 Userland exception filtering</p> <p>See advisory GHSA-5pgm-3j3g-2rc7 for more information.</p> <p>Userland exception thrown in a constructor will not be automatically caught by the mapper anymore. This prevents messages with sensible information from  reaching the final user \u2014 for instance an SQL exception showing a part of a  query.</p> <p>To allow exceptions to be considered as safe, the new method <code>MapperBuilder::filterExceptions()</code> must be used, with caution.</p> <pre><code>final class SomeClass\n{\n    public function __construct(private string $value)\n    {\n        \\Webmozart\\Assert\\Assert::startsWith($value, 'foo_');\n    }\n}\n\ntry {\n    (new \\CuyZ\\Valinor\\MapperBuilder())\n        -&gt;filterExceptions(function (Throwable $exception) {\n            if ($exception instanceof \\Webmozart\\Assert\\InvalidArgumentException) {\n                return \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\ThrowableMessage::from($exception);\n            }\n\n            // If the exception should not be caught by this library, it\n            // must be thrown again.\n            throw $exception;\n        })\n        -&gt;mapper()\n        -&gt;map(SomeClass::class, 'bar_baz');\n} catch (\\CuyZ\\Valinor\\Mapper\\MappingError $exception) {\n    // Should print something similar to:\n    // &gt; Expected a value to start with \"foo_\". Got: \"bar_baz\"\n    echo $exception-&gt;node()-&gt;messages()[0];\n}\n</code></pre> <p>Tree node API rework</p> <p>The class <code>\\CuyZ\\Valinor\\Mapper\\Tree\\Node</code> has been refactored to remove access to unwanted methods that were not supposed to be part of the public API. Below  are a list of all changes:</p> <ul> <li> <p>New methods <code>$node-&gt;sourceFilled()</code> and <code>$node-&gt;sourceValue()</code> allow accessing   the source value.</p> </li> <li> <p>The method <code>$node-&gt;value()</code> has been renamed to <code>$node-&gt;mappedValue()</code> and    will throw an exception if the node is not valid.</p> </li> <li> <p>The method <code>$node-&gt;type()</code> now returns a string.</p> </li> <li> <p>The methods <code>$message-&gt;name()</code>, <code>$message-&gt;path()</code>, <code>$message-&gt;type()</code> and    <code>$message-&gt;value()</code> have been deprecated in favor of the new method    <code>$message-&gt;node()</code>.</p> </li> <li> <p>The message parameter <code>{original_value}</code> has been deprecated in favor of   <code>{source_value}</code>.</p> </li> </ul> <p>Access removal of several parts of the library public API</p> <p>The access to class/function definition, types and exceptions did not add value  to the actual goal of the library. Keeping these features under the public API  flag causes more maintenance burden whereas revoking their access allows more  flexibility with the overall development of the library.</p>"},{"location":"project/changelog/version-0.12.0/#breaking-changes","title":"\u26a0 BREAKING CHANGES","text":"<ul> <li>Filter userland exceptions to hide potential sensible data (6ce1a4)</li> <li>Refactor tree node API (d3b1dc)</li> <li>Remove API access from several parts of library (316d91)</li> <li>Remove node visitor feature (63c87a)</li> </ul>"},{"location":"project/changelog/version-0.12.0/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Handle inferring methods with same names properly (dc45dd)</li> <li>Process invalid type default value as unresolvable type (7c9ac1)</li> <li>Properly display unresolvable type (3020db)</li> </ul>"},{"location":"project/changelog/version-0.12.0/#other","title":"Other","text":"<ul> <li>Ignore <code>.idea</code> folder (84ead0)</li> </ul>"},{"location":"project/changelog/version-0.13.0/","title":"Changelog 0.13.0 \u2014 31st of July 2022","text":"<p>See release on GitHub</p>"},{"location":"project/changelog/version-0.13.0/#notable-changes","title":"Notable changes","text":"<p>Reworking of messages body and parameters features</p> <p>The <code>\\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Message</code> interface is no longer a <code>Stringable</code>, however it defines a new method <code>body</code> that must return the body of the message, which can contain placeholders that will be replaced by parameters.</p> <p>These parameters can now be defined by implementing the interface <code>\\CuyZ\\Valinor\\Mapper\\Tree\\Message\\HasParameters</code>.</p> <p>This leads to the deprecation of the no longer needed interface <code>\\CuyZ\\Valinor\\Mapper\\Tree\\Message\\TranslatableMessage</code> which had a confusing name.</p> <pre><code>final class SomeException\n    extends DomainException \n    implements ErrorMessage, HasParameters, HasCode\n{\n    private string $someParameter;\n\n    public function __construct(string $someParameter)\n    {\n        parent::__construct();\n\n        $this-&gt;someParameter = $someParameter;\n    }\n\n    public function body() : string\n    {\n        return 'Some message / {some_parameter} / {source_value}';\n    }\n\n    public function parameters(): array\n    {\n        return [\n            'some_parameter' =&gt; $this-&gt;someParameter,\n        ];\n    }\n\n    public function code() : string\n    {\n        // A unique code that can help to identify the error\n        return 'some_unique_code';\n    }\n}\n</code></pre> <p>Handle <code>numeric-string</code> type</p> <p>The new <code>numeric-string</code> type can be used in docblocks.</p> <p>It will accept any string value that is also numeric.</p> <pre><code>(new MapperBuilder())-&gt;mapper()-&gt;map('numeric-string', '42'); // \u2705\n(new MapperBuilder())-&gt;mapper()-&gt;map('numeric-string', 'foo'); // \u274c\n</code></pre> <p>Better mapping error message</p> <p>The message of the exception will now contain more information, especially the total number of errors and the source that was given to the mapper. This change aims to have a better understanding of what is wrong when debugging.</p> <p>Before:</p> <p><code>Could not map type `array{foo: string, bar: int}` with the given source.</code></p> <p>After:</p> <p><code>Could not map type `array{foo: string, bar: int}`. An error occurred at path  bar: Value 'some other string' does not match type `int`.</code></p>"},{"location":"project/changelog/version-0.13.0/#breaking-changes","title":"\u26a0 BREAKING CHANGES","text":"<ul> <li>Rework messages body and parameters features (ad1207)</li> </ul>"},{"location":"project/changelog/version-0.13.0/#features","title":"Features","text":"<ul> <li>Allow to declare parameter for message (f61eb5)</li> <li>Display more information in mapping error message (9c1e7c)</li> <li>Handle numeric string type (96a493)</li> <li>Make <code>MessagesFlattener</code> countable (2c1c7c)</li> </ul>"},{"location":"project/changelog/version-0.13.0/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Handle native attribute on promoted parameter (897ca9)</li> </ul>"},{"location":"project/changelog/version-0.13.0/#other","title":"Other","text":"<ul> <li>Add fixed value for root node path (0b37b4)</li> <li>Remove types stringable behavior (b47a1b)</li> </ul>"},{"location":"project/changelog/version-0.14.0/","title":"Changelog 0.14.0 \u2014 1st of September 2022","text":"<p>See release on GitHub</p>"},{"location":"project/changelog/version-0.14.0/#notable-changes","title":"Notable changes","text":"<p>Until this release, the behaviour of the date objects creation was very  opinionated: a huge list of date formats were tested out, and if one was working it was used to create the date.</p> <p>This approach resulted in two problems. First, it led to (minor) performance  issues, because a lot of date formats were potentially tested for nothing. More importantly, it was not possible to define which format(s) were to be allowed (and in result deny other formats).</p> <p>A new method can now be used in the <code>MapperBuilder</code>:</p> <pre><code>(new \\CuyZ\\Valinor\\MapperBuilder())\n    // Both `Cookie` and `ATOM` formats will be accepted\n    -&gt;supportDateFormats(DATE_COOKIE, DATE_ATOM)\n    -&gt;mapper()\n    -&gt;map(DateTimeInterface::class, 'Monday, 08-Nov-1971 13:37:42 UTC');\n</code></pre> <p>Please note that the old behaviour has been removed. From now on, only valid  timestamp or ATOM-formatted value will be accepted by default.</p> <p>If needed and to help with the migration, the following deprecated  constructor can be registered to reactivate the previous behaviour:</p> <pre><code>(new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;registerConstructor(\n        new \\CuyZ\\Valinor\\Mapper\\Object\\BackwardCompatibilityDateTimeConstructor()\n    )\n    -&gt;mapper()\n    -&gt;map(DateTimeInterface::class, 'Monday, 08-Nov-1971 13:37:42 UTC');\n</code></pre>"},{"location":"project/changelog/version-0.14.0/#breaking-changes","title":"\u26a0 BREAKING CHANGES","text":"<ul> <li>Introduce constructor for custom date formats (f232cc)</li> </ul>"},{"location":"project/changelog/version-0.14.0/#features","title":"Features","text":"<ul> <li>Handle abstract constructor registration (c37ac1)</li> <li>Introduce attribute <code>DynamicConstructor</code> (e437d9)</li> <li>Introduce helper method to describe supported date formats (11a7ea)</li> </ul>"},{"location":"project/changelog/version-0.14.0/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Allow trailing comma in shaped array (bf445b)</li> <li>Correctly fetch file system cache entries (48208c)</li> <li>Detect invalid constructor handle type (b3cb59)</li> <li>Handle classes in a case-sensitive way in type parser (254074)</li> <li>Handle concurrent cache file creation (fd39ae)</li> <li>Handle inherited private constructor in class definition (73b622)</li> <li>Handle invalid nodes recursively (a401c2)</li> <li>Prevent illegal characters in PSR-16 cache keys (3c4d29)</li> <li>Properly handle callable objects of the same class (ae7ddc)</li> </ul>"},{"location":"project/changelog/version-0.14.0/#other","title":"Other","text":"<ul> <li>Add singleton usage of <code>ClassStringType</code> (4bc50e)</li> <li>Change <code>ObjectBuilderFactory::for</code> return signature (57849c)</li> <li>Extract native constructor object builder (2b46a6)</li> <li>Fetch attributes for function definition (ec494c)</li> <li>Refactor arguments instantiation (6414e9)</li> </ul>"},{"location":"project/changelog/version-0.15.0/","title":"Changelog 0.15.0 \u2014 6th of October 2022","text":"<p>See release on GitHub</p>"},{"location":"project/changelog/version-0.15.0/#notable-changes","title":"Notable changes","text":"<p>Two similar features are introduced in this release: constants and enums  wildcard notations. This is mainly useful when several cases of an enum or class constants share a common prefix.</p> <p>Example for class constants:</p> <pre><code>final class SomeClassWithConstants\n{\n    public const FOO = 1337;\n\n    public const BAR = 'bar';\n\n    public const BAZ = 'baz';\n}\n\n$mapper = (new MapperBuilder())-&gt;mapper();\n\n$mapper-&gt;map('SomeClassWithConstants::BA*', 1337); // error\n$mapper-&gt;map('SomeClassWithConstants::BA*', 'bar'); // ok\n$mapper-&gt;map('SomeClassWithConstants::BA*', 'baz'); // ok\n</code></pre> <p>Example for enum:</p> <pre><code>enum SomeEnum: string\n{\n    case FOO = 'foo';\n    case BAR = 'bar';\n    case BAZ = 'baz';\n}\n\n$mapper = (new MapperBuilder())-&gt;mapper();\n\n$mapper-&gt;map('SomeEnum::BA*', 'foo'); // error\n$mapper-&gt;map('SomeEnum::BA*', 'bar'); // ok\n$mapper-&gt;map('SomeEnum::BA*', 'baz'); // ok\n</code></pre>"},{"location":"project/changelog/version-0.15.0/#features","title":"Features","text":"<ul> <li>Add support for class constant type (1244c2)</li> <li>Add support for wildcard in enumeration type (69ebd1)</li> <li>Introduce utility class to build messages (cb8792)</li> </ul>"},{"location":"project/changelog/version-0.15.0/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Add return types for cache implementations (0e8f12)</li> <li>Correctly handle type inferring during mapping (37f96f)</li> <li>Fetch correct node value for children (3ee526)</li> <li>Improve scalar values casting (212b77)</li> <li>Properly handle static anonymous functions (c009ab)</li> </ul>"},{"location":"project/changelog/version-0.15.0/#other","title":"Other","text":"<ul> <li>Import namespace token parser inside library (0b8ca9)</li> <li>Remove unused code (b2889a, de8aa9)</li> <li>Save type token symbols during lexing (ad0f8f)</li> </ul>"},{"location":"project/changelog/version-0.16.0/","title":"Changelog 0.16.0 \u2014 19th of October 2022","text":"<p>See release on GitHub</p>"},{"location":"project/changelog/version-0.16.0/#features","title":"Features","text":"<ul> <li>Add support for PHP 8.2 (a92360)</li> </ul>"},{"location":"project/changelog/version-0.16.0/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Properly handle quote char in type definition (c71d6a)</li> </ul>"},{"location":"project/changelog/version-0.16.0/#other","title":"Other","text":"<ul> <li>Update dependencies (c2de32)</li> </ul>"},{"location":"project/changelog/version-0.17.0/","title":"Changelog 0.17.0 \u2014 8th of November 2022","text":"<p>See release on GitHub</p>"},{"location":"project/changelog/version-0.17.0/#notable-changes","title":"Notable changes","text":"<p>The main feature introduced in this release is the split of the flexible mode in three distinct modes:</p> <ol> <li>The flexible casting</li> </ol> <p>Changes the behaviours explained below:</p> <pre><code>$flexibleMapper = (new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;enableFlexibleCasting()\n    -&gt;mapper();\n\n// ---\n// Scalar types will accept non-strict values; for instance an\n// integer type will accept any valid numeric value like the\n// *string* \"42\".\n\n$flexibleMapper-&gt;map('int', '42');\n// =&gt; 42\n\n// ---\n// List type will accept non-incremental keys.\n\n$flexibleMapper-&gt;map('list&lt;int&gt;', ['foo' =&gt; 42, 'bar' =&gt; 1337]);\n// =&gt; [0 =&gt; 42, 1 =&gt; 1338]\n\n// ---\n// If a value is missing in a source for a node that accepts `null`,\n// the node will be filled with `null`.\n\n$flexibleMapper-&gt;map(\n    'array{foo: string, bar: null|string}',\n    ['foo' =&gt; 'foo'] // `bar` is missing\n);\n// =&gt; ['foo' =&gt; 'foo', 'bar' =&gt; null]\n\n// ---\n// Array and list types will convert `null` or missing values to an\n// empty array.\n\n$flexibleMapper-&gt;map(\n    'array{foo: string, bar: array&lt;string&gt;}',\n    ['foo' =&gt; 'foo'] // `bar` is missing\n);\n// =&gt; ['foo' =&gt; 'foo', 'bar' =&gt; []]\n</code></pre> <ol> <li>The superfluous keys</li> </ol> <p>Superfluous keys in source arrays will be allowed, preventing errors    when a value is not bound to any object property/parameter or shaped    array element.</p> <pre><code>(new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;allowSuperfluousKeys()\n    -&gt;mapper()\n    -&gt;map(\n        'array{foo: string, bar: int}',\n        [\n            'foo' =&gt; 'foo',\n            'bar' =&gt; 42,\n            'baz' =&gt; 1337.404, // `baz` will be ignored\n        ]\n    );\n</code></pre> <ol> <li>The permissive types</li> </ol> <p>Allows permissive types <code>mixed</code> and <code>object</code> to be used during    mapping.</p> <pre><code>(new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;allowPermissiveTypes()\n    -&gt;mapper()\n    -&gt;map(\n        'array{foo: string, bar: mixed}',\n        [\n            'foo' =&gt; 'foo',\n            'bar' =&gt; 42, // Could be any value\n        ]\n    );\n</code></pre>"},{"location":"project/changelog/version-0.17.0/#features","title":"Features","text":"<ul> <li>Add support for <code>strict-array</code> type (d456eb)</li> <li>Introduce new callback message formatter (93f898)</li> <li>Introduce new helper class to list messages (513827)</li> <li>Split mapper flexible mode in three distinct modes (549e5f)</li> </ul>"},{"location":"project/changelog/version-0.17.0/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Allow missing and null value for array node in flexible mode (034f1c)</li> <li>Allow missing value for shaped array nullable node in flexible mode (08fb0e)</li> <li>Handle scalar value casting in union types only in flexible mode (752ad9)</li> </ul>"},{"location":"project/changelog/version-0.17.0/#other","title":"Other","text":"<ul> <li>Do not use <code>uniqid()</code> (b81847)</li> <li>Transform missing source value to <code>null</code> in flexible mode (92a41a)</li> </ul>"},{"location":"project/changelog/version-0.2.0/","title":"Changelog 0.2.0 \u2014 7th of December 2021","text":"<p>See release on GitHub</p>"},{"location":"project/changelog/version-0.2.0/#features","title":"Features","text":"<ul> <li>Handle integer range type (9f99a2)</li> <li>Handle local type aliasing in class definition (56142d)</li> <li>Handle type alias import in class definition (fa3ce5)</li> </ul>"},{"location":"project/changelog/version-0.2.0/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Do not accept shaped array with excessive key(s) (5a578e)</li> <li>Handle integer value match properly (9ee2cc)</li> </ul>"},{"location":"project/changelog/version-0.2.0/#other","title":"Other","text":"<ul> <li>Delete commented code (4f5612)</li> <li>Move exceptions to more specific folder (185edf)</li> <li>Rename <code>GenericAssignerLexer</code> to <code>TypeAliasLexer</code> (680941)</li> <li>Use <code>marcocesarato/php-conventional-changelog</code> for changelog (178aa9)</li> </ul>"},{"location":"project/changelog/version-0.3.0/","title":"Changelog 0.3.0 \u2014 18th of December 2021","text":"<p>See release on GitHub</p>"},{"location":"project/changelog/version-0.3.0/#features","title":"Features","text":"<ul> <li>Handle common database datetime formats (#40) (179ba3)</li> </ul>"},{"location":"project/changelog/version-0.3.0/#other","title":"Other","text":"<ul> <li>Change Composer scripts calls (0b507c)</li> <li>Raise version of <code>friendsofphp/php-cs-fixer</code> (e5ccbe)</li> </ul>"},{"location":"project/changelog/version-0.4.0/","title":"Changelog 0.4.0 \u2014 7th of January 2022","text":"<p>See release on GitHub</p>"},{"location":"project/changelog/version-0.4.0/#notable-changes","title":"Notable changes","text":"<p>Allow mapping to any type</p> <p>Previously, the method <code>TreeMapper::map</code> would allow mapping only to an object. It is now possible to map to any type handled by the library.</p> <p>It is for instance possible to map to an array of objects:</p> <pre><code>$objects = (new MapperBuilder())-&gt;mapper()-&gt;map(\n    'array&lt;' . SomeClass::class . '&gt;',\n    [/* \u2026 */]\n);\n</code></pre> <p>For simple use-cases, an array shape can be used:</p> <pre><code>$array = (new MapperBuilder())-&gt;mapper()-&gt;map(\n    'array{foo: string, bar: int}',\n    [/* \u2026 */]\n);\n\necho $array['foo'];\necho $array['bar'] * 2;\n</code></pre> <p>This new feature changes the possible behaviour of the mapper, meaning static analysis tools need help to understand the types correctly. An extension for PHPStan and a plugin for Psalm are now provided and can be included in a project to automatically increase the type coverage.</p> <p>Better handling of messages</p> <p>When working with messages, it can sometimes be useful to customize the content of a message \u2014 for instance to translate it.</p> <p>The helper class <code>\\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\MessageMapFormatter</code> can be used to provide a list of new formats. It can be instantiated with an array where each key represents either:</p> <ul> <li>The code of the message to be replaced</li> <li>The content of the message to be replaced</li> <li>The class name of the message to be replaced</li> </ul> <p>If none of those is found, the content of the message will stay unchanged unless a default one is given to the class.</p> <p>If one of these keys is found, the array entry will be used to replace the content of the message. This entry can be either a plain text or a callable that takes the message as a parameter and returns a string; it is for instance advised to use a callable in cases where a translation service is used \u2014 to avoid useless greedy operations.</p> <p>In any case, the content can contain placeholders that will automatically be replaced by, in order:</p> <ol> <li>The original code of the message</li> <li>The original content of the message</li> <li>A string representation of the node type</li> <li>The name of the node</li> <li>The path of the node</li> </ol> <pre><code>try {\n    (new \\CuyZ\\Valinor\\MapperBuilder())\n        -&gt;mapper()\n        -&gt;map(SomeClass::class, [/* \u2026 */]);\n} catch (\\CuyZ\\Valinor\\Mapper\\MappingError $error) {\n    $node = $error-&gt;node();\n    $messages = new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\MessagesFlattener($node);\n\n    $formatter = (new MessageMapFormatter([\n        // Will match if the given message has this exact code\n        'some_code' =&gt; 'new content / previous code was: %1$s',\n\n        // Will match if the given message has this exact content\n        'Some message content' =&gt; 'new content / previous message: %2$s',\n\n        // Will match if the given message is an instance of `SomeError`\n        SomeError::class =&gt; '\n            - Original code of the message: %1$s\n            - Original content of the message: %2$s\n            - Node type: %3$s\n            - Node name: %4$s\n            - Node path: %5$s\n        ',\n\n        // A callback can be used to get access to the message instance\n        OtherError::class =&gt; function (NodeMessage $message): string {\n            if ((string)$message-&gt;type() === 'string|int') {\n                // \u2026\n            }\n\n            return 'Some message content';\n        },\n\n        // For greedy operation, it is advised to use a lazy-callback\n        'bar' =&gt; fn () =&gt; $this-&gt;translator-&gt;translate('foo.bar'),\n    ]))\n        -&gt;defaultsTo('some default message')\n        // \u2026or\u2026\n        -&gt;defaultsTo(fn () =&gt; $this-&gt;translator-&gt;translate('default_message'));\n\n    foreach ($messages as $message) {\n        echo $formatter-&gt;format($message);    \n    }\n}\n</code></pre> <p>Automatic union of objects inferring during mapping</p> <p>When the mapper needs to map a source to a union of objects, it will try to guess which object it will map to, based on the needed arguments of the objects, and the values contained in the source.</p> <pre><code>final class UnionOfObjects\n{\n    public readonly SomeFooObject|SomeBarObject $object;\n}\n\nfinal class SomeFooObject\n{\n    public readonly string $foo;\n}\n\nfinal class SomeBarObject\n{\n    public readonly string $bar;\n}\n\n// Will map to an instance of `SomeFooObject`\n(new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;mapper()\n    -&gt;map(UnionOfObjects::class, ['foo' =&gt; 'foo']);\n\n// Will map to an instance of `SomeBarObject`\n(new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;mapper()\n    -&gt;map(UnionOfObjects::class, ['bar' =&gt; 'bar']);\n</code></pre>"},{"location":"project/changelog/version-0.4.0/#breaking-changes","title":"\u26a0 BREAKING CHANGES","text":"<ul> <li>Add access to root node when error occurs during mapping (54f608)</li> <li>Allow mapping to any type (b2e810)</li> <li>Allow object builder to yield arguments without source (8a7414)</li> <li>Wrap node messages in proper class (a805ba)</li> </ul>"},{"location":"project/changelog/version-0.4.0/#features","title":"Features","text":"<ul> <li>Introduce automatic union of objects inferring during mapping (79d7c2)</li> <li>Introduce helper class <code>MessageMapFormatter</code> (ddf69e)</li> <li>Introduce helper class <code>MessagesFlattener</code> (a97b40)</li> <li>Introduce helper <code>NodeTraverser</code> for recursive operations on nodes (cc1bc6)</li> </ul>"},{"location":"project/changelog/version-0.4.0/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Handle nested attributes compilation (d2795b)</li> <li>Treat forbidden mixed type as invalid type (36bd36)</li> <li>Treat union type resolving error as message (e834cd)</li> <li>Use locked package versions for quality assurance workflow (626f13)</li> </ul>"},{"location":"project/changelog/version-0.4.0/#other","title":"Other","text":"<ul> <li>Ignore changelog configuration file in git export (85a6a4)</li> <li>Raise PHPStan version (0144bf)</li> </ul>"},{"location":"project/changelog/version-0.5.0/","title":"Changelog 0.5.0 \u2014 21st of January 2022","text":"<p>See release on GitHub</p>"},{"location":"project/changelog/version-0.5.0/#features","title":"Features","text":"<ul> <li>Introduce automatic named constructor resolution (718d3c)</li> <li>Set up dependabot for automated weekly dependency upgrades (23b611)</li> <li>Simplify type signature of <code>TreeMapper#map()</code> (e28003)</li> </ul>"},{"location":"project/changelog/version-0.5.0/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Correct regex that detects @internal or @api annotations (39f0b7)</li> <li>Improve type definitions to allow Psalm automatic inferring (f9b04c)</li> <li>Return indexed list of attributes when filtering on type (66aa4d)</li> </ul>"},{"location":"project/changelog/version-0.6.0/","title":"Changelog 0.6.0 \u2014 24th of February 2022","text":"<p>See release on GitHub</p>"},{"location":"project/changelog/version-0.6.0/#breaking-changes","title":"\u26a0 BREAKING CHANGES","text":"<ul> <li>Improve interface inferring API (1eb6e6)</li> <li>Improve object binding API (6d4270)</li> </ul>"},{"location":"project/changelog/version-0.6.0/#features","title":"Features","text":"<ul> <li>Handle variadic parameters in constructors (b6b329)</li> <li>Improve value altering API (422e6a)</li> <li>Introduce a camel case source key modifier (d94652)</li> <li>Introduce function definition repository (b49ebf)</li> <li>Introduce method to get parameter by index (380961)</li> </ul>"},{"location":"project/changelog/version-0.6.0/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Change license in <code>composer.json</code> (6fdd62)</li> <li>Ensure native mixed types remain valid (18ccbe)</li> <li>Remove string keys when unpacking variadic parameter values (cbf4e1)</li> <li>Transform exception thrown during object binding into a message (359e32)</li> <li>Write temporary cache file inside cache subdirectory (1b80a1)</li> </ul>"},{"location":"project/changelog/version-0.6.0/#other","title":"Other","text":"<ul> <li>Check value acceptance in separate node builder (30d447)</li> <li>Narrow union types during node build (06e9de)</li> </ul>"},{"location":"project/changelog/version-0.7.0/","title":"Changelog 0.7.0 \u2014 24th of March 2022","text":"<p>See release on GitHub</p>"},{"location":"project/changelog/version-0.7.0/#notable-changes","title":"Notable changes","text":"<p>Warning This release introduces a major breaking change that must be considered before updating</p> <p>Constructor registration</p> <p>The automatic named constructor discovery has been disabled. It is now mandatory to explicitly register custom constructors that can be used by the mapper.</p> <p>This decision was made because of a security issue reported by @Ocramius and described in advisory advisory GHSA-xhr8-mpwq-2rr2.</p> <p>As a result, existing code must list all named constructors that were previously automatically used by the mapper, and registerer them using the method <code>MapperBuilder::registerConstructor()</code>.</p> <p>The method <code>MapperBuilder::bind()</code> has been deprecated in favor of the method above that should be used instead.</p> <pre><code>final class SomeClass\n{\n    public static function namedConstructor(string $foo): self\n    {\n        // \u2026\n    }\n}\n\n(new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;registerConstructor(\n        SomeClass::namedConstructor(...),\n        // \u2026or for PHP &lt; 8.1:\n        [SomeClass::class, 'namedConstructor'],\n    )\n    -&gt;mapper()\n    -&gt;map(SomeClass::class, [\n        // \u2026\n    ]);\n</code></pre> <p>See documentation for more information.</p> <p>Source builder</p> <p>The <code>Source</code> class is a new entry point for sources that are not plain array or iterable. It allows accessing other features like camel-case keys or custom paths mapping in a convenient way.</p> <p>It should be used as follows:</p> <pre><code>$source = \\CuyZ\\Valinor\\Mapper\\Source\\Source::json($jsonString)\n    -&gt;camelCaseKeys()\n    -&gt;map([\n        'towns' =&gt; 'cities',\n        'towns.*.label' =&gt; 'name',\n    ]);\n\n$result = (new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;mapper()\n    -&gt;map(SomeClass::class, $source);\n</code></pre> <p>See documentation for more details about its usage.</p>"},{"location":"project/changelog/version-0.7.0/#breaking-changes","title":"\u26a0 BREAKING CHANGES","text":"<ul> <li>Change <code>Attributes::ofType</code> return type to <code>array</code> (1a599b)</li> <li>Introduce method to register constructors used during mapping (ecafba)</li> </ul>"},{"location":"project/changelog/version-0.7.0/#features","title":"Features","text":"<ul> <li>Introduce a path-mapping source modifier (b7a7d2)</li> <li>Introduce a source builder (ad5103)</li> </ul>"},{"location":"project/changelog/version-0.7.0/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Handle numeric key with camel case source key modifier (b8a18f)</li> <li>Handle parameter default object value compilation (fdef93)</li> <li>Handle variadic arguments in callable constructors (b646cc)</li> <li>Properly handle alias types for function reflection (e5b515)</li> </ul>"},{"location":"project/changelog/version-0.7.0/#other","title":"Other","text":"<ul> <li>Add Striker HTML report when running infection (79c7a4)</li> <li>Handle class name in function definition (e2451d)</li> <li>Introduce functions container to wrap definition handling (fd1117)</li> </ul>"},{"location":"project/changelog/version-0.8.0/","title":"Changelog 0.8.0 \u2014 9th of May 2022","text":"<p>See release on GitHub</p>"},{"location":"project/changelog/version-0.8.0/#notable-changes","title":"Notable changes","text":"<p>Float values handling</p> <p>Allows the usage of float values, as follows:</p> <pre><code>class Foo\n{\n    /** @var 404.42|1337.42 */\n    public readonly float $value;\n}\n</code></pre> <p>Literal boolean <code>true</code> / <code>false</code> values handling</p> <p>Thanks @danog for this feature!</p> <p>Allows the usage of boolean values, as follows:</p> <pre><code>class Foo\n{\n    /** @var int|false */\n    public readonly int|bool $value;\n}\n</code></pre> <p>Class string of union of object handling</p> <p>Allows to declare several class names in a <code>class-string</code>:</p> <pre><code>class Foo\n{\n    /** @var class-string&lt;SomeClass|SomeOtherClass&gt; */\n    public readonly string $className;\n}\n</code></pre> <p>Allow <code>psalm</code> and <code>phpstan</code> prefix in docblocks</p> <p>Thanks @boesing for this feature!</p> <p>The following annotations are now properly handled: <code>@psalm-param</code>, <code>@phpstan-param</code>, <code>@psalm-return</code> and <code>@phpstan-return</code>.</p> <p>If one of those is found along with a basic <code>@param</code> or <code>@return</code> annotation, it will take precedence over the basic value.</p>"},{"location":"project/changelog/version-0.8.0/#features","title":"Features","text":"<ul> <li>Allow <code>psalm</code> and <code>phpstan</code> prefix in docblocks (64e0a2)</li> <li>Handle class string of union of object (b7923b)</li> <li>Handle filename in function definition (0b042b)</li> <li>Handle float value type (790df8)</li> <li>Handle literal boolean <code>true</code> / <code>false</code> types (afcedf)</li> <li>Introduce composite types (892f38)</li> </ul>"},{"location":"project/changelog/version-0.8.0/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Call value altering function only if value is accepted (2f08e1)</li> <li>Handle function definition cache invalidation when file is modified (511a0d)</li> </ul>"},{"location":"project/changelog/version-0.8.0/#other","title":"Other","text":"<ul> <li>Add configuration for Composer allowed plugins (2f310c)</li> <li>Add Psalm configuration file to <code>.gitattributes</code> (979272)</li> <li>Bump dev-dependencies (844384)</li> <li>Declare code type in docblocks (03c84a)</li> <li>Ignore <code>Polyfill</code> coverage (c08fe5)</li> <li>Remove <code>symfony/polyfill-php80</code> dependency (368737)</li> </ul>"},{"location":"project/changelog/version-0.9.0/","title":"Changelog 0.9.0 \u2014 23rd of May 2022","text":"<p>See release on GitHub</p>"},{"location":"project/changelog/version-0.9.0/#notable-changes","title":"Notable changes","text":"<p>Cache injection and warmup</p> <p>The cache feature has been revisited, to give more control to the user on how and when to use it.</p> <p>The method <code>MapperBuilder::withCacheDir()</code> has been deprecated in favor of a new method <code>MapperBuilder::withCache()</code> which accepts any PSR-16 compliant implementation.</p> <p>Warning</p> <p>These changes lead up to the default cache not being automatically registered anymore. If you still want to enable the cache (which you should), you will have to explicitly inject it (see below).</p> <p>A default implementation is provided out of the box, which saves cache entries into the file system.</p> <p>When the application runs in a development environment, the cache implementation should be decorated with <code>FileWatchingCache</code>, which will watch the files of the application and invalidate cache entries when a PHP file is modified by a developer \u2014 preventing the library not behaving as expected when the signature of a property or a method changes.</p> <p>The cache can be warmed up, for instance in a pipeline during the build and deployment of the application \u2014 kudos to @boesing for the feature!</p> <p>Note The cache has to be registered first, otherwise the warmup will end up being useless.</p> <pre><code>$cache = new \\CuyZ\\Valinor\\Cache\\FileSystemCache('path/to/cache-directory');\n\nif ($isApplicationInDevelopmentEnvironment) {\n    $cache = new \\CuyZ\\Valinor\\Cache\\FileWatchingCache($cache);\n}\n\n$mapperBuilder = (new \\CuyZ\\Valinor\\MapperBuilder())-&gt;withCache($cache);\n\n// During the build:\n$mapperBuilder-&gt;warmup(SomeClass::class, SomeOtherClass::class);\n\n// In the application:\n$mapperBuilder-&gt;mapper()-&gt;map(SomeClass::class, [/* \u2026 */]);\n</code></pre> <p>Message formatting &amp; translation</p> <p>Major changes have been made to the messages being returned in case of a mapping error: the actual texts are now more accurate and show better information.</p> <p>Warning </p> <p>The method <code>NodeMessage::format</code> has been removed, message formatters should  be used instead. If needed, the old behaviour can be retrieved with the formatter <code>PlaceHolderMessageFormatter</code>, although it is strongly advised to  use the new placeholders feature (see below).</p> <p>The signature of the method <code>MessageFormatter::format</code> has changed as well.</p> <p>It is now also easier to format the messages, for instance when they need to be translated. Placeholders can now be used in a message body, and will be replaced  with useful information.</p> Placeholder Description <code>{message_code}</code> the code of the message <code>{node_name}</code> name of the node to which the message is bound <code>{node_path}</code> path of the node to which the message is bound <code>{node_type}</code> type of the node to which the message is bound <code>{original_value}</code> the source value that was given to the node <code>{original_message}</code> the original message before being customized <pre><code>try {\n    (new \\CuyZ\\Valinor\\MapperBuilder())\n        -&gt;mapper()\n        -&gt;map(SomeClass::class, [/* \u2026 */]);\n} catch (\\CuyZ\\Valinor\\Mapper\\MappingError $error) {\n    $node = $error-&gt;node();\n    $messages = new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\MessagesFlattener($node);\n\n    foreach ($messages as $message) {\n        if ($message-&gt;code() === 'some_code') {\n            $message = $message-&gt;withBody('new message / {original_message}');\n        }\n\n        echo $message;\n    }\n}\n</code></pre> <p>The messages are formatted using the ICU library, enabling the placeholders to use advanced syntax to perform proper translations, for instance currency support.</p> <pre><code>try {\n    (new \\CuyZ\\Valinor\\MapperBuilder())-&gt;mapper()-&gt;map('int&lt;0, 100&gt;', 1337);\n} catch (\\CuyZ\\Valinor\\Mapper\\MappingError $error) {\n    $message = $error-&gt;node()-&gt;messages()[0];\n\n    if (is_numeric($message-&gt;value())) {\n        $message = $message-&gt;withBody(\n            'Invalid amount {original_value, number, currency}'\n        );    \n    } \n\n    // Invalid amount: $1,337.00\n    echo $message-&gt;withLocale('en_US');\n\n    // Invalid amount: \u00a31,337.00\n    echo $message-&gt;withLocale('en_GB');\n\n    // Invalid amount: 1 337,00 \u20ac\n    echo $message-&gt;withLocale('fr_FR');\n}\n</code></pre> <p>See ICU documentation for more information on available syntax.</p> <p>Warning If the <code>intl</code> extension is not installed, a shim will be available to replace the placeholders, but it won't handle advanced syntax as described above.</p> <p>The formatter <code>TranslationMessageFormatter</code> can be used to translate the content of messages.</p> <p>The library provides a list of all messages that can be returned; this list can be filled or modified with custom translations.</p> <pre><code>\\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\TranslationMessageFormatter::default()\n    // Create/override a single entry\u2026\n    -&gt;withTranslation('fr', 'some custom message', 'un message personnalis\u00e9')\n    // \u2026or several entries.\n    -&gt;withTranslations([\n        'some custom message' =&gt; [\n            'en' =&gt; 'Some custom message',\n            'fr' =&gt; 'Un message personnalis\u00e9',\n            'es' =&gt; 'Un mensaje personalizado',\n        ], \n        'some other message' =&gt; [\n            // \u2026\n        ], \n    ])\n    -&gt;format($message);\n</code></pre> <p>It is possible to join several formatters into one formatter by using the <code>AggregateMessageFormatter</code>. This instance can then easily be injected in a service that will handle messages.</p> <p>The formatters will be called in the same order they are given to the aggregate.</p> <pre><code>(new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\AggregateMessageFormatter(\n    new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\LocaleMessageFormatter('fr'),\n    new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\MessageMapFormatter([\n        // \u2026\n    ],\n    \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\TranslationMessageFormatter::default(),\n))-&gt;format($message)\n</code></pre>"},{"location":"project/changelog/version-0.9.0/#breaking-changes","title":"\u26a0 BREAKING CHANGES","text":"<ul> <li>Improve message customization with formatters (60a665)</li> <li>Revoke <code>ObjectBuilder</code> API access (11e126)</li> </ul>"},{"location":"project/changelog/version-0.9.0/#features","title":"Features","text":"<ul> <li>Allow injecting a cache implementation that is used by the mapper (69ad3f)</li> <li>Extract file watching feature in own cache implementation (2d70ef)</li> <li>Improve mapping error messages (05cf4a)</li> <li>Introduce method to warm the cache up (ccf09f)</li> </ul>"},{"location":"project/changelog/version-0.9.0/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Make interface type match undefined object type (105eef)</li> </ul>"},{"location":"project/changelog/version-0.9.0/#other","title":"Other","text":"<ul> <li>Change <code>InvalidParameterIndex</code> exception inheritance type (b75adb)</li> <li>Introduce layer for object builder arguments (48f936)</li> </ul>"},{"location":"project/changelog/version-1.0.0/","title":"Changelog 1.0.0 \u2014 28th of November 2022","text":"<p>See release on GitHub</p> <p>First stable version! \ud83e\udd73 \ud83c\udf89</p> <p>This release marks the end of the initial development phase. The library has  been live for exactly one year at this date and is stable enough to start  following the semantic versioning \u2014 it means that any backward incompatible  change (aka breaking change) will lead to a bump of the major version.</p> <p>This is the biggest milestone achieved by this project (yet\u2122); I want to thank everyone who has been involved to make it possible, especially the  contributors who submitted high-quality pull requests to improve the library.</p> <p>There is also one person that I want to thank even more: my best friend Nathan, who has always been so supportive with my side-projects. Thanks, bro! \ud83d\ude4c</p> <p>The last year marked a bigger investment of my time in OSS contributions; I've proven to myself that I am able to follow a stable way of managing my engagement to this community, and this is why I enabled sponsorship on my profile to allow people to \u2764\ufe0f sponsor my work on GitHub \u2014 if you use this library in your applications, please consider offering me a \ud83c\udf7a from time to time! \ud83e\udd17</p>"},{"location":"project/changelog/version-1.0.0/#notable-changes","title":"Notable changes","text":"<p>End of PHP 7.4 support</p> <p>PHP 7.4 security support has ended on the 28th of November 2022; the minimum version supported by this library is now PHP 8.0.</p> <p>New mapper to map arguments of a callable</p> <p>This new mapper can be used to ensure a source has the right shape before calling a function/method.</p> <p>The mapper builder can be configured the same way it would be with a tree mapper, for instance to customize the type strictness.</p> <pre><code>$someFunction = function(string $foo, int $bar): string {\n    return \"$foo / $bar\";\n};\n\ntry {\n    $arguments = (new \\CuyZ\\Valinor\\MapperBuilder())\n        -&gt;argumentsMapper()\n        -&gt;mapArguments($someFunction, [\n            'foo' =&gt; 'some value',\n            'bar' =&gt; 42,\n        ]);\n\n    // some value / 42\n    echo $someFunction(...$arguments);\n} catch (\\CuyZ\\Valinor\\Mapper\\MappingError $error) {\n    // Do something\u2026\n}\n</code></pre> <p>Support for <code>TimeZone</code> objects</p> <p>Native <code>TimeZone</code> objects construction is now supported with a proper error handling.</p> <pre><code>try {\n    (new \\CuyZ\\Valinor\\MapperBuilder())\n        -&gt;mapper()\n        -&gt;map(DateTimeZone::class, 'Jupiter/Europa');\n} catch (MappingError $exception) {\n    $error = $exception-&gt;node()-&gt;messages()[0];\n\n    // Value 'Jupiter/Europa' is not a valid timezone.\n    echo $error-&gt;toString();\n}\n</code></pre> <p>Mapping object with one property</p> <p>When a class needs only one value, the source given to the mapper must match the type of the single property/parameter.</p> <p>This change aims to bring consistency on how the mapper behaves when mapping an object that needs one argument. Before this change, the source could either match the needed type, or be an array with a single entry and a key named after the argument.</p> <p>See example below:</p> <pre><code>final class Identifier\n{\n    public readonly string $value;\n}\n\nfinal class SomeClass\n{\n    public readonly Identifier $identifier;\n\n    public readonly string $description;\n}\n\n(new \\CuyZ\\Valinor\\MapperBuilder())-&gt;mapper()-&gt;map(SomeClass::class, [\n    'identifier' =&gt; ['value' =&gt; 'some-identifier'], // \u274c\n    'description' =&gt; 'Lorem ipsum\u2026',\n]);\n\n(new \\CuyZ\\Valinor\\MapperBuilder())-&gt;mapper()-&gt;map(SomeClass::class, [\n    'identifier' =&gt; 'some-identifier', // \u2705\n    'description' =&gt; 'Lorem ipsum\u2026',\n]);\n</code></pre>"},{"location":"project/changelog/version-1.0.0/#upgrading-from-0x-to-10","title":"Upgrading from 0.x to 1.0","text":"<p>As this is a major release, all deprecated features have been removed, leading to an important number of breaking changes.</p> <p>You can click on the entries below to get advice on available replacements. </p> Doctrine annotations support removal <p>Doctrine annotations cannot be used anymore, PHP attributes must be used.</p> <code>BackwardCompatibilityDateTimeConstructor</code> class removal <p>You must use the method available in the mapper builder, see dealing  with dates chapter.</p> Mapper builder <code>flexible</code> method removal <p>The flexible has been split in three disctint modes, see type strictness &amp; flexibility chapter.</p> Mapper builder <code>withCacheDir</code> method removal <p>You must now register a cache instance directly, see performance &amp;  caching chapter.</p> <code>StaticMethodConstructor</code> class removal <p>You must now register the constructors using the mapper builder, see custom object constructors chapter.</p> Mapper builder <code>bind</code> method removal <p>You must now register the constructors using the mapper builder, see custom object constructors chapter.</p> <code>ThrowableMessage</code> class removal <p>You must now use the <code>MessageBuilder</code> class, see error handling chapter.</p> <code>MessagesFlattener</code> class removal <p>You must now use the <code>Messages</code> class, see error handling chapter.</p> <code>TranslatableMessage</code> class removal <p>You must now use the <code>HasParameters</code> class, see custom exception chapter.</p> Message methods removal <p>The following methods have been removed:</p> <ul> <li><code>\\CuyZ\\Valinor\\Mapper\\Tree\\Message\\NodeMessage::name()</code></li> <li><code>\\CuyZ\\Valinor\\Mapper\\Tree\\Message\\NodeMessage::path()</code></li> <li><code>\\CuyZ\\Valinor\\Mapper\\Tree\\Message\\NodeMessage::type()</code></li> <li><code>\\CuyZ\\Valinor\\Mapper\\Tree\\Message\\NodeMessage::value()</code></li> <li><code>\\CuyZ\\Valinor\\Mapper\\Tree\\Node::value()</code></li> </ul> <p>It is still possible to get the wanted values using the method <code>\\CuyZ\\Valinor\\Mapper\\Tree\\Message\\NodeMessage::node()</code>.</p> <p>The placeholder <code>{original_value}</code> has also been removed, the same value can be fetched with <code>{source_value}</code>.</p> <code>PlaceHolderMessageFormatter</code> class removal <p>Other features are available to format message, see error messages customization chapter.</p> <code>Identifier</code> attribute removal <p>This feature has been part of the library since its first public release, but it was never documented because it did not fit one of the library's main  philosophy which is to be almost entirely decoupled from an application's domain layer.</p> <p>The feature is entirely removed and not planned to be replaced by an alternative, unless the community really feels like there is a need for something alike.</p>"},{"location":"project/changelog/version-1.0.0/#breaking-changes","title":"\u26a0 BREAKING CHANGES","text":"<ul> <li>Disallow array when mapping to object with one argument (72cba3)</li> <li>Mark tree mapper and arguments mapper as <code>@pure</code> (0d9855)</li> <li>Remove deprecated backward compatibility datetime constructor (a65e8d)</li> <li>Remove deprecated class <code>ThrowableMessage</code> (d36ca9)</li> <li>Remove deprecated class to flatten messages (f9ed93)</li> <li>Remove deprecated interface <code>TranslatableMessage</code> (ceb197)</li> <li>Remove deprecated message methods (e6557d)</li> <li>Remove deprecated method constructor attribute (d76467)</li> <li>Remove deprecated method to enable flexible mode (a2bef3)</li> <li>Remove deprecated method to set cache directory (b0d6d2)</li> <li>Remove deprecated method used to bind a callback (b79ed8)</li> <li>Remove deprecated placeholder message formatter (c2723d)</li> <li>Remove Doctrine annotations support (66c182)</li> <li>Remove identifier attribute (8a7486)</li> <li>Remove PHP 7.4 support (5f5a50)</li> <li>Remove support for <code>strict-array</code> type (22c3b4)</li> </ul>"},{"location":"project/changelog/version-1.0.0/#features","title":"Features","text":"<ul> <li>Add constructor for <code>DateTimeZone</code> with error support (a0a4d6)</li> <li>Introduce mapper to map arguments of a callable (9c7e88)</li> </ul>"},{"location":"project/changelog/version-1.0.0/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Allow mapping <code>null</code> to single node nullable type (0a98ec)</li> <li>Handle single argument mapper properly (d7bf6a)</li> <li>Handle tree mapper call without argument in PHPStan extension (3f3a01)</li> <li>Handle tree mapper call without argument in Psalm plugin (b425af)</li> </ul>"},{"location":"project/changelog/version-1.0.0/#other","title":"Other","text":"<ul> <li>Activate value altering feature only when callbacks are registered (0f33a5)</li> <li>Bump <code>psr/simple-cache</code> supported version (e4059a)</li> <li>Remove <code>@</code> from comments for future PHP versions changes (68774c)</li> <li>Update dependencies (4afcda)</li> </ul>"},{"location":"project/changelog/version-1.1.0/","title":"Changelog 1.1.0 \u2014 20th of December 2022","text":"<p>See release on GitHub</p>"},{"location":"project/changelog/version-1.1.0/#notable-changes","title":"Notable changes","text":"<p>Handle class generic types inheritance</p> <p>It is now possible to use the <code>@extends</code> tag (already handled by PHPStan and Psalm) to declare the type of a parent class generic. This logic is recursively applied to all parents.</p> <pre><code>/**\n * @template FirstTemplate\n * @template SecondTemplate\n */\nabstract class FirstClassWithGenerics\n{\n    /** @var FirstTemplate */\n    public $valueA;\n\n    /** @var SecondTemplate */\n    public $valueB;\n}\n\n/**\n * @template FirstTemplate\n * @extends FirstClassWithGenerics&lt;FirstTemplate, int&gt;\n */\nabstract class SecondClassWithGenerics extends FirstClassWithGenerics\n{\n    /** @var FirstTemplate */\n    public $valueC;\n}\n\n/**\n * @extends SecondClassWithGenerics&lt;string&gt;\n */\nfinal class ChildClass extends SecondClassWithGenerics\n{\n}\n\n$object = (new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;mapper()\n    -&gt;map(ChildClass::class, [\n        'valueA' =&gt; 'foo',\n        'valueB' =&gt; 1337,\n        'valueC' =&gt; 'bar',\n    ]);\n\necho $object-&gt;valueA; // 'foo'\necho $object-&gt;valueB; // 1337\necho $object-&gt;valueC; // 'bar'\n</code></pre> <p>Added support for class inferring</p> <p>It is now possible to infer abstract or parent classes the same way it can be done for interfaces.</p> <p>Example with an abstract class:</p> <pre><code>abstract class SomeAbstractClass\n{\n    public string $foo;\n\n    public string $bar;\n}\n\nfinal class SomeChildClass extends SomeAbstractClass\n{\n    public string $baz;\n}\n\n$result = (new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;infer(\n        SomeAbstractClass::class,\n        fn () =&gt; SomeChildClass::class\n    )\n    -&gt;mapper()\n    -&gt;map(SomeAbstractClass::class, [\n        'foo' =&gt; 'foo',\n        'bar' =&gt; 'bar',\n        'baz' =&gt; 'baz',\n    ]);\n\nassert($result instanceof SomeChildClass);\nassert($result-&gt;foo === 'foo');\nassert($result-&gt;bar === 'bar');\nassert($result-&gt;baz === 'baz');\n</code></pre>"},{"location":"project/changelog/version-1.1.0/#features","title":"Features","text":"<ul> <li>Add support for class inferring (5a90ad)</li> <li>Handle class generic types inheritance (6506b7)</li> </ul>"},{"location":"project/changelog/version-1.1.0/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Handle <code>object</code> return type in PHPStan extension (201728)</li> <li>Import plugin class file in PHPStan configuration (58d540)</li> <li>Keep nested errors when superfluous keys are detected (813b3b)</li> </ul>"},{"location":"project/changelog/version-1.1.0/#other","title":"Other","text":"<ul> <li>Adapt code with PHP 8.0 syntax (3fac3e)</li> <li>Add <code>isAbstract</code> flag in class definition (ad0c06)</li> <li>Add <code>isFinal</code> flag in class definition (25da31)</li> <li>Enhance <code>TreeMapper::map()</code> return type signature (dc32d3)</li> <li>Improve return type signature for <code>TreeMapper</code> (c8f362)</li> <li>Prevent multiple cache round-trip (13b620)</li> </ul>"},{"location":"project/changelog/version-1.2.0/","title":"Changelog 1.2.0 \u2014 9th of January 2023","text":"<p>See release on GitHub</p>"},{"location":"project/changelog/version-1.2.0/#notable-changes","title":"Notable changes","text":"<p>Handle single property/constructor argument with array input</p> <p>It is now possible, again, to use an array for a single node (single class property or single constructor argument), if this array has one value with a key matching the argument/property name.</p> <p>This is a revert of a change that was introduced in a previous commit: see hash 72cba320f582c7cda63865880a1cbf7ea292d2b1</p>"},{"location":"project/changelog/version-1.2.0/#features","title":"Features","text":"<ul> <li>Allow usage of array input for single node during mapping (686186)</li> </ul>"},{"location":"project/changelog/version-1.2.0/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Do not re-validate single node with existing error (daaaac)</li> </ul>"},{"location":"project/changelog/version-1.2.0/#other","title":"Other","text":"<ul> <li>Remove unneeded internal check (86cca5)</li> <li>Remove unneeded internal checks and exceptions (157723)</li> </ul>"},{"location":"project/changelog/version-1.3.0/","title":"Changelog 1.3.0 \u2014 8th of February 2023","text":"<p>See release on GitHub</p>"},{"location":"project/changelog/version-1.3.0/#notable-changes","title":"Notable changes","text":"<p>Handle custom enum constructors registration</p> <p>It is now possible to register custom constructors for enum, the same way it could be done for classes.</p> <pre><code>(new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;registerConstructor(\n        // Allow the native constructor to be used\n        SomeEnum::class,\n\n        // Register a named constructor\n        SomeEnum::fromMatrix(...)\n    )\n    -&gt;mapper()\n    -&gt;map(SomeEnum::class, [\n        'type' =&gt; 'FOO',\n        'number' =&gt; 'BAR',\n    ]);\n\nenum SomeEnum: string\n{\n    case CASE_A = 'FOO_VALUE_1';\n    case CASE_B = 'FOO_VALUE_2';\n    case CASE_C = 'BAR_VALUE_1';\n    case CASE_D = 'BAR_VALUE_2';\n\n    /**\n     * @param 'FOO'|'BAR' $type\n     * @param int&lt;1, 2&gt; $number\n     * /\n    public static function fromMatrix(string $type, int $number): self\n    {\n        return self::from(\"{$type}_VALUE_{$number}\");\n    }\n}\n</code></pre> <p>An enum constructor can be for a specific pattern:</p> <pre><code>enum SomeEnum\n{\n    case FOO;\n    case BAR;\n    case BAZ;\n}\n\n(new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;registerConstructor(\n        /**\n         * This constructor will be called only when pattern\n         * `SomeEnum::BA*` is requested during mapping.\n         *\n         * @return SomeEnum::BA*\n         */\n        fn (string $value): SomeEnum =&gt; /* Some custom domain logic */\n    )\n    -&gt;mapper()\n    -&gt;map(SomeEnum::class . '::BA*', 'some custom value');\n</code></pre> <p>Note that this commit required heavy refactoring work, leading to a regression for union types containing enums and other types. As these cases are considered marginal, this change is considered non-breaking.</p>"},{"location":"project/changelog/version-1.3.0/#features","title":"Features","text":"<ul> <li>Handle custom enum constructors registration (217e12)</li> </ul>"},{"location":"project/changelog/version-1.3.0/#other","title":"Other","text":"<ul> <li>Handle enum type as class type (5a3caf)</li> </ul>"},{"location":"project/changelog/version-1.3.1/","title":"Changelog 1.3.1 \u2014 13th of February 2023","text":"<p>See release on GitHub</p> <p>Bugfix release.</p>"},{"location":"project/changelog/version-1.3.1/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Check if temporary cache file exists before deletion (3177bf)</li> <li>Display useful error message for invalid constructor return type (dc7f5c)</li> <li>Keep input path when error occurs in single node (d70257)</li> <li>Properly handle class static constructor for other class (d34974)</li> <li>Properly handle union of <code>null</code> and objects (8f03a7)</li> </ul>"},{"location":"project/changelog/version-1.3.1/#other","title":"Other","text":"<ul> <li>Update dependencies (f7e7f2)</li> </ul>"},{"location":"project/changelog/version-1.4.0/","title":"Changelog 1.4.0 \u2014 17th of April 2023","text":"<p>See release on GitHub</p>"},{"location":"project/changelog/version-1.4.0/#notable-changes","title":"Notable changes","text":"<p>Exception thrown when source is invalid</p> <p>JSON or YAML given to a source may be invalid, in which case an exception can now be caught and manipulated.</p> <pre><code>try {\n    $source = \\CuyZ\\Valinor\\Mapper\\Source\\Source::json('invalid JSON');\n} catch (\\CuyZ\\Valinor\\Mapper\\Source\\Exception\\InvalidSource $error) {\n    // Let the application handle the exception in the desired way.\n    // It is possible to get the original source with `$error-&gt;source()`\n}\n</code></pre>"},{"location":"project/changelog/version-1.4.0/#features","title":"Features","text":"<ul> <li>Introduce <code>InvalidSource</code> thrown when using invalid JSON/YAML (0739d1)</li> </ul>"},{"location":"project/changelog/version-1.4.0/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Allow integer values in float types (c6df24)</li> <li>Make <code>array-key</code> type match <code>mixed</code> (ccebf7)</li> <li>Prevent infinite loop when class has parent class with same name (83eb05)</li> </ul>"},{"location":"project/changelog/version-1.4.0/#other","title":"Other","text":"<ul> <li>Add previous exception in various custom exceptions (b9e381)</li> </ul>"},{"location":"project/changelog/version-1.5.0/","title":"Changelog 1.5.0 \u2014 7th of August 2023","text":"<p>See release on GitHub</p>"},{"location":"project/changelog/version-1.5.0/#features","title":"Features","text":"<ul> <li>Introduce method to get date formats supported during mapping (873961)</li> </ul>"},{"location":"project/changelog/version-1.5.0/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Allow filesystem cache to be cleared when directory does not exist (782408)</li> <li>Allow negative timestamp to be mapped to a datetime (d358e8)</li> <li>Allow overriding of supported datetime formats (1c70c2)</li> <li>Correctly handle message formatting for long truncated UTF8 strings (0a8f37)</li> <li>Make serialization of attributes possible (e8ca2f)</li> <li>Remove exception inheritance from <code>UnresolvableType</code> (eaa128)</li> <li>Remove previous exception from <code>UnresolvableType</code> (5c89c6)</li> </ul>"},{"location":"project/changelog/version-1.5.0/#other","title":"Other","text":"<ul> <li>Avoid using <code>unserialize</code> when caching <code>NULL</code> default values (5e9b4c)</li> <li>Catch <code>json_encode</code> exception to help identifying parsing errors (861c3b)</li> <li>Update dependencies (c31e5c, 5fa107)</li> </ul>"},{"location":"project/changelog/version-1.6.0/","title":"Changelog 1.6.0 \u2014 25th of August 2023","text":"<p>See release on GitHub</p>"},{"location":"project/changelog/version-1.6.0/#notable-changes","title":"Notable changes","text":"<p>Symfony Bundle</p> <p>A bundle is now available for Symfony applications, it will ease the integration and usage of the Valinor library in the framework. The documentation can be  found in the CuyZ/Valinor-Bundle repository.</p> <p>Note that the documentation has been updated to add information about the bundle as well as tips on how to integrate the library in other frameworks.</p> <p>PHP 8.3 support</p> <p>Thanks to @TimWolla, the library now supports PHP 8.3, which entered its beta phase. Do not hesitate to test the library with this new version, and report any encountered issue on the repository.</p> <p>Better type parsing</p> <p>The first layer of the type parser has been completely rewritten. The previous one would use regex to split a raw type in tokens, but that led to limitations \u2014 mostly concerning quoted strings \u2014 that are now fixed.</p> <p>Although this change should not impact the end user, it is a major change in the library, and it is possible that some edge cases were not covered by tests. If that happens, please report any encountered issue on the repository.</p> <p>Example of previous limitations, now solved:</p> <pre><code>// Union of strings containing space chars\n(new MapperBuilder())\n    -&gt;mapper()\n    -&gt;map(\n        \"'foo bar'|'baz fiz'\",\n        'baz fiz'\n    );\n\n// Shaped array with special chars in the key\n(new MapperBuilder())\n    -&gt;mapper()\n    -&gt;map(\n        \"array{'some &amp; key': string}\",\n        ['some &amp; key' =&gt; 'value']\n    );\n</code></pre> <p>More advanced array-key handling</p> <p>It is now possible to use any string or integer as an array key. The following types are now accepted and will work properly with the mapper:</p> <pre><code>$mapper-&gt;map(\"array&lt;'foo'|'bar', string&gt;\", ['foo' =&gt; 'foo']);\n\n$mapper-&gt;map('array&lt;42|1337, string&gt;', [42 =&gt; 'foo']);\n\n$mapper-&gt;map('array&lt;positive-int, string&gt;', [42 =&gt; 'foo']);\n\n$mapper-&gt;map('array&lt;negative-int, string&gt;', [-42 =&gt; 'foo']);\n\n$mapper-&gt;map('array&lt;int&lt;-42, 1337&gt;, string&gt;', [42 =&gt; 'foo']);\n\n$mapper-&gt;map('array&lt;non-empty-string, string&gt;', ['foo' =&gt; 'foo']);\n\n$mapper-&gt;map('array&lt;class-string, string&gt;', ['SomeClass' =&gt; 'foo']);\n</code></pre>"},{"location":"project/changelog/version-1.6.0/#features","title":"Features","text":"<ul> <li>Add support for PHP 8.3 (5c44f8)</li> <li>Allow any string or integer in array key (12af3e)</li> <li>Support microseconds in the Atom / RFC 3339 / ISO 8601 format (c25721)</li> </ul>"},{"location":"project/changelog/version-1.6.0/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Correctly handle type inferring for method coming from interface (2657f8)</li> <li>Detect missing closing bracket after comma in shaped array type (2aa4b6)</li> <li>Handle class name collision while parsing types inside a class (044072)</li> <li>Handle invalid Intl formats with <code>intl.use_exceptions=1</code> (29da9a)</li> <li>Improve cache warmup by creating required directories (a3341a)</li> <li>Load attributes lazily during runtime and cache access (3e7c63)</li> <li>Properly handle class/enum name in shaped array key (1964d4)</li> </ul>"},{"location":"project/changelog/version-1.6.0/#other","title":"Other","text":"<ul> <li>Improve attributes arguments compilation (c4acb1)</li> <li>Replace regex-based type parser with character-based one (ae8303)</li> <li>Simplify symbol parsing algorithm (f260cf)</li> <li>Update Rector dependency (669ff9)</li> </ul>"},{"location":"project/changelog/version-1.6.1/","title":"Changelog 1.6.1 \u2014 11th of October 2023","text":"<p>See release on GitHub</p>"},{"location":"project/changelog/version-1.6.1/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Correctly handle multiline type alias in classes (c23102)</li> <li>Handle integer key in path mapping modifier (9419f6)</li> <li>Handle variadic parameters declared in docblock (f4884c)</li> </ul>"},{"location":"project/changelog/version-1.7.0/","title":"Changelog 1.7.0 \u2014 23rd of October 2023","text":"<p>See release on GitHub</p>"},{"location":"project/changelog/version-1.7.0/#notable-changes","title":"Notable changes","text":"<p>Non-positive integer</p> <p>Non-positive integer can be used as below. It will accept any value equal to or lower than zero.</p> <pre><code>final class SomeClass\n{\n    /** @var non-positive-int */\n    public int $nonPositiveInteger;\n}\n</code></pre> <p>Non-negative integer</p> <p>Non-negative integer can be used as below. It will accept any value equal to or greater than zero.</p> <pre><code>final class SomeClass\n{\n    /** @var non-negative-int */\n    public int $nonNegativeInteger;\n}\n</code></pre>"},{"location":"project/changelog/version-1.7.0/#features","title":"Features","text":"<ul> <li>Handle non-negative integer type (f444ea)</li> <li>Handle non-positive integer type (53e404)</li> </ul>"},{"location":"project/changelog/version-1.7.0/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Add missing <code>@psalm-pure</code> annotation to pure methods (004eb1)</li> <li>Handle comments in classes when parsing types imports (3b663a)</li> </ul>"},{"location":"project/changelog/version-1.7.0/#other","title":"Other","text":"<ul> <li>Add comment for future PHP version change (461898)</li> <li>Fix some typos (5cf8ae)</li> <li>Make <code>NativeBooleanType</code> a <code>BooleanType</code> (d57ffa)</li> </ul>"},{"location":"project/changelog/version-1.8.0/","title":"Changelog 1.8.0 \u2014 26th of December 2023","text":"<p>See release on GitHub</p>"},{"location":"project/changelog/version-1.8.0/#notable-changes","title":"Notable changes","text":"<p>Normalizer service (serialization)</p> <p>This new service can be instantiated with the <code>MapperBuilder</code>. It allows transformation of a given input into scalar and array values, while preserving the original structure.</p> <p>This feature can be used to share information with other systems that use a data format (JSON, CSV, XML, etc.). The normalizer will take care of recursively  transforming the data into a format that can be serialized.</p> <p>Below is a basic example, showing the transformation of objects into an array of scalar values.</p> <pre><code>namespace My\\App;\n\n$normalizer = (new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;normalizer(\\CuyZ\\Valinor\\Normalizer\\Format::array());\n\n$userAsArray = $normalizer-&gt;normalize(\n    new \\My\\App\\User(\n        name: 'John Doe',\n        age: 42,\n        country: new \\My\\App\\Country(\n            name: 'France',\n            countryCode: 'FR',\n        ),\n    )\n);\n\n// `$userAsArray` is now an array and can be manipulated much more\n// easily, for instance to be serialized to the wanted data format.\n//\n// [\n//     'name' =&gt; 'John Doe',\n//     'age' =&gt; 42,\n//     'country' =&gt; [\n//         'name' =&gt; 'France',\n//         'countryCode' =&gt; 'FR',\n//     ],\n// ];\n</code></pre> <p>A normalizer can be extended by using so-called transformers, which can be either an attribute or any callable object.</p> <p>In the example below, a global transformer is used to format any date found by the normalizer.</p> <pre><code>(new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;registerTransformer(\n        fn (\\DateTimeInterface $date) =&gt; $date-&gt;format('Y/m/d')\n    )\n    -&gt;normalizer(\\CuyZ\\Valinor\\Normalizer\\Format::array())\n    -&gt;normalize(\n        new \\My\\App\\Event(\n            eventName: 'Release of legendary album',\n            date: new \\DateTimeImmutable('1971-11-08'),\n        )\n    );\n\n// [\n//     'eventName' =&gt; 'Release of legendary album',\n//     'date' =&gt; '1971/11/08',\n// ]\n</code></pre> <p>This date transformer could have been an attribute for a more granular control, as shown below.</p> <pre><code>namespace My\\App;\n\n#[\\Attribute(\\Attribute::TARGET_PROPERTY)]\nfinal class DateTimeFormat\n{\n    public function __construct(private string $format) {}\n\n    public function normalize(\\DateTimeInterface $date): string\n    {\n        return $date-&gt;format($this-&gt;format);\n    }\n}\n\nfinal readonly class Event\n{\n    public function __construct(\n        public string $eventName,\n        #[\\My\\App\\DateTimeFormat('Y/m/d')]\n        public \\DateTimeInterface $date,\n    ) {}\n}\n\n(new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;registerTransformer(\\My\\App\\DateTimeFormat::class)\n    -&gt;normalizer(\\CuyZ\\Valinor\\Normalizer\\Format::array())\n    -&gt;normalize(\n        new \\My\\App\\Event(\n            eventName: 'Release of legendary album',\n            date: new \\DateTimeImmutable('1971-11-08'),\n        )\n    );\n\n// [\n//     'eventName' =&gt; 'Release of legendary album',\n//     'date' =&gt; '1971/11/08',\n// ]\n</code></pre> <p>More features are available, details about it can be found in the documentation.</p>"},{"location":"project/changelog/version-1.8.0/#features","title":"Features","text":"<ul> <li>Introduce normalizer service (1c9368)</li> </ul>"},{"location":"project/changelog/version-1.8.0/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Allow leading zeros in numeric string in flexible mode (f000c1)</li> <li>Allow mapping union of scalars and classes (4f4af0)</li> <li>Properly handle single-namespaced classes (a53ef9)</li> <li>Properly parse class name in same single-namespace (a462fe)</li> </ul>"},{"location":"project/changelog/version-1.8.1/","title":"Changelog 1.8.1 \u2014 8th of January 2024","text":"<p>See release on GitHub</p>"},{"location":"project/changelog/version-1.8.1/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Properly detect namespaced class in docblock (6f7c77)</li> </ul>"},{"location":"project/changelog/version-1.8.2/","title":"Changelog 1.8.2 \u2014 8th of January 2024","text":"<p>See release on GitHub</p>"},{"location":"project/changelog/version-1.8.2/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Allow callable type to be compiled (4a9771f)</li> </ul>"},{"location":"serialization/common-examples/","title":"Common transformers examples","text":"<p>Instead of providing transformers out-of-the-box, this library focuses on easing the creation of custom ones. This way, the normalizer is not tied up to a third-party library release-cycle and can be adapted to fit the needs of the application's business logics.</p> <p>Below is a list of common features that can inspire or be implemented by third-party libraries or applications.</p> <p>Info</p> <p>These examples are not available out-of-the-box, they can be implemented using the library's API and should be adapted to fit the needs of the application.</p> <ul> <li>Customizing dates format</li> <li>Transforming property name to \u201csnake_case\u201d</li> <li>Ignoring properties</li> <li>Renaming properties</li> <li>Transforming objects</li> <li>Versioning API</li> </ul>"},{"location":"serialization/common-examples/#customizing-dates-format","title":"Customizing dates format","text":"<p>By default, dates will be formatted using the RFC 3339 format, but it may be needed to use another format. </p> <p>This can be done on all dates, using a global transformer, as shown in the example below:</p> Show code example \u2014 Global date format <pre><code>(new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;registerTransformer(\n        fn (\\DateTimeInterface $date) =&gt; $date-&gt;format('Y/m/d')\n    )\n    -&gt;normalizer(\\CuyZ\\Valinor\\Normalizer\\Format::array())\n    -&gt;normalize(\n        new \\My\\App\\Event(\n            eventName: 'Release of legendary album',\n            date: new \\DateTimeImmutable('1971-11-08'),\n        )\n    );\n\n// [\n//     'eventName' =&gt; 'Release of legendary album',\n//     'date' =&gt; '1971/11/08',\n// ]\n</code></pre> <p>For a more granular control, an attribute can be used to target a specific property, as shown in the example below:</p> Show code example \u2014 Date format attribute <pre><code>namespace My\\App;\n\n#[\\Attribute(\\Attribute::TARGET_PROPERTY)]\nfinal class DateTimeFormat\n{\n    public function __construct(private string $format) {}\n\n    public function normalize(\\DateTimeInterface $date): string\n    {\n        return $date-&gt;format($this-&gt;format);\n    }\n}\n\nfinal readonly class Event\n{\n    public function __construct(\n        public string $eventName,\n        #[\\My\\App\\DateTimeFormat('Y/m/d')]\n        public \\DateTimeInterface $date,\n    ) {}\n}\n\n(new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;registerTransformer(\\My\\App\\DateTimeFormat::class)\n    -&gt;normalizer(\\CuyZ\\Valinor\\Normalizer\\Format::array())\n    -&gt;normalize(\n        new \\My\\App\\Event(\n            eventName: 'Release of legendary album',\n            date: new \\DateTimeImmutable('1971-11-08'),\n        )\n    );\n\n// [\n//     'eventName' =&gt; 'Release of legendary album',\n//     'date' =&gt; '1971/11/08',\n// ]\n</code></pre>"},{"location":"serialization/common-examples/#transforming-property-name-to-snake_case","title":"Transforming property name to \u201csnake_case\u201d","text":"<p>Depending on the conventions of the data format, it may be necessary to transform the case of the keys, for instance from \u201ccamelCase\u201d to \u201csnake_case\u201d.</p> <p>If this transformation is needed on every object, it can be done globally by using a global transformer, as shown in the example below:</p> Show code example \u2014 global \u201csnake_case\u201d properties <pre><code>namespace My\\App;\n\nfinal class CamelToSnakeCaseTransformer\n{\n    public function __invoke(object $object, callable $next): mixed\n    {\n        $result = $next();\n\n        if (! is_array($result)) {\n            return $result;\n        }\n\n        $snakeCased = [];\n\n        foreach ($result as $key =&gt; $value) {\n            $newKey = strtolower(preg_replace('/[A-Z]/', '_$0', lcfirst($key)));\n\n            $snakeCased[$newKey] = $value;\n        }\n\n        return $snakeCased;\n    }\n}\n\n(new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;registerTransformer(new \\My\\App\\CamelToSnakeCaseTransformer())\n    -&gt;normalizer(\\CuyZ\\Valinor\\Normalizer\\Format::array())\n    -&gt;normalize(\n         new \\My\\App\\User(\n            name: 'John Doe',\n            emailAddress: 'john.doe@example.com', \n            age: 42,\n            country: new Country(\n                name: 'France',\n                countryCode: 'FR',\n            ),\n        )\n    );\n\n// [\n//     'name' =&gt; 'John Doe',\n//     'email_address' =&gt; 'john.doe@example', // snake_case\n//     'age' =&gt; 42,\n//     'country' =&gt; [\n//         'name' =&gt; 'France',\n//         'country_code' =&gt; 'FR', // snake_case\n//     ],\n// ]\n</code></pre> <p>For a more granular control, an attribute can be used to target specific objects, as shown in the example below:</p> Show code example \u2014 \u201csnake_case\u201d attribute <pre><code>namespace My\\App;\n\n#[\\Attribute(\\Attribute::TARGET_CLASS)]\nfinal class SnakeCaseProperties\n{\n    public function normalize(object $object, callable $next): array\n    {\n        $result = $next();\n\n        if (! is_array($result)) {\n            return $result;\n        }\n\n        $snakeCased = [];\n\n        foreach ($result as $key =&gt; $value) {\n            $newKey = strtolower(preg_replace('/[A-Z]/', '_$0', lcfirst($key)));\n\n            $snakeCased[$newKey] = $value;\n        }\n\n        return $snakeCased;\n    }\n}\n\n#[SnakeCaseProperties]\nfinal readonly class Country\n{\n    public function __construct(\n        public string $name,\n        public string $countryCode,\n    ) {}\n}\n\n(new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;registerTransformer(\\My\\App\\SnakeCaseProperties::class)\n    -&gt;normalizer(\\CuyZ\\Valinor\\Normalizer\\Format::array())\n    -&gt;normalize(\n        new \\My\\App\\User(\n            name: 'John Doe',\n            emailAddress: 'john.doe@example.com',\n            age: 42,\n            country: new Country(\n                name: 'France',\n                countryCode: 'FR',\n            ),\n        )\n    );\n\n// [\n//     'name' =&gt; 'John Doe',\n//     'emailAddress' =&gt; 'john.doe@example', // camelCase\n//     'age' =&gt; 42,\n//     'country' =&gt; [\n//         'name' =&gt; 'France',\n//         'country_code' =&gt; 'FR', // snake_case\n//     ],\n// ]\n</code></pre>"},{"location":"serialization/common-examples/#ignoring-properties","title":"Ignoring properties","text":"<p>Some objects might want to omit some properties during normalization, for instance, to hide sensitive data.</p> <p>In the example below, an attribute is added on a property that will replace the value with a custom object that is afterward removed by a global transformer. </p> Show code example \u2014 Ignore property attribute <pre><code>namespace My\\App;\n\n#[\\Attribute(\\Attribute::TARGET_PROPERTY)]\nfinal class Ignore\n{\n    public function normalize(mixed $value): IgnoredValue\n    {\n        return new \\My\\App\\IgnoredValue();\n    }\n}\n\nfinal class IgnoredValue\n{\n    public function __construct() {}\n}\n\nfinal readonly class User\n{\n    public function __construct(\n        public string $name,\n        #[\\My\\App\\Ignore]\n        public string $password,\n    ) {}\n}\n\n(new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;registerTransformer(\\My\\App\\Ignore::class)\n    -&gt;registerTransformer(\n        fn (object $value, callable $next) =&gt; array_filter(\n            $next(),\n            fn (mixed $value) =&gt; ! $value instanceof \\My\\App\\IgnoredValue,\n        ),\n    )\n    -&gt;normalizer(\\CuyZ\\Valinor\\Normalizer\\Format::array())\n    -&gt;normalize(new \\My\\App\\User(\n        name: 'John Doe',\n        password: 's3cr3t-p4$$w0rd')\n    );\n\n// ['name' =&gt; 'John Doe']\n</code></pre>"},{"location":"serialization/common-examples/#renaming-properties","title":"Renaming properties","text":"<p>Properties' names can differ between the object and the data format.</p> <p>In the example below, an attribute is added on properties that need to be renamed during normalization</p> Show code example \u2014 Rename property attribute <pre><code>namespace My\\App;\n\n#[\\Attribute(\\Attribute::TARGET_PROPERTY)]\nfinal class Rename\n{\n    public function __construct(private string $name) {}\n\n    public function normalizeKey(): string\n    {\n        return $this-&gt;name;\n    }\n}\n\nfinal readonly class Address\n{\n    public function __construct(\n        public string $street,\n        public string $zipCode,\n        #[\\My\\App\\Rename('town')]\n        public string $city,\n    ) {}\n}\n\n(new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;registerTransformer(\\My\\App\\Rename::class)\n    -&gt;normalizer(\\CuyZ\\Valinor\\Normalizer\\Format::array())\n    -&gt;normalize(\n        new Address(\n            street: '221B Baker Street', \n            zipCode: 'NW1 6XE', \n            city: 'London', \n        )\n    );\n\n// [\n//     'street' =&gt; '221B Baker Street',\n//     'zipCode' =&gt; 'NW1 6XE',\n//     'town' =&gt; 'London',\n// ]\n</code></pre>"},{"location":"serialization/common-examples/#transforming-objects","title":"Transforming objects","text":"<p>Some objects can have custom behaviors during normalization, for instance properties may need to be remapped. In the example below, a transformer will check if an object defines a <code>normalize</code> method and use it if it exists.</p> Show code example \u2014 Custom object normalization <pre><code>namespace My\\App;\n\nfinal readonly class Address\n{\n    public function __construct(\n        public string $road,\n        public string $zipCode,\n        public string $town,\n    ) {}\n\n    public function normalize(): array\n    {\n        return [\n            'street' =&gt; $this-&gt;road,\n            'postalCode' =&gt; $this-&gt;zipCode,\n            'city' =&gt; $this-&gt;town,\n        ];\n    }\n}\n\n(new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;registerTransformer(function (object $object, callable $next) {\n        return method_exists($object, 'normalize')\n            ? $object-&gt;normalize()\n            : $next();\n    })\n    -&gt;normalizer(\\CuyZ\\Valinor\\Normalizer\\Format::array())\n    -&gt;normalize(\n        new \\My\\App\\Address(\n            road: '221B Baker Street',\n            zipCode: 'NW1 6XE',\n            town: 'London',\n        ),\n    );\n\n// [\n//     'street' =&gt; '221B Baker Street',\n//     'postalCode' =&gt; 'NW1 6XE',\n//     'city' =&gt; 'London',\n// ]\n</code></pre>"},{"location":"serialization/common-examples/#versioning-api","title":"Versioning API","text":"<p>API versioning can be implemented with different strategies and algorithms. The example below shows how objects can implement an interface to specify their own specific versioning behavior.</p> Show code example \u2014 Versioning objects <pre><code>namespace My\\App;\n\ninterface HasVersionedNormalization\n{\n    public function normalizeWithVersion(string $version): mixed;\n}\n\nfinal readonly class Address implements \\My\\App\\HasVersionedNormalization\n{\n    public function __construct(\n        public string $streetNumber,\n        public string $streetName,\n        public string $zipCode,\n        public string $city,\n    ) {}\n\n    public function normalizeWithVersion(string $version): array\n    {\n        return match (true) {\n            version_compare($version, '1.0.0', '&lt;') =&gt; [\n                // Street number and name are merged in a single property\n                'street' =&gt; \"$this-&gt;streetNumber, $this-&gt;streetName\",\n                'zipCode' =&gt; $this-&gt;zipCode,\n                'city' =&gt; $this-&gt;city,\n            ],\n            default =&gt; get_object_vars($this),\n        };\n    }\n}\n\nfunction normalizeWithVersion(string $version): mixed\n{\n    return (new \\CuyZ\\Valinor\\MapperBuilder())\n        -&gt;registerTransformer(\n            fn (\\My\\App\\HasVersionedNormalization $object) =&gt; $object-&gt;normalizeWithVersion($version)\n        )\n        -&gt;normalizer(\\CuyZ\\Valinor\\Normalizer\\Format::array())\n        -&gt;normalize(\n            new \\My\\App\\Address(\n                streetNumber: '221B',\n                streetName: 'Baker Street',\n                zipCode: 'NW1 6XE',\n                city: 'London',\n            )\n        );\n}\n\n// Version can come for instance from HTTP request headers\n$result_v0_4 = normalizeWithVersion('0.4');\n$result_v1_8 = normalizeWithVersion('1.8');\n\n// $result_v0_4 === [\n//     'street' =&gt; '221B, Baker Street',\n//     'zipCode' =&gt; 'NW1 6XE',\n//     'city' =&gt; 'London',\n// ]\n// \n// $result_v1_8 === [\n//     'streetNumber' =&gt; '221B',\n//     'streetName' =&gt; 'Baker Street',\n//     'zipCode' =&gt; 'NW1 6XE',\n//     'city' =&gt; 'London',\n// ]\n</code></pre>"},{"location":"serialization/normalizer/","title":"Normalizing data","text":"<p>A normalizer is a service that transforms a given input into scalar and array values, while preserving the original structure.</p> <p>This feature can be used to share information with other systems that use a data format (JSON, CSV, XML, etc.). The normalizer will take care of recursively transforming the data into a format that can be serialized.</p> <p>Info</p> <p>The library only supports normalizing to arrays, but aims to support other formats like JSON or CSV in the future.</p> <p>In the meantime, native functions like <code>json_encode()</code> may be used as an alternative.</p>"},{"location":"serialization/normalizer/#basic-usage","title":"Basic usage","text":"<pre><code>namespace My\\App;\n\n$normalizer = (new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;normalizer(\\CuyZ\\Valinor\\Normalizer\\Format::array());\n\n$userAsArray = $normalizer-&gt;normalize(\n    new \\My\\App\\User(\n        name: 'John Doe',\n        age: 42,\n        country: new \\My\\App\\Country(\n            name: 'France',\n            countryCode: 'FR',\n        ),\n    )\n);\n\n// `$userAsArray` is now an array and can be manipulated much more easily, for\n// instance to be serialized to the wanted data format.\n//\n// [\n//     'name' =&gt; 'John Doe',\n//     'age' =&gt; 42,\n//     'country' =&gt; [\n//         'name' =&gt; 'France',\n//         'countryCode' =&gt; 'FR',\n//     ],\n// ];\n</code></pre>"},{"location":"serialization/normalizer/#extending-the-normalizer","title":"Extending the normalizer","text":"<p>This library provides a normalizer out-of-the-box that can be used as-is, or extended to add custom logic. To do so, transformers must be registered within the <code>MapperBuilder</code>.</p> <p>A transformer can be a callable (function, closure or a class implementing the <code>__invoke()</code> method), or an attribute that can target a class or a property.</p> <p>Note</p> <p>You can find common examples of transformers in the next chapter.</p>"},{"location":"serialization/normalizer/#callable-transformers","title":"Callable transformers","text":"<p>A callable transformer must declare at least one argument, for which the type will determine when it is used during normalization. In the example below, a global transformer is used to format any date found by the normalizer.</p> <pre><code>(new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;registerTransformer(\n        fn (\\DateTimeInterface $date) =&gt; $date-&gt;format('Y/m/d')\n    )\n    -&gt;normalizer(\\CuyZ\\Valinor\\Normalizer\\Format::array())\n    -&gt;normalize(\n        new \\My\\App\\Event(\n            eventName: 'Release of legendary album',\n            date: new \\DateTimeImmutable('1971-11-08'),\n        )\n    );\n\n// [\n//     'eventName' =&gt; 'Release of legendary album',\n//     'date' =&gt; '1971/11/08',\n// ]\n</code></pre> <p>Transformers can be chained. To do so, a second parameter of type <code>callable</code> must be declared in a transformer. This parameter \u2014 named <code>$next</code> by convention \u2014 can be used whenever needed in the transformer logic.</p> <pre><code>(new \\CuyZ\\Valinor\\MapperBuilder())\n\n    // The type of the first parameter of the transformer will determine when it\n    // is used during normalization.\n    -&gt;registerTransformer(\n        fn (string $value, callable $next) =&gt; strtoupper($next())\n    )\n\n    // Transformers can be chained, the last registered one will take precedence\n    // over the previous ones, which can be called using the `$next` parameter.\n    -&gt;registerTransformer(\n        /**\n         * Advanced type annotations like `non-empty-string` can be used to\n         * target a more specific type.\n         * \n         * @param non-empty-string $value \n         */\n        fn (string $value, callable $next) =&gt; $next() . '!'\n    )\n\n    // A priority can be given to a transformer, to make sure it is called\n    // before or after another one. The higher priority, the sooner the\n    // transformer will be called. The default priority is 0.\n    -&gt;registerTransformer(\n        /**\n         * @param non-empty-string $value \n         */\n        fn (string $value, callable $next) =&gt; $next() . '?',\n        priority: 100\n    )\n\n    -&gt;normalizer(\\CuyZ\\Valinor\\Normalizer\\Format::array())\n    -&gt;normalize('Hello world'); // HELLO WORLD!?\n</code></pre>"},{"location":"serialization/normalizer/#attribute-transformers","title":"Attribute transformers","text":"<p>Callable transformers allow targeting any value during normalization, whereas attribute transformers allow targeting a specific class or property for a more granular control.</p> <p>To be detected by the normalizer, an attribute must be registered first by giving its class name to the <code>registerTransformer</code> method.</p> <p>Tip</p> <p>It is possible to register attributes that share a common interface by giving the interface name to the method.</p> <pre><code>namespace My\\App;\n\ninterface SomeAttributeInterface {}\n\n#[\\Attribute]\nfinal class SomeAttribute implements \\My\\App\\SomeAttributeInterface {}\n\n#[\\Attribute]\nfinal class SomeOtherAttribute implements \\My\\App\\SomeAttributeInterface {}\n\n(new \\CuyZ\\Valinor\\MapperBuilder())\n    // Registers both `SomeAttribute` and `SomeOtherAttribute` attributes\n    -&gt;registerTransformer(\\My\\App\\SomeAttributeInterface::class)\n    \u2026\n</code></pre> <p>Attributes must declare a method named <code>normalize</code> that follows the same rules as callable transformers: a mandatory first parameter and an optional second <code>callable</code> parameter.</p> <pre><code>namespace My\\App;\n\n#[\\Attribute(\\Attribute::TARGET_PROPERTY)]\nfinal class Uppercase\n{\n    public function normalize(string $value, callable $next): string\n    {\n        return strtoupper($next());\n    }\n}\n\nfinal readonly class City\n{\n    public function __construct(\n        public string $zipCode,\n        #[Uppercase]\n        public string $name,\n        #[Uppercase]\n        public string $country,\n    ) {}\n}\n\n(new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;registerTransformer(Uppercase::class)\n    -&gt;normalizer(\\CuyZ\\Valinor\\Normalizer\\Format::array())\n    -&gt;normalize(\n        new \\My\\App\\City(\n            zipCode: 'NW1 6XE',\n            name: 'London',\n            country: 'United Kingdom',\n        ) \n    );\n\n// [\n//     'zipCode' =&gt; 'NW1 6XE',\n//     'name' =&gt; 'LONDON',\n//     'country' =&gt; 'UNITED KINGDOM',\n// ]\n</code></pre> <p>If an attribute needs to transform the key of a property, it needs to declare a method named <code>normalizeKey</code>.</p> <pre><code>namespace My\\App;\n\n#[\\Attribute(\\Attribute::TARGET_PROPERTY)]\nfinal class PrefixedWith\n{\n    public function __construct(private string $prefix) {}\n\n    public function normalizeKey(string $value): string\n    {\n        return $this-&gt;prefix . $value;\n    }\n}\n\nfinal readonly class Address\n{\n    public function __construct(\n        #[\\My\\App\\PrefixedWith('address_')]\n        public string $road,\n        #[\\My\\App\\PrefixedWith('address_')]\n        public string $zipCode,\n        #[\\My\\App\\PrefixedWith('address_')]\n        public string $city,\n    ) {}\n}\n\n(new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;registerTransformer(PrefixedWith::class)\n    -&gt;normalizer(\\CuyZ\\Valinor\\Normalizer\\Format::array())\n    -&gt;normalize(\n        new \\My\\App\\Address(\n            road: '221B Baker Street',\n            zipCode: 'NW1 6XE',\n            city: 'London',\n        ) \n    );\n\n// [\n//     'address_road' =&gt; '221B Baker Street',\n//     'address_zipCode' =&gt; 'NW1 6XE',\n//     'address_city' =&gt; 'London',\n// ]\n</code></pre>"},{"location":"usage/object-construction/","title":"Object construction","text":"<p>During the mapping, instances of objects are recursively created and hydrated with values coming from the input.</p> <p>The values of an object are filled either with a constructor \u2014 which is the recommended way \u2014 or using the class properties. If a constructor exists, it will be used to create the object, otherwise the properties will be filled directly.</p> <p>By default, the library will use a native constructor of a class if it is public; for advanced use cases, the library also allows the usage of custom constructors.</p>"},{"location":"usage/object-construction/#class-with-a-single-value","title":"Class with a single value","text":"<p>When an object needs only one value (one constructor argument or one property), the source given to the mapper can match the type of the value \u2014 it does not need to be an array with one value with a key matching the argument/property name.</p> <p>This can be useful when the application has control over the format of the  source given to the mapper, in order to lessen the structure of input.</p> <pre><code>final class Identifier\n{\n    public readonly string $value;\n}\n\nfinal class SomeClass\n{\n    public readonly Identifier $identifier;\n\n    public readonly string $description;\n}\n\n$mapper = (new \\CuyZ\\Valinor\\MapperBuilder())-&gt;mapper();\n\n$mapper-&gt;map(SomeClass::class, [\n    'identifier' =&gt; [\n        // \ud83d\udc4e The `value` key feels a bit excessive\n        'value' =&gt; 'some-identifier'\n    ],\n    'description' =&gt; 'Lorem ipsum\u2026',\n]); \n\n$mapper-&gt;map(SomeClass::class, [\n    // \ud83d\udc4d The input has been flattened and is easier to read\n    'identifier' =&gt; 'some-identifier',\n    'description' =&gt; 'Lorem ipsum\u2026',\n]);\n</code></pre>"},{"location":"usage/type-reference/","title":"Type reference","text":"<p>To prevent conflicts or duplication of the type annotations, this library tries to handle most of the type annotations that are accepted by PHPStan and Psalm.</p>"},{"location":"usage/type-reference/#scalar","title":"Scalar","text":"<pre><code>final class SomeClass\n{\n    public function __construct(\n        private bool $boolean,\n\n        private float $float,\n\n        private int $integer,\n\n        /** @var positive-int */\n        private int $positiveInteger,\n\n        /** @var negative-int */\n        private int $negativeInteger,\n\n        /** @var non-positive-int */\n        private int $nonPositiveInteger,\n\n        /** @var non-negative-int */\n        private int $nonNegativeInteger,\n\n        /** @var int&lt;-42, 1337&gt; */\n        private int $integerRange,\n\n        /** @var int&lt;min, 0&gt; */\n        private int $integerRangeWithMinRange,\n\n        /** @var int&lt;0, max&gt; */\n        private int $integerRangeWithMaxRange,\n\n        private string $string,\n\n        /** @var non-empty-string */\n        private string $nonEmptyString,\n\n        /** @var numeric-string */\n        private string $numericString,\n\n        /** @var class-string */\n        private string $classString,\n\n        /** @var class-string&lt;SomeInterface&gt; */\n        private string $classStringOfAnInterface,\n    ) {}\n}\n</code></pre>"},{"location":"usage/type-reference/#object","title":"Object","text":"<pre><code>final class SomeClass\n{\n    public function __construct(\n        private SomeClass $class,\n\n        private DateTimeInterface $interface,\n\n        /** @var SomeInterface&amp;AnotherInterface */\n        private object $intersection,\n\n        /** @var SomeCollection&lt;SomeClass&gt; */\n        private SomeCollection $classWithGeneric,\n    ) {}\n}\n\n/**\n * @template T of object \n */\nfinal class SomeCollection\n{\n    public function __construct(\n        /** @var array&lt;T&gt; */\n        private array $objects,\n    ) {}\n}\n</code></pre>"},{"location":"usage/type-reference/#array-lists","title":"Array &amp; lists","text":"<pre><code>final class SomeClass\n{\n    public function __construct(\n        /** @var string[] */\n        private array $simpleArray,\n\n        /** @var array&lt;string&gt; */\n        private array $arrayOfStrings,\n\n        /** @var array&lt;string, SomeClass&gt; */\n        private array $arrayOfClassWithStringKeys,\n\n        /** @var array&lt;int, SomeClass&gt; */\n        private array $arrayOfClassWithIntegerKeys,\n\n        /** @var array&lt;non-empty-string, string&gt; */\n        private array $arrayOfClassWithNonEmptyStringKeys,\n\n        /** @var array&lt;'foo'|'bar', string&gt; */\n        private array $arrayOfClassWithStringValueKeys,\n\n        /** @var array&lt;42|1337, string&gt; */\n        private array $arrayOfClassWithIntegerValueKeys,\n\n        /** @var array&lt;positive-int, string&gt; */\n        private array $arrayOfClassWithPositiveIntegerValueKeys,\n\n        /** @var non-empty-array&lt;string&gt; */\n        private array $nonEmptyArrayOfStrings,\n\n        /** @var non-empty-array&lt;string, SomeClass&gt; */\n        private array $nonEmptyArrayWithStringKeys,\n\n        /** @var list&lt;string&gt; */\n        private array $listOfStrings,\n\n        /** @var non-empty-list&lt;string&gt; */\n        private array $nonEmptyListOfStrings,\n\n        /** @var array{foo: string, bar: int} */\n        private array $shapedArray,\n\n        /** @var array{foo: string, bar?: int} */\n        private array $shapedArrayWithOptionalElement,\n\n        /** @var array{string, bar: int} */\n        private array $shapedArrayWithUndefinedKey,\n    ) {}\n}\n</code></pre>"},{"location":"usage/type-reference/#union","title":"Union","text":"<pre><code>final class SomeClass\n{\n    public function __construct(\n        private int|string $simpleUnion,\n\n        /** @var class-string&lt;SomeInterface|AnotherInterface&gt; */\n        private string $unionOfClassString,\n\n        /** @var array&lt;SomeInterface|AnotherInterface&gt; */\n        private array $unionInsideArray,\n\n        /** @var int|true */\n        private int|bool $unionWithLiteralTrueType;\n\n        /** @var int|false */\n        private int|bool $unionWithLiteralFalseType;\n\n        /** @var 404.42|1337.42 */\n        private float $unionOfFloatValues,\n\n        /** @var 42|1337 */\n        private int $unionOfIntegerValues,\n\n        /** @var 'foo'|'bar' */\n        private string $unionOfStringValues,\n    ) {}\n}\n</code></pre>"},{"location":"usage/type-reference/#class-constants","title":"Class constants","text":"<pre><code>final class SomeClassWithConstants\n{\n    public const FOO = 1337;\n\n    public const BAR = 'bar';\n\n    public const BAZ = 'baz';\n}\n\nfinal class SomeClass\n{\n    public function __construct(\n        /** @var SomeClassWithConstants::FOO|SomeClassWithConstants::BAR */\n        private int|string $oneOfTwoCasesOfConstants,\n\n        /** @param SomeClassWithConstants::BA* (matches `bar` or  `baz`) */\n        private string $casesOfConstantsMatchingPattern,\n    ) {}\n}\n</code></pre>"},{"location":"usage/type-reference/#enums","title":"Enums","text":"<pre><code>enum SomeEnum\n{\n    case FOO;\n    case BAR;\n    case BAZ;\n}\n\nfinal class SomeClass\n{\n    public function __construct(\n        private SomeEnum $enum,\n\n        /** @var SomeEnum::FOO|SomeEnum::BAR */\n        private SomeEnum $oneOfTwoCasesOfEnum,\n\n        /** @var SomeEnum::BA* (matches BAR or BAZ) */\n        private SomeEnum $casesOfEnumMatchingPattern,\n    ) {}\n}\n</code></pre>"},{"location":"usage/type-strictness-and-flexibility/","title":"Type strictness &amp; flexibility","text":"<p>The mapper is sensitive to the types of the data that is recursively populated \u2014 for instance a string <code>\"42\"</code> given to a node that expects an integer will make the mapping fail because the type is not strictly respected.</p> <p>Array keys that are not bound to any node are forbidden. Mapping an array <code>['foo' =&gt; \u2026, 'bar' =&gt; \u2026, 'baz' =&gt; \u2026]</code> to an object that needs only <code>foo</code> and <code>bar</code> will fail, because <code>baz</code> is superfluous. The same rule applies for shaped arrays.</p> <p>When mapping to a list, the given array must have sequential integer keys starting at 0; if any gap or invalid key is found it will fail, like for  instance trying to map <code>['foo' =&gt; 'foo', 'bar' =&gt; 'bar']</code> to <code>list&lt;string&gt;</code>.</p> <p>Types that are too permissive are not permitted \u2014 if the mapper encounters a  type like <code>mixed</code>, <code>object</code> or <code>array</code> it will fail because those types are not precise enough.</p> <p>If these limitations are too restrictive, the mapper can be made more flexible to disable one or several rule(s) declared above.</p>"},{"location":"usage/type-strictness-and-flexibility/#enabling-flexible-casting","title":"Enabling flexible casting","text":"<p>This setting changes the behaviours explained below:</p> <pre><code>$flexibleMapper = (new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;enableFlexibleCasting()\n    -&gt;mapper();\n\n// ---\n// Scalar types will accept non-strict values; for instance an integer\n// type will accept any valid numeric value like the *string* \"42\".\n\n$flexibleMapper-&gt;map('int', '42');\n// =&gt; 42\n\n// ---\n// List type will accept non-incremental keys.\n\n$flexibleMapper-&gt;map('list&lt;int&gt;', ['foo' =&gt; 42, 'bar' =&gt; 1337]);\n// =&gt; [0 =&gt; 42, 1 =&gt; 1338]\n\n// ---\n// If a value is missing in a source for a node that accepts `null`, the\n// node will be filled with `null`.\n\n$flexibleMapper-&gt;map(\n    'array{foo: string, bar: null|string}',\n    ['foo' =&gt; 'foo'] // `bar` is missing\n);\n// =&gt; ['foo' =&gt; 'foo', 'bar' =&gt; null]\n\n// ---\n// Array and list types will convert `null` or missing values to an empty\n// array.\n\n$flexibleMapper-&gt;map(\n    'array{foo: string, bar: array&lt;string&gt;}',\n    ['foo' =&gt; 'foo'] // `bar` is missing\n);\n// =&gt; ['foo' =&gt; 'foo', 'bar' =&gt; []]\n</code></pre>"},{"location":"usage/type-strictness-and-flexibility/#allowing-superfluous-keys","title":"Allowing superfluous keys","text":"<p>With this setting enabled, superfluous keys in source arrays will be allowed,  preventing errors when a value is not bound to any object property/parameter or shaped array element.</p> <pre><code>(new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;allowSuperfluousKeys()\n    -&gt;mapper()\n    -&gt;map(\n        'array{foo: string, bar: int}',\n        [\n            'foo' =&gt; 'foo',\n            'bar' =&gt; 42,\n            'baz' =&gt; 1337.404, // `baz` will be ignored\n        ]\n    );\n</code></pre>"},{"location":"usage/type-strictness-and-flexibility/#allowing-permissive-types","title":"Allowing permissive types","text":"<p>This setting allows permissive types <code>mixed</code> and <code>object</code> to be used during  mapping.</p> <pre><code>(new \\CuyZ\\Valinor\\MapperBuilder())\n    -&gt;allowPermissiveTypes()\n    -&gt;mapper()\n    -&gt;map(\n        'array{foo: string, bar: mixed}',\n        [\n            'foo' =&gt; 'foo',\n            'bar' =&gt; 42, // Could be any value\n        ]\n    );\n</code></pre>"},{"location":"usage/validation-and-error-handling/","title":"Validation and error handling","text":"<p>The source given to a mapper can never be trusted, this is actually the very goal of this library: transforming an unstructured input to a well-defined object structure. If a value has an invalid type, or if the mapper cannot cast it properly (in flexible mode), it means that it is not able to guarantee the validity of the desired object thus it will fail.</p> <p>Any issue encountered during the mapping will add an error to an upstream exception of type <code>\\CuyZ\\Valinor\\Mapper\\MappingError</code>. It is therefore always recommended wrapping the mapping function call with a try/catch statement and handle the error properly.</p> <p>When the mapping fails, the exception gives access to the root node. This recursive object allows retrieving all needed information through the whole mapping tree: path, values, types and messages, including the issues that caused the exception.</p> <p>Node messages can be customized and iterated through with the usage of the class  <code>\\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Messages</code>.</p> <pre><code>try {\n    (new \\CuyZ\\Valinor\\MapperBuilder())\n        -&gt;mapper()\n        -&gt;map(SomeClass::class, [/* \u2026 */ ]);\n} catch (\\CuyZ\\Valinor\\Mapper\\MappingError $error) {\n    // Get flatten list of all messages through the whole nodes tree\n    $messages = \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Messages::flattenFromNode(\n        $error-&gt;node()\n    );\n\n    // Formatters can be added and will be applied on all messages\n    $messages = $messages-&gt;formatWith(\n        new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\MessageMapFormatter([\n            // \u2026\n        ]),\n        (new \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\Formatter\\TranslationMessageFormatter())\n            -&gt;withTranslations([\n                // \u2026\n            ])\n    );\n\n    // If only errors are wanted, they can be filtered\n    $errorMessages = $messages-&gt;errors();\n\n    foreach ($errorMessages as $message) {\n        echo $message;\n    }\n}\n</code></pre>"},{"location":"usage/validation-and-error-handling/#custom-exception-messages","title":"Custom exception messages","text":"<p>More specific validation should be done in the constructor of the object, by throwing an exception if something is wrong with the given data.</p> <p>For security reasons, exceptions thrown in a constructor will not be caught by the mapper, unless one of the three options below is used.</p>"},{"location":"usage/validation-and-error-handling/#1-custom-exception-classes","title":"1. Custom exception classes","text":"<p>An exception that implements <code>\\CuyZ\\Valinor\\Mapper\\Tree\\Message\\ErrorMessage</code> can be thrown. The body can contain placeholders, see message customization  chapter for more information.</p> <p>If more parameters can be provided, the exception can also implement the  interface <code>\\CuyZ\\Valinor\\Mapper\\Tree\\Message\\HasParameters</code> that returns a list of string values, using keys as parameters names.</p> <p>To help identifying an error, a unique code can be provided by implementing the  interface <code>CuyZ\\Valinor\\Mapper\\Tree\\Message\\HasCode</code>.</p> <pre><code>final class SomeClass\n{\n    public function __construct(private string $value)\n    {\n        if ($this-&gt;value === 'foo') {\n            throw new SomeException('some custom parameter');\n        }\n    }\n}\n\nuse CuyZ\\Valinor\\Mapper\\Tree\\Message\\ErrorMessage;\nuse CuyZ\\Valinor\\Mapper\\Tree\\Message\\HasCode;\nuse CuyZ\\Valinor\\Mapper\\Tree\\Message\\HasParameters;\n\nfinal class SomeException extends DomainException implements ErrorMessage, HasParameters, HasCode\n{\n    private string $someParameter;\n\n    public function __construct(string $someParameter)\n    {\n        parent::__construct();\n\n        $this-&gt;someParameter = $someParameter;\n    }\n\n    public function body() : string\n    {\n        return 'Some custom message / {some_parameter} / {source_value}';\n    }\n\n    public function parameters(): array\n    {\n        return [\n            'some_parameter' =&gt; $this-&gt;someParameter,\n        ];\n    }\n\n    public function code() : string\n    {\n        // A unique code that can help to identify the error\n        return 'some_unique_code';\n    }\n}\n\ntry {\n    (new \\CuyZ\\Valinor\\MapperBuilder())-&gt;mapper()-&gt;map(SomeClass::class, 'foo');\n} catch (\\CuyZ\\Valinor\\Mapper\\MappingError $exception) {\n    // Should print:\n    // Some custom message / some custom parameter / 'foo'\n    echo $exception-&gt;node()-&gt;messages()[0];\n}\n</code></pre>"},{"location":"usage/validation-and-error-handling/#2-use-provided-message-builder","title":"2. Use provided message builder","text":"<p>The utility class <code>\\CuyZ\\Valinor\\Mapper\\Tree\\Message\\MessageBuilder</code> can be used to build a message.</p> <pre><code>final class SomeClass\n{\n    public function __construct(private string $value)\n    {\n        if (str_starts_with($this-&gt;value, 'foo_')) {\n            throw \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\MessageBuilder::newError(\n                'Some custom error message: {value}.'\n            )\n            -&gt;withCode('some_code')\n            -&gt;withParameter('value', $this-&gt;value)\n            -&gt;build();\n        }\n    }\n}\n\ntry {\n    (new \\CuyZ\\Valinor\\MapperBuilder())-&gt;mapper()-&gt;map(\n        SomeClass::class, 'foo_bar'\n    );\n} catch (\\CuyZ\\Valinor\\Mapper\\MappingError $exception) {\n    // Should print:\n    // &gt; Some custom error message: foo_bar.\n    echo $exception-&gt;node()-&gt;messages()[0];\n}\n</code></pre>"},{"location":"usage/validation-and-error-handling/#3-allow-third-party-exceptions","title":"3. Allow third party exceptions","text":"<p>It is possible to set up a list of exceptions that can be caught by the mapper, for instance when using lightweight validation tools like Webmozart Assert.</p> <p>It is advised to use this feature with caution: userland exceptions may contain sensible information \u2014 for instance an SQL exception showing a part of a query should never be allowed. Therefore, only an exhaustive list of carefully chosen exceptions should be filtered.</p> <pre><code>final class SomeClass\n{\n    public function __construct(private string $value)\n    {\n        \\Webmozart\\Assert\\Assert::startsWith($value, 'foo_');\n    }\n}\n\ntry {\n    (new \\CuyZ\\Valinor\\MapperBuilder())\n        -&gt;filterExceptions(function (Throwable $exception) {\n            if ($exception instanceof \\Webmozart\\Assert\\InvalidArgumentException) {\n                return \\CuyZ\\Valinor\\Mapper\\Tree\\Message\\MessageBuilder::from($exception);\n            } \n\n            // If the exception should not be caught by this library, it\n            // must be thrown again.\n            throw $exception;\n        })\n        -&gt;mapper()\n        -&gt;map(SomeClass::class, 'bar_baz');\n} catch (\\CuyZ\\Valinor\\Mapper\\MappingError $exception) {\n    // Should print something similar to:\n    // &gt; Expected a value to start with \"foo_\". Got: \"bar_baz\"\n    echo $exception-&gt;node()-&gt;messages()[0];\n}\n</code></pre>"}]}